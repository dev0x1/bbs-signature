{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-04-07T00:08:33.536781+00:00",
  "repo": "decentralized-identity/bbs-signature",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "current-signature-specification",
      "description": "Issues associated to the current BBS signature specification that previous implementations used",
      "color": "185E2C"
    },
    {
      "name": "ready-for-pr",
      "description": "",
      "color": "CD2B82"
    },
    {
      "name": "dont-merge-yet",
      "description": "",
      "color": "24BAA2"
    },
    {
      "name": "pending-close",
      "description": "",
      "color": "829ED9"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU5OTUxOTA5Mzg=",
      "title": "Update specification to document the usage of hash 2 curve draft 6",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/1",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "current-signature-specification"
      ],
      "body": "Current implementations of BBS signatures are using hash 2 curve draft 6, this should be noted in the document for those wanting to build interoperable implementations as subsequent revisions of the hash 2 curve draft have been breaking.",
      "createdAt": "2021-09-13T18:20:38Z",
      "updatedAt": "2022-03-21T02:31:36Z",
      "closedAt": "2022-03-21T02:31:35Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead",
          "createdAt": "2021-09-13T18:20:54Z",
          "updatedAt": "2021-09-13T18:20:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing this issue as the draft has moved to documenting the most recent version of the signature scheme rather than the current state of implementations",
          "createdAt": "2022-03-21T02:31:35Z",
          "updatedAt": "2022-03-21T02:31:35Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU5OTUxOTM5OTg=",
      "title": "Document the binary formats for cryptographic structures defined by the specification",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/2",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Within the draft there are several new cryptographic structures that are encoded in binary, their format should be documented to support interoperable implementations, these include\r\n\r\n- ProofOfKnowledge (signature proof)\r\n- Commitment\r\n- Commitment ProofOfKnowledge\r\n- BBS Signature",
      "createdAt": "2021-09-13T18:24:25Z",
      "updatedAt": "2022-03-21T02:37:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead",
          "createdAt": "2021-09-13T18:24:44Z",
          "updatedAt": "2021-09-13T18:24:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "A topic for future discussion is whether to use a structured (e.g CBOR) vs custom binary format, current implementations use a custom binary format however structured solutions like CBOR could be considered for future revisions.",
          "createdAt": "2021-09-13T18:28:59Z",
          "updatedAt": "2021-09-13T18:28:59Z"
        },
        {
          "author": "ChristopherA",
          "authorAssociation": "NONE",
          "body": "I\u2019m hoping you document CBOR versions of these (and not the IPFS version of CBOR). We are increasingly using CBOR in wallet interoperability standards as it allows airgap solutions like UR: \r\n\r\n* https://github.com/BlockchainCommons/crypto-commons#urs\r\n* https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-005-ur.md",
          "createdAt": "2021-10-05T03:12:53Z",
          "updatedAt": "2021-10-05T03:12:53Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we will want to reference the [pairing-friendly curves](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-zcash-serialization-format-) RFC at least for BLS12-381. It is supposedly undergoing changes to make the draft more normative (and hopefully move beyond a draft). We would probably want to have each profile specify the binary encoding for scalars and group elements for its related pairing-friendly curve, and then define things like the signature binary format on top of that.",
          "createdAt": "2022-01-26T17:29:42Z",
          "updatedAt": "2022-01-26T17:30:04Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "#66 adds a preliminary serialisation format for the signature, however the proof representation is still un-documented",
          "createdAt": "2022-03-21T02:37:47Z",
          "updatedAt": "2022-03-21T02:37:47Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU5OTUyMDE3MDM=",
      "title": "Seperate the message generators from the public key",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/3",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "current-signature-specification"
      ],
      "body": "Currently the specification uses the term \"deterministic public key\" to refer to the underlying public key + message generators required to commit a series of messages to in order to construct a BBS signature signed by an issuer. This association has been found to be confusing and the suggested clarification is to remove the concept of a \"deterministic public key\" and instead just have a public key and a set of message generators with a defined process under which they are generated.",
      "createdAt": "2021-09-13T18:34:21Z",
      "updatedAt": "2022-01-13T01:28:38Z",
      "closedAt": "2022-01-13T01:28:38Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing in favour of #19 which has more elaboration on the alternatives to explore",
          "createdAt": "2022-01-13T01:28:31Z",
          "updatedAt": "2022-01-13T01:28:31Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU5OTUyMDYxNjM=",
      "title": "Elaborate on background around group signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/4",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Because the concept of a \"group signature\" is a lesser known term in the wider community that uses digital signature technology it would provide a good opportunity for education around some of the novel features of these types of cryptographic schemes provide if the spec included some of this background",
      "createdAt": "2021-09-13T18:40:14Z",
      "updatedAt": "2021-09-13T18:40:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7",
          "createdAt": "2021-09-13T18:40:41Z",
          "updatedAt": "2021-09-13T18:40:41Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU5OTUyMDkwMDI=",
      "title": "Change digest algorithm used to SHAKE256",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/5",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There are three different ways a digest algorithm is used in a BBS Signature\r\n\r\n1. Message generators\r\n2. Doing deterministic signature generation\r\n3. Proof - for the fiat shamir heuristic\r\n\r\nCurrent implementations use BLAKE2B however this is a non-NIST approved digest algorithm making alignment more difficult the suggestion is to shift to using SHAKE256 for the above applications",
      "createdAt": "2021-09-13T18:44:02Z",
      "updatedAt": "2022-02-23T09:32:58Z",
      "closedAt": "2022-02-23T09:32:58Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed via #65 ",
          "createdAt": "2022-02-23T09:32:58Z",
          "updatedAt": "2022-02-23T09:32:58Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU5OTUyMTYxMzU=",
      "title": "How to map data to be cryptographically signable",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/6",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Describe the process for how to map abitrary data to be in a sign-able form.\r\n\r\nThe current way in which this is done is the data is hashed and the first 48 bytes are used, this is then reduced to the first sub-group order, _mod Q_.\r\n\r\nIn future there may be new options for this process:\r\n\r\n1. Hash the data (approach depended on #5) take the 64 byte output and then reduce the data to the first sub-group order, _mod Q_.\r\n2. Mapping integers - provides the basis for range proofs\r\n3. Mapping floating point numbers\r\n4. Sortable data, e.g anything that has lexiographical ordering\r\n\r\n@mikelodder7 can provide further details",
      "createdAt": "2021-09-13T18:53:57Z",
      "updatedAt": "2022-02-16T04:42:17Z",
      "closedAt": "2022-02-16T04:42:16Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing in favour of #40 which has more details thanks to @mikelodder7 ",
          "createdAt": "2022-02-16T04:42:16Z",
          "updatedAt": "2022-02-16T04:42:16Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOF8lax84781G5",
      "title": "Test vectors",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/7",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In order to facilitate interoperability this specification should contain a set of test vectors for the cryptographic structures defined",
      "createdAt": "2021-09-23T20:06:50Z",
      "updatedAt": "2022-02-23T21:50:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Initial test vectors for the signature have been contributed in #67, the remaining will be contributed once the proof serialization is settled.",
          "createdAt": "2022-02-23T21:50:11Z",
          "updatedAt": "2022-02-23T21:50:11Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOF8lax848HfxV",
      "title": "Crypto agility",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/8",
      "state": "CLOSED",
      "author": "schanzen",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current draft is partially agnostic to the cryptographic details and in other parts very specific.\r\nFor example, the choice of curve is left open: https://github.com/schanzen/bbs-signature/blob/main/spec.md#choice-of-signature-primitive\r\nBut, the curve is implicitly enforced in https://github.com/schanzen/bbs-signature/blob/main/spec.md#terminology along with other primitives such as the hash functions.\r\nThis will make #7 a bit awkward to fix.\r\n\r\nI guess the specification could be very specific to only define a concrete instantiation or abstract to allow crypto agility.\r\nThe latter may require additional metadata in the objects.\r\n\r\nRelated to #5 as well. Maybe hashfunctions should be harmonized for the initial recommendation/instantiation?",
      "createdAt": "2021-09-27T20:54:15Z",
      "updatedAt": "2022-02-23T09:35:08Z",
      "closedAt": "2022-02-23T09:34:56Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks for raising, I agree along side the hashing algorithm as we discussed on the most recent call the underlying curve used should be left open. Could you elaborate on where in the terminology section this is currently not the case?",
          "createdAt": "2021-09-30T19:45:33Z",
          "updatedAt": "2021-09-30T19:45:33Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "Under  https://github.com/schanzen/bbs-signature/blob/main/spec.md#terminology you are defining ```dst```,  ```hash_to_curve_g1```, and ```hash_to_curve_g2``` with a parameter which is tied to BLS12-381: BLS12381G1_XMD:BLAKE2B_SSWU_RO_BBS_SIGNATURES:1_0_0 and BLS12381G1_XMD:BLAKE2B_SSWU_RO, respectively.\r\n\r\nThe ```dst``` parameter should probably be different depending on the used hash and curve and so should the algo for the hash_to_curve.",
          "createdAt": "2021-09-30T20:04:09Z",
          "updatedAt": "2021-09-30T20:04:09Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "I guess the question is if the \"BBS+ Signature Scheme\" is supposed look like https://datatracker.ietf.org/doc/html/rfc6979 where you then have specific instantiations in the test vectors: https://datatracker.ietf.org/doc/html/rfc6979#appendix-A.2.5\r\nOr if it should be more like https://www.rfc-editor.org/rfc/rfc8032 where the choice of primitives is taken away (on purpose).\r\nOne could make the argument that the approach of EdDSA is more sensible as implementors will make less errors, but maybe the scheme itself should then also be qualified. Ex: \"The BLS12-381-SHAKE-BBS+ signature scheme\" or similar.",
          "createdAt": "2021-09-30T20:17:57Z",
          "updatedAt": "2021-09-30T20:20:39Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "> One could make the argument that the approach of EdDSA is more sensible as implementors will make less errors...\r\n\r\n+1 to this approach.",
          "createdAt": "2021-10-04T21:27:57Z",
          "updatedAt": "2021-10-04T21:27:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Yeah +1 being overly cryptographically agile is a security and implementation risk, I would suggest the best middle ground is to position the draft with a single definition of DIGEST_ALGORITHM / HASH_ALGORITHM rather than having the concrete algorithm repeated throughout as it is currently.",
          "createdAt": "2021-10-07T20:09:57Z",
          "updatedAt": "2021-10-07T20:09:57Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "Yeah, it's one thing to make sure your core design is flexible and pluggable. It's another thing to surface that flexibility all the way up your stack to implementers/users that can make bad mistakes with the wrong choices. Eliminate choice at those top layers to help protect implementers/users.",
          "createdAt": "2021-10-07T22:15:28Z",
          "updatedAt": "2021-10-07T22:15:28Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "The other point I was trying to make is that the \"name\" of the draft is currently very generic \"BBS Signature Scheme\" while what is proposed is actually much more specific. It may be time to give the proposed scheme a dedicated (new) name? My reasoning is that it basically squats the concept of \"BBS+ Signature Schemes\" which may lead to confusion in the future especially of schemes based on other curves pop up.",
          "createdAt": "2021-10-08T08:16:25Z",
          "updatedAt": "2021-10-08T08:16:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> My reasoning is that it basically squats the concept of \"BBS+ Signature Schemes\" which may lead to confusion in the future especially of schemes based on other curves pop up\r\n\r\nI think this is asking another cryptographic agility question here seperate from the selection of the digest algorithm, which is should the draft couple itself to a particular pairing based curve (e.g BLS 12-381). The decision to mandate a particular digest algorithm does not necessarily mean we have to do the same in regards to the curve. Leaving the draft open to new curves makes it more like ECDSA rather than EdDSA in this respect. ",
          "createdAt": "2021-10-10T20:44:14Z",
          "updatedAt": "2021-10-10T20:44:14Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "> > My reasoning is that it basically squats the concept of \"BBS+ Signature Schemes\" which may lead to confusion in the future especially of schemes based on other curves pop up\r\n> \r\n> I think this is asking another cryptographic agility question here seperate from the selection of the digest algorithm, which is should the draft couple itself to a particular pairing based curve (e.g BLS 12-381). The decision to mandate a particular digest algorithm does not necessarily mean we have to do the same in regards to the curve. Leaving the draft open to new curves makes it more like ECDSA rather than EdDSA in this respect.\r\n\r\nThe (albeit theoretical) issue I have with \"BBS Signature Scheme\" is that this specifier existed before this (more specific) draft. So if anybody ever writes down \"We are using the BBS Signature Scheme\" it is ambiguous if this refers to any implementation of the proposed scheme from a paper or this specific proposal. On the other hand is is 100% unambiguous if somebody writes ECDSA or EdDSA, respectively. There is only one way to do those, and they can be found in RFCs. The issue is that the draft is using a name which is, essentially, already \"taken\" and that may lead to issues unless this becomes **the** de-facto standard and \"overtaking\" the meaning of \"BBS Signatures\" which cannot be guaranteed.\r\n\r\nTo be more specific:\r\n1. \"BBS Signature\" is defined here: D. Boneh, X. Boyen, and H. Shacham. Short Group Signatures.\r\n2. \"BBS+ Signature\" is defined here: Man Ho Au, Willy Susilo, and Yi Mu. Constant-Size Dynamic k-TAA.\r\n\r\nWhat is written in the draft/specification in this repos is \"XYZ Signature Scheme\" which is _based on a_ BBS (1) or BBS+ (2) signature.\r\n",
          "createdAt": "2021-10-11T10:36:36Z",
          "updatedAt": "2021-10-11T10:56:37Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "Just adding here a point raised by @tplooker in today's meeting: The wip draft (#3) conceptually deviates from the one proposed in the papers with respect to the deterministic generation of message commitments. Which makes the draft even more a variation of BBS which uses/proposes the use of nonce values.",
          "createdAt": "2021-10-11T20:31:24Z",
          "updatedAt": "2021-10-11T20:32:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "During the delayed call today we discussed taking this draft in the direction of supporting several key cryptographic extension points, e.g \"agile\". And then defining profiles on top which promote interoperable implementations. \r\n\r\nSome of the rational for this was noted through how elliptic curve cryptography was developed, essentially ECDSA when it was developed preceded formal standardisation of particular elliptic curves, hence the need to remain agnostic. Within the sub-field of pairing cryptography we find a similar situation where by multiple curves are showing promise and adoption however innovation and development continue to occur here. Therefore rather than the draft picking one winner, a set of security criteria could be defined that allows different pairing friendly curves to be used.\r\n\r\nGoing in this direction with the draft would mean the follow elements would be abstractly defined\r\n- The hash algorithm\r\n- The pairing friendly curve",
          "createdAt": "2021-11-02T01:40:06Z",
          "updatedAt": "2021-11-02T01:40:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@schanzen the direction this draft has taken is to define [ciphersuites](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-ciphersuites), the exact format is still a W.I.P, but do you feel this is addressing this issue?",
          "createdAt": "2022-02-15T08:50:29Z",
          "updatedAt": "2022-02-15T08:50:29Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Assuming this issue has now been addressed given an approach has been agreed by the working group as described above, please re-open if you do not feel it has been.",
          "createdAt": "2022-02-23T09:34:55Z",
          "updatedAt": "2022-02-23T09:35:08Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOF8lax8480yF_",
      "title": "Proof of knowledge revealed message structure",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/10",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Related to #2 \r\n\r\nCurrently the implementations of a BBS proof of knowledge signature includes the encoding of a binary structure at the start of the proof which captures which of the messages being verified and how they correspond to the original ordering of the message set signed. Currently this structure takes the form of a bit array.\r\n\r\nFor example assume the following set of messages were originally signed\r\n\r\n```\r\n[\r\n  \"message1\"\r\n  \"message2\",\r\n  \"message3\",\r\n  \"message4\",\r\n  \"message5\"\r\n]\r\n```\r\n\r\nAnd a proof revealing only the 1st 4th and 5th message was generated, meaning the revealed messages supplied during the verify proof operation would appear in the following order\r\n\r\n```\r\n[\r\n  \"message1\",\r\n  \"message4\",\r\n  \"message5\"\r\n]\r\n```\r\n\r\nThe resulting bit array in the proof would take the following form\r\n\r\n```\r\n+-----------------------------+-----------------------------+---------------------------------+\r\n| Total messages length (16bit)| Revealed messages bit array |..... remaining proof structure |\r\n+-----------------------------+-----------------------------+---------------------------------+\r\n\r\n+-----------+--------------+-----------------------------------+\r\n| 5 (integer) | 1 | 0 | 0 | 1 | 1  | ..... remaining proof structure |\r\n+-----------+--------------+-----------------------------------+\r\n```\r\n\r\nHowever, this mechanism of expression does limit options around the data canonicalisation algorithm that is used on top of the cryptographic scheme. Namely it does not support a re-ordering of the revealed messages away from the order in which they were originally signed. To accomodate this we could instead elect to change the expression of this aspect of the proof from a bit array to a byte/multi-byte array, where instead the array contents is a set of un-signer integers (16bit each) where each integer corresponds to the index the message occupied in the original ordering of the signed message set\r\n\r\nFor example assume the following set of messages were originally signed\r\n\r\n```\r\n[\r\n  \"message1\",\r\n  \"message2\",\r\n  \"message3\",\r\n  \"message4\",\r\n  \"message5\"\r\n]\r\n```\r\n\r\nAnd a proof revealing only the 1st 4th and 5th message was generated, **BUT** the messages in the resulting proof are re-ordered so that they present as 4, 5, 1 \r\n\r\n```\r\n[\r\n  \"message4\",\r\n  \"message5\",\r\n  \"message1\"\r\n]\r\n```\r\n\r\nThe resulting bit array in the proof would take the following form\r\n\r\n```\r\n+-----------------------------+----------------------------------------+-------------------------------+----------------+\r\n| Total messages length (16bit)| Revealed messages array length (16bit) | Revealed messages byte array | remaining proof |\r\n+-----------------------------+----------------------------------------+-------------------------------+----------------+\r\n\r\n+--+--+--------+------------------------------+\r\n| 5  | 3 | 4 | 5 | 1 | ..... remaining proof structure |\r\n+--+--+--------+------------------------------+\r\n```\r\n\r\nThe tradeoff here is that the overhead of this structure is more than in the simpler case with the bit array.\r\n\r\n**NOTE** It is probably also worth considering a more standard structured binary format like CBOR rather than a custom structure ",
      "createdAt": "2021-10-07T21:15:45Z",
      "updatedAt": "2022-01-23T19:45:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> Namely it does not support a re-ordering of the revealed messages away from the order in which they were originally signed.\r\n\r\nCould you expand on this some? I'm missing the context of why canonicalization would force the messages to be ordered differently, in any approach the original index must be preserved so why can't they be correctly re-ordered before being serialized?",
          "createdAt": "2021-10-07T21:29:33Z",
          "updatedAt": "2021-10-07T21:29:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@quartzjer good question, An example is RDF Dataset normalisation, when you have a graph that features several blank nodes, and then you create a sub-graph from this (e.g your sub-set of revealed messages). The ordering of the \"statements\" in the canonical form of the sub-graph can be different to that of the original graph.",
          "createdAt": "2021-10-07T21:47:45Z",
          "updatedAt": "2021-10-07T21:47:45Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "@quartzjer its related to graph isomorphism and canonicalization of derived subgraphs... basically, the derive operation is an object transformation... (graph 1 -> graph 2).\r\n\r\n```\r\ngraph 1 -> [messages order that is signed over]\r\ngraph 2 -> [messages order can be different]\r\n```\r\n\r\nThis a problem because of the compact use of hash to point... the order is exploited to make the proof compact... we can't do that with merkle proofs, which is part of why the proof size is so much larger... ",
          "createdAt": "2021-10-07T21:52:20Z",
          "updatedAt": "2021-10-07T21:52:20Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "That context is helpful and makes sense.  It does still seem a bit odd to me though, adding metadata that doesn't directly impact/support the crypto methods and is intended to work around a limitation of a higher layer.\r\n\r\nMore troublesome though, it also exposes a correlation vector.  How the revealed messages are re-ordered by the canonicalization leaks some information about the original ordering of the non-revealed messages.  It may seem like a small leak, but all leaks can be exploited once you have enough data.",
          "createdAt": "2021-10-07T22:12:15Z",
          "updatedAt": "2021-10-07T22:12:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I think the meta-question here is what constraints does the cryptographic layer impose around what canonicalisation algorithms can be used above it.\r\n\r\n> More troublesome though, it also exposes a correlation vector. How the revealed messages are re-ordered by the canonicalization leaks some information about the original ordering of the non-revealed messages. It may seem like a small leak, but all leaks can be exploited once you have enough data.\r\n\r\nYes this is a valid point, however its important to note its not guaranteed that the algorithm for re-ordering the revealed messages will actually leak information, that aspect IMO could be addressed via privacy/security considerations. ",
          "createdAt": "2021-10-08T01:24:58Z",
          "updatedAt": "2021-10-08T01:24:58Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> its not guaranteed that the algorithm for re-ordering the revealed messages will actually leak information\r\n\r\nIt is actually guaranteed, even just simply the fact that they are re-ordered is a leak having nothing to do with the algorithm that does it.  If the issuer and the holder use different ordering, it's a vector to exploit.\r\n\r\n> that aspect IMO could be addressed via privacy/security considerations.\r\n\r\nSure, I just get uncomfortable seeing that adding built-in support for re-ordered indexes increases linkability (if used). ",
          "createdAt": "2021-10-08T15:51:37Z",
          "updatedAt": "2021-10-08T15:51:37Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue is only coming about because the input to the signature in this situation is a set of statements with their own independent ordering (the n-quads). To me that seems outside of the scope of the signature method itself, in that it could easily be handled at a higher layer by providing additional input mapping the statement order to the signed message order, or by manually reordering the statements. In fact I did not expect us to define an encoding for the revealed message indices at all, again leaving that up to concrete implementations (the LD-proof in this case).",
          "createdAt": "2021-10-08T16:02:57Z",
          "updatedAt": "2021-10-08T16:02:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This conversation has been great to draw out the different possible design options we can accomodate at the cryptographic layer for BBS signatures.\r\n\r\n1. The structure for a BBS proof of knowledge is defined in a way that it features no information about which of the revealed messages correspond to in the order in which they were originally signed (required to be able to do a verify proof operation). This would mean verify proof would require a new seperate argument to be supplied alongside the public key proof and revealed message set.\r\n2. The structure for a BBS proof of knowledge is defined in a way that features a preceding bit array where each bit of the array indicates where the message was revealed or not. This means the revealed message set MUST be ordered in the same order as it was originally signed (with un-revealed messages simply removed).\r\n3.  The structure for a BBS proof of knowledge is defined in a way that features a preceding byte array, which is essentially the proposal at the start of this issue.",
          "createdAt": "2021-10-10T20:18:07Z",
          "updatedAt": "2021-10-10T20:18:07Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "@tplooker,\r\n\r\nIs this issue related at all to a discussion we had about introducing the use of an HMAC key (that remains secret to both the issuer and holder, i.e., never shared with any verifier) that is used to generate blank node IDs prior to signing -- to fully obscure any information about how those IDs were chosen (i.e., no matter how the canonicalization algorithm works, the IDs would appear random to verifiers)?",
          "createdAt": "2021-10-18T15:42:30Z",
          "updatedAt": "2021-10-18T15:42:30Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@dlongley yes more specifically my comment here\r\n\r\n> Yes this is a valid point, however its important to note its not guaranteed that the algorithm for re-ordering the revealed messages will actually leak information, that aspect IMO could be addressed via privacy/security considerations.\r\n\r\nOtherwise in general the issue is discussing more broadly what mechanisms should be at the cryptographic layer vs deferred to higher layers.",
          "createdAt": "2021-10-20T19:06:33Z",
          "updatedAt": "2021-10-20T19:06:33Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "Could someone (perhaps @tplooker or @brianorwhatever?) provide an example (the simplest possible) of a JSON-LD VC that cannot be verified using BBS+, annotating it with how the problem manifests? I'm trying to understand the scope of the issue, and especially, the scope in real world use cases.  Is it anytime that nesting is used, or is it a certain pattern of nesting?  How can a non-JSON-LD person understand the impact?\r\n\r\nThanks!",
          "createdAt": "2021-11-17T19:48:44Z",
          "updatedAt": "2021-11-17T19:48:44Z"
        },
        {
          "author": "brianorwhatever",
          "authorAssociation": "NONE",
          "body": "@swcurran I would take a look at @tplooker comment here https://github.com/mattrglobal/jsonld-signatures-bbs/issues/158#issuecomment-945238151 for the most succint description of the problem. My impression is that it is basically going to happen whenever there is nested objects (unsure how many will trigger it) within the `credentialSubject` that don't have an `id` attribute",
          "createdAt": "2021-11-18T00:59:26Z",
          "updatedAt": "2021-11-18T00:59:26Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "It's helpful but not an example of the JSON-LD that triggers the issue. However, [your comment in that same issue](https://github.com/mattrglobal/jsonld-signatures-bbs/issues/158#issue-1005912071) has an example.\r\n\r\nAs I understand @tplooker's explanation that [you reference](https://github.com/mattrglobal/jsonld-signatures-bbs/issues/158#issuecomment-945238151), the issue manifests in your credential by the existence of the `recipient` and `vaccine` items with no `id` below them.  Presumably, if you had just one item, or all (or all but one) had an `id`, life would be good. And presumably, anytime there is more than one such item anywhere in the JSON will trigger the problem.\r\n\r\nThat's going to be pretty rough for anyone that wants to use an existing structure as a VC.\r\n\r\n",
          "createdAt": "2021-11-18T01:29:21Z",
          "updatedAt": "2021-11-18T01:29:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@swcurran The problem is related to, but not directly caused, by the serialization algorithm (i.e., URDNA). The problem in the example is caused by the way the Holder communicated the indexes of the revealed messages to the Verifier, because it does not account for the fact that the messages received by the Verifier may not be in the same order that the Holder has them (because of URDNA).\r\n\r\nAs an example, let\u2019s say that the Holder has messages `m1`, `m2` and `m3` and creates a proof disclosing only `m2` and `m3`. What was proposed to let the Verifier know what messages are disclosed, is that the Holder will also send the bit array `011` indicating that they have 3 messages and that they disclosed the 2nd and the 3rd one. However, if the Verifier gets the messages as `[m3, m2]` (correct messages, wrong order) they will use `m3` like it was the 2nd Holder\u2019s message and `m2` like it was the third. That miss-match will make the verification fail. \r\n\r\nThe solution however is not to put `id's` to every nested object in the VC (although that could also work). The simple solution is to communicate the indexes of the revealed messages in a way that will account for the case above. One way to do that is instead of the Holder sending the bit array `011` to send the integers list `[3, 2]` which solves that problem.",
          "createdAt": "2021-12-02T11:20:46Z",
          "updatedAt": "2021-12-02T11:20:46Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "Thanks.  Agree that what you state is the \"simple solution\", but in reality that means agreeing on the exact simple solution, publishing it as a new signature scheme, updating libraries and then updating the existing applications that use those libraries so that arbitrary JSON-LD can be used. That would suggest a long delay in being able to use of BBS+ credentials for general use cases.  Thus, I agree that adding in IDs is not the correct solution, it is a practical hack that will work for the existing scheme.\r\n\r\nI noticed, for example, that in publishing the BBS+ version of the mDL schema, that approach was used throughout.",
          "createdAt": "2021-12-02T17:41:28Z",
          "updatedAt": "2021-12-02T17:41:28Z"
        },
        {
          "author": "brianorwhatever",
          "authorAssociation": "NONE",
          "body": "do you have a link to the bbs+ mdl schema @swcurran? sounds interesting!",
          "createdAt": "2021-12-02T18:45:51Z",
          "updatedAt": "2021-12-02T18:45:51Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "You can follow the chain to see the approach.  Start here: https://digitalbazaar.github.io/vdl-test-suite/ (Manu posted about this in the W3C CCG).  From the examples, the context for a \"vDL\" is https://w3id.org/vdl/v1, which resolves to a chunk of JSON that has just has an id for each attribute in the form of:\r\n\r\n``` jsonc\r\n       ...\r\n        \"family_name\": {\r\n          \"@id\": \"https://w3id.org/vdl#family_name\"\r\n        },\r\n        \"given_name\": {\r\n          \"@id\": \"https://w3id.org/vdl#given_name\"\r\n        },\r\n        \"birth_date\": {\r\n          \"@id\": \"https://w3id.org/vdl#birth_date\"\r\n        },\r\n        ...\r\n```\r\n\r\nI don't know a lot about JSON-LD and perhaps those @id's per attribute are normal.  But I would image they don't contribute much to the semantic understanding (human or machine) of the attributes -- but they do provide an ID.\r\n\r\n",
          "createdAt": "2021-12-02T19:29:18Z",
          "updatedAt": "2021-12-02T19:29:18Z"
        },
        {
          "author": "brianorwhatever",
          "authorAssociation": "NONE",
          "body": "Cool, thanks for the link. I'm also not a JSON-LD expert but I believe an `@id` is more about what the node is semantically vs an identifier (`id`) for the node which is the issue in this instance. See this example https://www.w3.org/TR/json-ld/#example-4-context-for-the-sample-document-in-the-previous-section\r\n\r\nThere's also the `\"@type\": \"@id\"` line which is often seen in contexts and I don't totally understand..",
          "createdAt": "2021-12-02T21:17:44Z",
          "updatedAt": "2021-12-02T21:17:44Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "What are the consequences if the signature specification didn't include any revealed message indexes or how they're encoded, and surrendered that responsibility to higher level application suites, like Linked Data and Jose processors. This neither adds nor removes any (more) leaks from the signature format, it's just makes it less opinionated about attaching information to the signature that isn't signed over anyway. This means each application will have to define how to handle index information and not be constrained by the signature format. I believe this is how the BBS+ LD was initially implemented, but then things got moved into the crypto encoding of the signature mostly for convenience and API design style.",
          "createdAt": "2022-01-20T20:58:51Z",
          "updatedAt": "2022-01-20T21:00:24Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "+1 to making the low-level signature specification (RFC dealing with the crypto specifically) not be opinionated about message indexes or how the data is encoded but instead just receive appropriately atomized / ordered data for signing. The next layer up (e.g., Data Integrity BBS+ Signature spec / JWP spec) can define how to consume / transform / canonize / order / atomize / etc. the data that is to be passed to the crypto layer.",
          "createdAt": "2022-01-20T21:54:11Z",
          "updatedAt": "2022-01-20T21:54:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @tmarkovski @dlongley for adding to the conversation I agree with much of the sentiment shared. In an effort to clarify further, listed below are the most relevant hard requirements BBS Signatures as a crypto scheme has that is influential in designing the contract/interface and related data structures for a derived BBS proof.\r\n\r\n- When verifying a derived BBS proof, the verifying party must know the total number of messages that were originally signed when the signature was created.\r\n- When verifying a derived BBS proof, for any revealed messages (messages that the holder or prover wishes to prove were signed by an issuer), the verifying party must know the placement each revealed message occupied in the original set of messages that were signed.\r\n\r\nFrom my understanding of the opinions shared in this issue and also via DIF slack, is that most people are supportive of a proposal where the cryptographic layer has no opinion about the message indexes leaving it to upstream technologies (e.g LD-Proof or JWP) to make this definition. This means the derived BBS proof structure defined by this draft will only describe the direct cryptographic information of the proof.\r\n\r\nGiven that proposal we still need to decide how the contract for verifying a deriveProof should change, for instance the current draft defines\r\n\r\n```\r\nresult = SpkVerify(spk, PK, (msg[i],...,msg[D]), nonce)\r\n```\r\n\r\nwhere D is the number of revealed messages makes the following invalid assumptions\r\n\r\n- spk contains information on the total number of messages originally signed\r\n- spk contains some form of mapping that maps the revealed messages (msg) to their original position in the originally signed message set.\r\n\r\nOne potential proposal would be to change the contract for verifying a derivedProof to something like\r\n\r\n```\r\nresult = SpkVerify(spk, PK, revealedMessages, totalSignedMessages, nonce)\r\n```\r\n\r\nWhere revealed messages is a map of the following structure\r\n\r\n```\r\n{\r\n  1: octet_string_msg_1,\r\n  5: octet_string_msg_5,\r\n  9: octet_string_msg_9,\r\n}\r\n```\r\n",
          "createdAt": "2022-01-21T00:18:18Z",
          "updatedAt": "2022-01-21T00:18:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Another option is to retain the total signed messages as a value encoded in to `spk` to reduce the need to manage it externally, however still handle the ordering of the revealed messages in the way described above, meaning the contract would look something more like \r\n\r\n```\r\nresult = SpkVerify(spk, PK, revealedMessages, nonce)\r\n```",
          "createdAt": "2022-01-21T00:22:15Z",
          "updatedAt": "2022-01-21T00:23:01Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Is `PK` already a function of `totalSignedMessages (L)` (via `PK = DpkToPk(DPK, L)` or `PK = SkToPk(Sk, L)`)? If yes, then encoding it doesn't save much work, since the information would be needed prior to that to construct `PK`.\r\nI like your proposal with `result = SpkVerify(spk, PK, revealedMessages, totalSignedMessages, nonce)` and using a map to unambiguously describe the message input.\r\n\r\nImplementation wise, I think application suites can choose to continue to encode the signature as it is currently, by encoding the total, indexes and proof into a single field, as long as their spec is clear this is the case. That said, we may end up with `signatureValue` in LD proof having different format than signature in JWT, because one chose to encode additional data into the signature. Is this a problem overall?",
          "createdAt": "2022-01-21T13:17:49Z",
          "updatedAt": "2022-01-21T13:18:31Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  That said, we may end up with signatureValue in LD proof having different format than signature in JWT, because one chose to encode additional data into the signature. Is this a problem overall?\r\n\r\nUpon further investigation, the revealed messages re-ordering issue seems to be caused by IDs that are of similar format as the blank node labels IDs. This could have a simple solution (re-sorting after transforming back to blank node labels) that will allow the LD proofs to use a bit array appended to the proof value, as originally proposed [here](https://github.com/w3c-ccg/ldp-bbs2020/issues/22). This can also eliminate the dangers of a correlation because of the re-ordering of the revealed messages.\r\n\r\nThat been said, IMO the bbs+ spec should remain agnostic to the way the indexes of the revealed messages are encoded. This could lead to the proofValue having different formats between implementations; however, IMO this is not a problem. Higher level specs like JWP and LD-proofs will most likely want to use different formats for the revealed message indexes either way, because of the way they work.\r\n",
          "createdAt": "2022-01-21T23:16:40Z",
          "updatedAt": "2022-01-21T23:16:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Is PK already a function of totalSignedMessages (L) (via PK = DpkToPk(DPK, L) or PK = SkToPk(Sk, L))?\r\n\r\nThanks thats a good call out, which reminded me to file #26 given the resolution to that issue I am suggesting does my proposal make more sense? e.g PK would be an ordinary public key (Note - I release this change impacts several other sections in the draft).\r\n\r\n> Implementation wise, I think application suites can choose to continue to encode the signature as it is currently, by encoding the total, indexes and proof into a single field, as long as their spec is clear this is the case.\r\n\r\nYes I think the point to clarify is that from this drafts perspective any data structure like a reveal indices array would be left to a higher level draft to define.\r\n\r\n> That said, we may end up with signatureValue in LD proof having different format than signature in JWT, because one chose to encode additional data into the signature. Is this a problem overall?\r\n\r\nGiven they are different digital signature representation formats I expect divergence at some level. So long as the core structure of any signature / proof and public key value remains structually the same upstream then I dont think we can prevent additional data structures being wrapped around them? \r\n",
          "createdAt": "2022-01-23T19:43:57Z",
          "updatedAt": "2022-01-23T19:43:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> That been said, IMO the bbs+ spec should remain agnostic to the way the indexes of the revealed messages are encoded. This could lead to the proofValue having different formats between implementations; however, IMO this is not a problem. Higher level specs like JWP and LD-proofs will most likely want to use different formats for the revealed message indexes either way, because of the way they work\r\n\r\n+1 I think much of the different at these representation layers is really due to different approaches to problems like data canonicalization which should remain entirely opaque to the crypto layer (the concern of this draft)",
          "createdAt": "2022-01-23T19:45:57Z",
          "updatedAt": "2022-01-23T19:45:57Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOF8lax8488ZzG",
      "title": "Improve documentation around BBS Signature message generator procedure",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/11",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The specification currently has limited detail on how an important aspect of existing implementations of BBS associated to this draft works, that is the deterministic generation of what are known as message generators (a name that perhaps should be revisited). \r\n\r\nFor context a message generator is effectively a \"public parameter\" that is used to commit a digested message that will be protected by the resulting BBS signature. All of the message generators for all of the messages are required during sign, verify, deriveProof and verifyProof (even for those messages that remain un-revealed). For implementations of BBS signatures outside / not aligned to this draft, these generators are often communicated out of band or in conjunction with the signature or proof. \r\n\r\nImplementations following this draft however derive these generators via a deterministic process from the public key during the sign, verify, deriveProof and verifyProof operations thus removing the need to manage these generators as additional public parameter information associated to the signature.\r\n\r\nThis technique/procedure should be better documented and discussed by the working group.\r\n\r\nThis issue is also partially related to #10 in the sense that it explains why the revealed messages have to be ordered in reference to how they were signed as this provides the means to associate the correct message to its generator.\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2021-10-11T09:21:48Z",
      "updatedAt": "2022-02-16T00:59:31Z",
      "closedAt": "2022-02-16T00:59:31Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This issue is a double up of #19 closing in favour of that.",
          "createdAt": "2022-02-16T00:59:31Z",
          "updatedAt": "2022-02-16T00:59:31Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOF8lax84_SQWk",
      "title": "Generalize the presentation proof nonce",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/15",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "The spec currently specifies a presentation nonce to prevent replay attack, and recommends it to be a random value. I suggest we had a few details and requirements around nonce generation, to accommodate various scenarios: \r\n - For replay protections, the nonce only need to be unique, so a verifier identifier + timestamp would work (to create proofs non-interactively).\r\n - If the holder keys are held in hardware that the user only has access for a limited period of time, then making the nonce random prevents the user pre-generating proofs to be used later after the authorized period.\r\n - A BBS+ attribute credential can be used to create a digital signature on some data, disclosing a subset of the attributes. In this case, the nonce can be the digest of the signed data.\r\n\r\nI can create a PR with suggested updates.\r\n\r\n",
      "createdAt": "2021-11-23T22:03:26Z",
      "updatedAt": "2022-03-21T02:35:17Z",
      "closedAt": "2022-03-21T02:35:17Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with defining requirements around nonce generation. I don\u2019t understand though how the third option prevents replay attacks or pre-generated proofs (could not the adversary replay the presentation of the same disclosed attributes or pre-generate proofs for the whole credential??). I would appreciate if you could explain that part. ",
          "createdAt": "2021-11-24T20:55:48Z",
          "updatedAt": "2021-11-24T20:55:48Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The last point is a different potential use case: digital signature on say, a document, vs. using a BBS+ credential for authn/authz. E.g., Jane is a professional engineer of company A is asked to review and sign off on the design of a project from company B. She does, and uses her work credential with attributes (name, affiliation, level, role, etc.) to sign off the document, and discloses affiliation, level, and role (e.g., \"This was signed by a level 60 engineer from the Cloud group of Company A\"); she does not disclose her name because her company doesn't want the customer to poach their employees. In this case, the challenge `c` is the hash of the document, just like in conventional electronic signatures. There isn't a replay attack in this case; since the attacker would simply present the same signed document with same signature and disclosed attributes.",
          "createdAt": "2021-11-24T21:24:04Z",
          "updatedAt": "2021-11-24T21:24:04Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As a follow up to that issue, after talking with @christianpaquin I realized I had misunderstood the proposed use case. Although there could be a higher layer spec defining credentials for signing documents, I think it would be nice to also have that use case documented in the current spec and recommend a nonce accordingly (Maybe add a nonce generation section in the security considerations??).",
          "createdAt": "2021-11-30T17:41:43Z",
          "updatedAt": "2021-11-30T17:41:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on work item call on the 15th of Dec, @christianpaquin is going to make a PR to address this issue",
          "createdAt": "2021-12-13T19:42:52Z",
          "updatedAt": "2021-12-13T19:42:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in PR #55, closing on that basis",
          "createdAt": "2022-03-21T02:35:17Z",
          "updatedAt": "2022-03-21T02:35:17Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOF8lax84_viyB",
      "title": "Blinded signatures revision",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/16",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As it is right now, the commitment mechanic (blinded signatures) could lead to some inconsistencies and possible forged signatures. For example, if the Issuer signs the messages `m1`, `m2`, a \"standard\" (non-blinded) signature would be, `(A, e, s)` with\r\n\r\n    A = (g0 + h0 * s + h1 * m1 + h2 * m2)*(1/(SK+e))\r\n\r\nIf the Holder commits a message `m3` using `h1`, i.e., \r\n\r\n    commit = h0 * s\u2019 + h1 * m3\r\n\r\nThe blinded signature, created by the Issuer, would be \r\n\r\n    A_blind = (commit + g0 + h0 * s + h1 * m1 + h2 * m2)*(1/(SK+e)) = \r\n      = (g0 + h0 * (s+s\u2019) + h1 * (m1+m3) + h2 * m2) * (1/(SK+e)). \r\n\r\nNotice that `(A_blind, s+s\u2019, e)` is a valid BBS+ signature in the messages `(m1+m3)` and `m2`, which is not the desired outcome and a potential forgery (`A_blind`, `s`, `s\u2019` and `e` are known to the Holder). \r\n\r\nThe main problem is that currently there is no mechanism for the Issuer to validate that the Holder does not create commitments using the same G2 elements as themself (`h1` in the example above). My proposal is (at least for now) to define a blinded signature that would only contain committed from the Holder messages.\r\n",
      "createdAt": "2021-12-02T11:17:26Z",
      "updatedAt": "2021-12-08T10:09:30Z",
      "closedAt": "2021-12-08T10:09:29Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is exactly why the commitment proof of knowledge needs to be verified by the issuer prior to creating a signature using the commitment.",
          "createdAt": "2021-12-04T17:13:26Z",
          "updatedAt": "2021-12-04T17:13:26Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your answer. I had misunderstood BlindMessagesProofGen. I think we should also mention that the Issuer should check that the used generators for the commitment are not also used for the signature, (i don't think it would be obvious to an implementer). I can make a pr for that and i think we can close this issue.",
          "createdAt": "2021-12-08T10:09:29Z",
          "updatedAt": "2021-12-08T10:09:29Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOF8lax85ATa0V",
      "title": "More flexible default generators",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/19",
      "state": "OPEN",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the default generators are defined using roughly the formula `hash-to-curve(PK || index || count)`, meaning that the generators are dependent on both the public key of the issuer and the number of signed messages.\r\n\r\nThere is also discussion of wanting to use a set of predetermined random generators instead of the default generators, in which case the generators would be independent of both the public key and the number of messages in the signature.\r\n\r\nIn the interest of aligning these approaches somewhat, I think it's worth considering removing the message count from the hash input, so that the default generators depend only on the public key of the issuer. This could have positive effects on performance given that all the generators could be cached up to a maximum number of signed messages.\r\n\r\nThis change might also be relevant in the case of JSON-LD credentials. In order to commit to one or more hidden messages (to implement holder binding for instance) a holder would need to have the relevant message generators. But the total number of messages is often not known at this point in the credential exchange protocol, because the JSON-LD credential itself (including the proof block?) would need to be generated and normalized first. If the generators were independent of the number of messages and the hidden messages were among the first messages (not added to the end) then this would be made possible.",
      "createdAt": "2021-12-13T18:10:00Z",
      "updatedAt": "2022-01-27T02:07:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm fine if we want a different formula. As long as the inputs have sufficient entropy.",
          "createdAt": "2021-12-13T19:20:39Z",
          "updatedAt": "2021-12-13T19:20:39Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #3 ",
          "createdAt": "2022-01-10T19:15:22Z",
          "updatedAt": "2022-01-10T19:15:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Another option is for the message generators to be pre generated and shared globally rather than being issuer specific like the proposal above. \r\n\r\nDiscussed on 10th Jan WG call, resolved to add a section to the spec that speaks about message generator creation which will take a seed and output a list of message generators",
          "createdAt": "2022-01-10T19:32:03Z",
          "updatedAt": "2022-01-10T19:32:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead will provide a PR that defines ^ process",
          "createdAt": "2022-01-10T19:32:27Z",
          "updatedAt": "2022-01-10T19:32:27Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There was some discussion on the call around a DST for the generators. This is an extra parameter to hash-to-curve (besides the seed and message index used as input) which would separate generators used for different signing algorithms. Currently the draft specifies `BLS12381G1_XMD:BLAKE2B_SSWU_RO_BBS+_SIGNATURES:1_0_0`. I think for the next draft it might be something like `BLS12381G1_XOF:SHAKE256_SSWU_RO_BBS+_SIGNATURES:2022`. This implies that the chosen seed value should not include such information, and might be something trivial like the encoding of the words `message generators` in the common case.",
          "createdAt": "2022-01-10T22:26:07Z",
          "updatedAt": "2022-01-10T22:26:07Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Message generators must NOT be shared globally. They must be unique per public key for the protocol to be secure",
          "createdAt": "2022-01-11T05:21:05Z",
          "updatedAt": "2022-01-11T05:21:05Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My proposal is to use Shake256(\u201cBBS_Domain_Generators\u201d || pk || count) to seed  the Xof then draw 64 bytes for each generator  and call hash2curve on the 64 bytes. That runs must faster than the current method in Ursa and is more secure",
          "createdAt": "2022-01-11T05:26:00Z",
          "updatedAt": "2022-01-11T05:26:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you elaborate on the specific security concern here when using global message generators? This model would be similar to some usages of U-Prove, perhaps you could elaborate @christianpaquin.\r\n",
          "createdAt": "2022-01-11T05:54:36Z",
          "updatedAt": "2022-01-11T05:54:50Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "U Prove is a bad comparison. See  https://eprint.iacr.org/2012/298.pdf from Anna Lysyanskaya which says `UProve is not provably secure! No proof of security has been given under any reasonable assumption; and in fact, recently, Baldimtsi and Lysyanskaya [3] showed that all known approaches for proving security in the random oracle model will fail for the Brands blind signature scheme on which UProve is based, under essentially any assumption.`\r\n\r\nAs for a universal setup for BBS+, I have not seen any formal security proofs for one way or the other. Let me review the literature to see what I can find.",
          "createdAt": "2022-01-11T14:27:03Z",
          "updatedAt": "2022-01-11T14:27:03Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "As long as `h0` is different, the other `h_i` could be shared, no? This is not a U-Prove specific construct, this should work for messages built using a Pedersen commitment constructions. BBS+ and, e.g., U-Prove are not equivalent, sure, but these types of protocols have been long studied in the literature, even if there is no formal security proof (ECDSA doesn't have a security proof either...)\r\n\r\n",
          "createdAt": "2022-01-11T14:32:32Z",
          "updatedAt": "2022-01-11T14:32:32Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "To clarify: we indeed need to make sure that the spec remains secure. BBS+ has a security proof, which _is_ a great benefit, so we should be careful to keep that. Camenisch-Drijvers-Lehmann's paper use random generators. Maybe they absolutely need this to prove the security. Maybe the shared generator approach is also secure (in practice), but can't be proven. We'd be stuck with a design choice of provable security vs. efficiency.",
          "createdAt": "2022-01-11T15:09:22Z",
          "updatedAt": "2022-01-11T15:09:22Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We\u2019ll ECDSA does have security proofs by they\u2019re wierd.\r\n\r\nSuppose we have universal generators h_i, if I commit to a value using that it will be the same for all signatures. Think same encryption same key same message problem. This is why AES and CHACHA use nonces to remove this problem. Same key, same message, different nonce means the attacker can\u2019t tell if the same message was encrypted with the same key. Nonce reuse attacks do happen.\r\n\r\nYou raise an interesting point to just have a random h_0. I\u2019ll think about that some more. In general though I still think the generators need to be context specific or domain separated ",
          "createdAt": "2022-01-11T18:30:14Z",
          "updatedAt": "2022-01-11T18:30:14Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "It'd be worthwhile to have various academic experts review the v1 spec (when ready), wherever we land. ",
          "createdAt": "2022-01-11T21:43:41Z",
          "updatedAt": "2022-01-11T21:43:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> It'd be worthwhile to have various academic experts review the v1 spec (when ready), wherever we land.\r\n\r\n+1 we will definitely seek broader review when appropriate.\r\n\r\n > To clarify: we indeed need to make sure that the spec remains secure. BBS+ has a security proof, which is a great benefit, so we should be careful to keep that. Camenisch-Drijvers-Lehmann's paper use random generators. Maybe they absolutely need this to prove the security. Maybe the shared generator approach is also secure (in practice), but can't be proven. We'd be stuck with a design choice of provable security vs. efficiency.\r\n \r\n This is IMO is core to conversation here, is the random nature in which the generators are create0d in this paper, core to the security proof, if not is there a provable security benefit in these generators instead being issuer specific (e.g derived from the issuers public key) otherwise the simplest possible implementation would be for them to be global public parameters.",
          "createdAt": "2022-01-11T21:54:20Z",
          "updatedAt": "2022-01-11T21:54:20Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> In general though I still think the generators need to be context specific or domain separated\r\n\r\n@mikelodder7 is there a security basis you can point to for needing this? Anyway we could clarify with the authors of the Camenisch-Drijvers-Lehmann's paper whether the generators being generated randomly contributes to the security?",
          "createdAt": "2022-01-11T21:57:23Z",
          "updatedAt": "2022-01-11T21:57:23Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Suppose we have universal generators h_i, if I commit to a value using that it will be the same for all signatures. Think same encryption same key same message problem. \r\n\r\nThe bbs+ proof is also randomized even without a nonce (through r1, r2 etc.). Furthermore, the proof that it is zero knowledge does not make assumptions about the generators. The fact that it is zero-knowledge I think can ease those concerns. (not to say that it is not important for the generators to be sufficiently randomized)\r\n\r\nIn literature, it is true that Camenisch, Drijvers and Lehmann have hi as random elements and part of the Issuer\u2019s key but Man Ho Au, Susilo and Yi Mu refer to them as \u201cpublic common parameters\u201d and calculate them in a issuer independent way. In the end, if the generators are sufficiently randomized through a secure hash-function I don't see why any of the proofs will not be holding. But I also agree that care must be taken and contacting the authors seems a greet idea.",
          "createdAt": "2022-01-11T22:12:27Z",
          "updatedAt": "2022-01-11T22:12:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> In the end, if the generators are sufficiently randomized through a secure hash-function I don't see why any of the proofs will not be holding\r\n\r\n@BasileiosKal can you clarify, do you mean so long as the message generators were generated in a sufficiently random manner then they are safe to be re-used across multiple signatures even from different issuers? Or that they must be universally random?",
          "createdAt": "2022-01-11T22:15:37Z",
          "updatedAt": "2022-01-11T22:15:37Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @BasileiosKal can you clarify, do you mean so long as the message generators were generated in a sufficiently random manner then they are safe to be re-used across multiple signatures even from different issuers? Or that they must be universally random?\r\n\r\nYes my argument is that I think it is safe to reuse generators, as long as they where originally created to be sufficiently random.",
          "createdAt": "2022-01-11T22:36:57Z",
          "updatedAt": "2022-01-11T22:36:57Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019m not as worried about the proofs as I am the signing. The other proposal from this group is to make signing deterministic which might also impact this.",
          "createdAt": "2022-01-11T22:42:16Z",
          "updatedAt": "2022-01-11T22:42:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I\u2019m not as worried about the proofs as I am the signing\r\n\r\nIs there a more specific security concern you could elaborate on here?\r\n\r\n> The other proposal from this group is to make signing deterministic which might also impact this.\r\n\r\nAnyway we can improve the understanding of the implications of this? For example does the current proposal for deterministic signatures for BBS mean that using global message generators across signatures is not possible?",
          "createdAt": "2022-01-11T22:53:46Z",
          "updatedAt": "2022-01-11T22:53:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 any follow up here about a specific security concern?",
          "createdAt": "2022-01-18T01:56:16Z",
          "updatedAt": "2022-01-18T01:56:16Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > I\u2019m not as worried about the proofs as I am the signing\r\n> \r\n> Is there a more specific security concern you could elaborate on here?\r\n\r\n\r\nusing the same generators with signatures could potentially leak the messages signed since the commitments will always be the same. Researching to see if this is as bad as I think it might be or not\r\n\r\n> \r\n> > The other proposal from this group is to make signing deterministic which might also impact this.\r\n> \r\n> Anyway we can improve the understanding of the implications of this? For example does the current proposal for deterministic signatures for BBS mean that using global message generators across signatures is not possible?\r\n\r\nNo we should be able to but it does mean signatures are distinct and unique which cryptographically isn\u2019t a problem but could be correlation risk.",
          "createdAt": "2022-01-18T18:09:28Z",
          "updatedAt": "2022-01-18T18:09:28Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> using the same generators with signatures could potentially leak the messages signed since the commitments will always be the same.\r\n\r\nI'm a bit confused, was it suggested to make the commitments deterministic as well?",
          "createdAt": "2022-01-18T18:33:30Z",
          "updatedAt": "2022-01-18T18:33:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It\u2019s true that random and fixed generators are not always equivalent (as shown by this https://eprint.iacr.org/2019/202.pdf paper). However, a takeaway from the paper is that that CDH is just as strong (or even stronger) in cases where a fixed, instead of a random generator, is used. The same result is proven for DL. Wouldn\u2019t that mean that if the sk is sufficiently randomized, the signature will be Indistinguishable from any other element in the group??\r\n\r\nAnother detail is that if we decide to use fixed generators, we should specify that the secret key should not have any dependency to that generator, to avoid problems like in the case of the strong power DDH mentioned in the same paper.\r\n\r\n> No we should be able to but it does mean signatures are distinct and unique which cryptographically isn\u2019t a problem but could be correlation risk.\r\n\r\nWouldn't that be the case even if the generators are not fixed?? If e and s are random, the signatures will be unique. IMO we should add a section to the Security Considerations, saying that the signature should be kept secret to avoid correlation.",
          "createdAt": "2022-01-20T13:53:30Z",
          "updatedAt": "2022-01-20T13:53:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking more about this there may be a potential problem. Pairings make DDH in G1 easy, both in the fixed and in the random generator setting. Furthermore, I think there is a way, using exactly this fact, for an adversary to decide if 2 signatures are on the same messages `mod q`, if a fixed generator is used. \r\n\r\nIf `((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), e1, s1)` and `((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), e2, s2)` are two different signatures on `msg1` and `msg2` respectively (same generators and key, different `e` and `s` values) then the adversary could compute\r\n\r\n```\r\nI1 = e((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), w+P2*e1) * e(-P1 - h0*s1, P2) = \r\n    = e(P1 + h0*s1 + h[1]*msg1, P2) * e(-P1 - h0*s1, P2) => I1 = e(h[1]*msg1. P2)\r\n\r\nI2 = e((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), w+P2*e2) * e(-P1 - h0*s2, P2) = \r\n    = e(P1 + h0*s2 + h[1]*msg2, P2) * e(-g0 - h0*s2, P2) => I2 = e(h[1]*msg2. P2)\r\n```\r\n\r\nAs a result, if I'm not mistaken, the adversary could check if `I1 = I2` to decide if `msg1 = msg2 mod q`, which can correlate the two signatures. Note that the above method only works if there is only 1 message been signed by each signature.\r\n\r\nHowever, we can also prove that an adversary can not extract the message from the signature since such an adversary could be used to solve DL in G1; If the adversary `A` on input a bbs+ signature on the message `m` returns that message, we could just query `A` with `((g0 + h0*s + a)*(1/(e+x)), e, s)` where `a = h[1]*c` is the DL problem we trying to solve. Notice that the query is a valid bbs+ signature on `c` meaning that we will get from `A` the DL of `a` on the basis of `h[1]`, i.e., `c`.\r\n\r\nFor that reason, and the fact that even if we used random generators, there is no proof (currently) that two signatures on the same message couldn't be correlated (for example, if the same method as in the security proof of Lemma 1, in [this](https://eprint.iacr.org/2016/663.pdf) paper, is used to create random generators, the same method as above could be used to decide if `msg1 = msg2 mod q`), IMO the added complexity of using different random generators for each signature is not worth it. In most applications, the signatures will be kept private to avoid correlation either way, while if someone wants to actually use the signature, they will also disclose the signed messages.",
          "createdAt": "2022-01-23T20:28:22Z",
          "updatedAt": "2022-01-24T08:35:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 ^",
          "createdAt": "2022-01-23T21:46:12Z",
          "updatedAt": "2022-01-23T21:46:12Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal if I understand your analysis correctly, if we do migrate to a construction of a BBS+ signature that is deterministic in nature on purpose due to the benefits it brings, then the ability for a possessor of two BBS signatures issued by the same issuer to know that the same set of messages were signed would become apparent anyway?\r\n\r\nIn general I agree with the thinking that correlation via the signature value is not a concern, this is present with most digital signature schemes anyway (esp those that are deterministic in nature like EdDSA or the deterministic construction for ECDSA). The added anti-correlation mechanisms of BBS+ come via the derived proofs, we should add a section in the privacy considerations that describes this nuance",
          "createdAt": "2022-01-23T22:04:42Z",
          "updatedAt": "2022-01-23T22:04:42Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if we do migrate to a construction of a BBS+ signature that is deterministic in nature on purpose due to the benefits it brings, then the ability for a possessor of two BBS signatures issued by the same issuer to know that the same set of messages were signed would become apparent anyway?\r\n\r\nYes exactly. IMO this will not have any practical significance, especially since the message itself and the SK will be secure against an attacker. An addition to the security considerations section should suffice.",
          "createdAt": "2022-01-23T23:07:01Z",
          "updatedAt": "2022-01-23T23:07:01Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Overall, I believe this is a good direction. But, I'd like to do formal security proof that default generators in a universal setup are secure. Also, the generator procedure should be able to be done via computation like domain -> shake256 -> hash2curve(index, okm, dst) -> G",
          "createdAt": "2022-01-24T17:16:55Z",
          "updatedAt": "2022-01-24T17:16:55Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If `((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), e1, s1)` and `((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), e2, s2)` are two different signatures on `msg1` and `msg2` respectively (same generators and key, different `e` and `s` values) then the adversary could compute\r\n> \r\n> ```\r\n> I1 = e((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), w+P2*e1) * e(-P1 - h0*s1, P2) = \r\n>     = e(P1 + h0*s1 + h[1]*msg1, P2) * e(-P1 - h0*s1, P2) => I1 = e(h[1]*msg1. P2)\r\n> \r\n> I2 = e((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), w+P2*e2) * e(-P1 - h0*s2, P2) = \r\n>     = e(P1 + h0*s2 + h[1]*msg2, P2) * e(-g0 - h0*s2, P2) => I2 = e(h[1]*msg2. P2)\r\n> ```\r\n> \r\n> As a result, if I'm not mistaken, the adversary could check if `I1 = I2` to decide if `msg1 = msg2 mod q`, which can correlate the two signatures. Note that the above method only works if there is only 1 message been signed by each signature.\r\n\r\nAs noted, this wouldn't really matter for signatures from a single issuer if deterministic signatures are adopted, however... when the same generators are shared, then it also works for signatures across multiple issuers, regardless of having deterministic signatures.\r\n\r\nThat said, I've been generally assuming that when the signature value itself is revealed (instead of using a ZKP), then all the messages are also expected to be revealed. That would be worth documenting if it is the case.",
          "createdAt": "2022-01-24T17:51:43Z",
          "updatedAt": "2022-01-24T17:52:33Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> But, I'd like to do formal security proof that default generators in a universal setup are secure\r\n\r\n+1. What security properties do we need to prove in the universal default generators setup?? Both the SK and -if my computations where not wrong- the message, are provably secure. On the other hand, the signatures could be correlated. What other security properties should we turn our attention to?",
          "createdAt": "2022-01-24T18:16:02Z",
          "updatedAt": "2022-01-24T18:16:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As noted, this wouldn't really matter for signatures from a single issuer if deterministic signatures are adopted, however... when the same generators are shared, then it also works for signatures across multiple issuers, regardless of having deterministic signatures.\r\n\r\nThat\u2019s a very interesting point. Maybe we should define P2 as issuer specific to avoid this problem (cross-issuer correlation of signatures on the same message)?? Although I do agree that it still does not seem to have enough practical significance to validate the added complexity. Adding to the documentation seems necessary though.",
          "createdAt": "2022-01-24T18:30:18Z",
          "updatedAt": "2022-01-24T18:30:18Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> +1. What security properties do we need to prove in the universal default generators setup?? Both the SK and -if my computations where not wrong- the message, are provably secure. On the other hand, the signatures could be correlated. What other security properties should we turn our attention to?\r\n\r\nFirst, it should be secure in the scenario where multiple issuers are reusing the generators and it shouldn't be possible to know if the same message is signed at the same position. Second, an attacker should not be able to trick a signer by copying the commitments to another signer. I'll try to think of more properties as we go along. The second solution is already partially accounted for by using a blind signature proof of knowledge of committed values. I'm worried about the first scenario for both signing and proving.\r\n",
          "createdAt": "2022-01-24T18:57:11Z",
          "updatedAt": "2022-01-24T18:57:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": " > First, it should be secure in the scenario where multiple issuers are reusing the generators and it shouldn't be possible to know if the same message is signed at the same position.\r\n\r\n@mikelodder7 can you elaborate on this more, do you mean by a party that has two signatures from two issuers or two proofs from two issuers? Because I agree if it is the latter but if it is the former, what is the attack vector?\r\n\r\n> Second, an attacker should not be able to trick a signer by copying the commitments to another signer\r\n\r\nIm unsure how universal/global generators would facilitate this deceit?",
          "createdAt": "2022-01-27T02:06:37Z",
          "updatedAt": "2022-01-27T02:07:05Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOF8lax85ATp39",
      "title": "NIZK's must use fiat-shamir hash comparison",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/20",
      "state": "CLOSED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When verifying any NIZK, it is necessary to check if the fiat-shamir heuristics are the same i.e. the challenges.\r\nComparing whether the commitments are the same is not enough. ",
      "createdAt": "2021-12-13T19:22:25Z",
      "updatedAt": "2022-02-16T00:49:50Z",
      "closedAt": "2022-02-16T00:49:50Z",
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOF8lax85BdmyZ",
      "title": "Terminology clarification",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/24",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Clarify terminology for \r\n\r\nDomain Parameters\r\nGenerators (and their relationship to domain parameters)\r\nGenerators with specific purposes (e.g message generators and blinding factor generators)",
      "createdAt": "2022-01-10T19:20:10Z",
      "updatedAt": "2022-01-10T19:20:10Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDOF8lax85BeKXa",
      "title": "Variable and function naming",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/25",
      "state": "OPEN",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "andrewwhitehead"
      ],
      "labels": [],
      "body": "The current draft uses the caret and tilde characters in variable naming, as they are in some of the source research. This causes issues with the markdown format of the specification in that it is burdensome and/or impossible to properly escape these characters.\r\n\r\nI don't see any clear standards on variable or function naming in other IETF drafts. Variables may be upper-, lower-, camel-, or snake-cased. Functions can be camel-cased, snake-cased, or kebab-case (ie. `HKDF-Extract`).\r\n\r\nSome suggestions for discussion:\r\n\r\n- name spec-internal variables and functions in snake case unless they represent an initialism (like `DST`) or are commonly capitalized (such as a field `F` or the set of integers `Z`). I think there is a tendency to use capitalized variables for elliptic curve points like `A` in the signature\r\n- name external functions according to their respective standards when possible, for example `hash_to_curve`\r\n- a trailing apostrophe is allowed in variable names, such as `s'` - precedent in hash-to-curve draft for example\r\n- for variables currently using `~` as a suffix use `_b` short for blinding factor\r\n- for variables currently using `^` as a suffix use `_c` short for commitment",
      "createdAt": "2022-01-10T21:53:34Z",
      "updatedAt": "2022-02-16T04:42:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bumblefudge",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See #17 ",
          "createdAt": "2022-01-24T19:11:41Z",
          "updatedAt": "2022-01-24T19:11:41Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOF8lax85CRz0I",
      "title": "Conceptually seperate message generators from public key definition",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/26",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "At the moment in the draft a BBS signature public key is defined as an ordinary public key (using the based generator for the curve group) + a set of message generators used for committing messages to a BBS signature. Given the conversation occurring in #19 even if the outcome is to stick with a set of message generators that are derived through a deterministic process from the ordinary public key, I think we should remove the concept of a BBS signature public key and regard message generators as \"public parameters\" instead.",
      "createdAt": "2022-01-23T19:34:47Z",
      "updatedAt": "2022-01-27T18:40:46Z",
      "closedAt": "2022-01-27T18:40:46Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOF8lax85CR1vI",
      "title": "Setup automated tooling for publishing the latest version of the draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/27",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The authors of the [jwp draft](https://github.com/json-web-proofs/json-web-proofs) have done some great work in setting up automation around draft publishing / archiving and diff rendering, we should considering adopting similar technology to facilitate development of the draft.",
      "createdAt": "2022-01-23T20:10:05Z",
      "updatedAt": "2022-01-26T01:00:44Z",
      "closedAt": "2022-01-26T01:00:44Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed with #32 ",
          "createdAt": "2022-01-26T01:00:44Z",
          "updatedAt": "2022-01-26T01:00:44Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOF8lax85CSaB6",
      "title": "Supporting bound BBS signature usecases",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/28",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As has been discussed before in [related communities](https://github.com/w3c-ccg/ldp-bbs2020/issues/37), the loose intended definition of bound BBS signatures refers to a signature that features a binding to a secret key (private key) possessed by the holder, which is required to be known by the holder in order to derive a proof using the signature. Effectively it is the introduction of a proof of key possession factor to a BBS signature which increases the assurances a relying party or verifier has when presented with a derived proof.\r\n\r\nMechanically this \"feature\" could be realised in multiple ways which affect the scope of this draft:\r\n1. Would be to leverage the blind sign functionality and treat the bound secret key as a blinded message.\r\n2. Would be to doing something more opinionated at the level of this draft introducing the concept of bound signatures and potentially removing the more flexible blind sign functionality.",
      "createdAt": "2022-01-24T03:23:22Z",
      "updatedAt": "2022-02-23T09:35:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO if the main use case for blind signatures is for holder binding it may be better to move the blind signature functionality on a extension of the spec to keep the core spec as simple as possible (which IMO will be appreciated by the IETF). Holder binding could be achieved with similar but much simpler mechanisms.",
          "createdAt": "2022-01-24T18:47:21Z",
          "updatedAt": "2022-01-24T18:47:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would definitely be open to making the blind signature support an optional extension. For me it also raises questions about supporting deterministic signatures.",
          "createdAt": "2022-01-24T21:28:11Z",
          "updatedAt": "2022-01-24T21:28:11Z"
        },
        {
          "author": "brentzundel",
          "authorAssociation": "MEMBER",
          "body": "Since the underlying algorithm already natively supports the signing of blinded attributes which may be used for binding the signed data to a holder, it doesn't make sense to me to pursue alternative mechanisms for doing so.",
          "createdAt": "2022-01-25T16:52:58Z",
          "updatedAt": "2022-01-25T16:52:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Without a proposal for holder binding done in a more opinionated way, I can see this perspective, however I do think there are simpler options so will put together something more concrete to help inform this discussion.",
          "createdAt": "2022-01-25T20:05:44Z",
          "updatedAt": "2022-01-25T20:05:44Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> potentially removing the more flexible blind sign functionality.\r\n\r\nThis would invalidate private linking use-cases, where the holder wants to link different credentials together from multiple issuers without revealing the linkage to them, and can selectively disclose any linkages during presentation as needed.  This looks like binding but is subtly different as both may need to exist separately in such use-cases.\r\n\r\nAlso, blind signing is useful as a private witness where the issuer can sign something the holder wants witnessed without having to reveal the contents.\r\n\r\n",
          "createdAt": "2022-01-25T20:41:16Z",
          "updatedAt": "2022-01-25T20:41:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> This would invalidate private linking use-cases, where the holder wants to link different credentials together from multiple issuers without revealing the linkage to them, and can selectively disclose any linkages during presentation as needed. This looks like binding but is subtly different as both may need to exist separately in such use-cases.\r\n\r\n@quartzjer do you mean general private linking use-cases? like any attribute in common across credential / signatures? As i dont think this invalidates those usecases?\r\n\r\n> Also, blind signing is useful as a private witness where the issuer can sign something the holder wants witnessed without having to reveal the contents.\r\n\r\nAgree with this, but IMO this is really just stating the most general class of usecases that blind sign solves for, is there anything more concrete we could discuss?\r\n\r\nTo be clear im not saying arbitrary blind sign functionality is not useful, just questioning whether we need to standardize that now, vs via an extension later. Because it significantly complicates the current draft. Essentially all the blind sign functionality defines is a pre-protocol for how a holder constructs a commitment representing a set of blinded messages and an issuer verifies this before including it in their issued signature.",
          "createdAt": "2022-01-25T21:20:33Z",
          "updatedAt": "2022-01-25T21:20:33Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's also fair to say that even if blind signing is removed from the core spec, we would ensure that it was not made impossible, and the functionality would likely remain in existing implementations.",
          "createdAt": "2022-01-25T21:23:00Z",
          "updatedAt": "2022-01-25T21:23:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "+1 @andrewwhitehead exactly",
          "createdAt": "2022-01-25T21:29:31Z",
          "updatedAt": "2022-01-25T21:29:31Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> do you mean general private linking use-cases?\r\n\r\nI was speaking to linking of multiple different credentials (by using the same link secret, blinded to multiple issuers).\r\n\r\n> I think it's also fair to say that even if blind signing is removed from the core spec, we would ensure that it was not made impossible, and the functionality would likely remain in existing implementations.\r\n\r\nAhh yes, this I completely understand and agree with, it can definitely be an extension since it is pretty self-isolated. ",
          "createdAt": "2022-01-25T22:00:59Z",
          "updatedAt": "2022-01-25T22:00:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I was speaking to linking of multiple different credentials (by using the same link secret, blinded to multiple issuers).\r\n\r\nOk great the proposal made in this issue would not eliminate that capability. As said above we are really just talking about the pre-protocol around blinding messages for an issuer to sign.",
          "createdAt": "2022-01-25T22:06:32Z",
          "updatedAt": "2022-01-25T22:06:32Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #37 ",
          "createdAt": "2022-02-23T09:35:50Z",
          "updatedAt": "2022-02-23T09:35:50Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOF8lax85CSaUd",
      "title": "Supporting use cases for blind signing",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/29",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently the spec documents a procedure for constructing BBS signatures where by some / all of the messages signed by the signer are unknown to them. This issue is to discuss the usecases for this feature and whether it should remain in scope for the core spec of whether it could be added in the form of a seperate extension specification. The tradeoff being that electing to keep blind signing in scope significantly increases deliverables for the spec in the form of multiple cryptographic operations and data structures.\r\n\r\nNote - related to this is a discussion on how we should handle \"bound\" bbs signatures captured in issue #28",
      "createdAt": "2022-01-24T03:25:08Z",
      "updatedAt": "2022-01-28T14:37:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "When BBS+ is used to create an anonymous credentials (messages are user attributes), then there are some interesting use cases. For example, the duty of the issuer (BBS+ signer) could be performed by two entities in a federation: an attribute provider (knows the user attribute) and an issuer (secure machine holding the crypto keys), and perhaps you don't want to leak the attribute values to the issuer, but it trusts the attribute provider to set the values. Another example is to carry-over attributes from one credential to another: say the credential contains a user-ID, never disclosed but used for non-revocation proofs. A new credential could be issued or linked to another one by copying the attribute value over; a revocation would then invalidate both credentials.\r\n\r\nSimplifying the spec is an important goal; the various signing algs are confusing to a new reader. It would be great to achieve this functionality through an extension. FWIW, that's what with did for U-Prove using the [collaborative issuance extension](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/U-Prove20Collaborative20Issuance20Extension.pdf). See also this [white paper](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/U-Prove20extensions20paper.pdf) for more background on the feature, including more details of the scenarios described above.",
          "createdAt": "2022-01-28T03:24:32Z",
          "updatedAt": "2022-01-28T03:24:32Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @christianpaquin this is awesome context both the usecase and the example of the model you took to accomodate it  in U-Prove.\r\n\r\nIf we simply removed sections 3.7-3.11 I believe they could form part or most of the extension to do this. Provided we have an alternative proposal for holder binding such as proposed by #37 ",
          "createdAt": "2022-01-28T04:00:15Z",
          "updatedAt": "2022-01-28T04:02:40Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Another example is to carry-over attributes from one credential to another: say the credential contains a user-ID, never disclosed but used for non-revocation proofs. A new credential could be issued or linked to another one by copying the attribute value over; a revocation would then invalidate both credentials.\r\n\r\nVery interesting use cases. Is the idea here for the holder to send a commitment with the user-ID to a new issuer? If so, how the second issuer can be sure that the holder committed to the correct user-ID (also contained in the first credential)?\r\n\r\n> an attribute provider (knows the user attribute) and an issuer (secure machine holding the crypto keys), and perhaps you don't want to leak the attribute values to the issuer, but it trusts the attribute provider to set the values. \r\n\r\nAlso would in this case be necessary for the whole procedure of blind signatures to be followed (which also involves creating Schnorr proofs about the knowledge of the attributes and the correctness of the commitment)? If the requirement is only for information to not be leaked, wouldn't just the Pedersen commitment suffice? If that is the case, maybe we should define the blind messages nizk creation and verification as optional, to support that use-case.",
          "createdAt": "2022-01-28T10:55:19Z",
          "updatedAt": "2022-01-28T11:58:44Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": " \r\n> Is the idea here for the holder to send a commitment with the user-ID to a new issuer? If so, how the second issuer can be sure that the holder committed to the correct user-ID (also contained in the first credential)?\r\n\r\nYes. Conceptually, the holder creates a presentation proof with a commitment, showing that the undisclosed attribute is the same as in its credential; after validation by the issuer, the commitment can be integrated in the new credential. The U-Prove extension above shows how to do that for Brands' credentials; the details would be slightly different for a BBS+ based credential. An analysis is required to answer the questions you raised. Bottom line, it's not a trivial thing and perhaps this justifies specifying this functionality outside of the core spec (making sure however it has the right hooks for extensions).",
          "createdAt": "2022-01-28T14:37:15Z",
          "updatedAt": "2022-01-28T14:37:58Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOF8lax85CbKCy",
      "title": "Naming of the draft BBS vs BBS+",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/30",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I propose we rename the draft to \"The BBS Signature Scheme\" and elect to drop the + from all mentions of BBS. Through appropriate citations of the academic work I think we can still achieve the right level of association to the schemes origins. The rationale for dropping the + is that in many visible places that character is not allowed (e.g naming repositories, naming packages and programming language syntax)",
      "createdAt": "2022-01-25T22:14:16Z",
      "updatedAt": "2022-01-26T00:52:59Z",
      "closedAt": "2022-01-26T00:52:58Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "I definitely support this :+1:.",
          "createdAt": "2022-01-25T22:23:33Z",
          "updatedAt": "2022-01-25T22:23:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in #32 there was only two minor inconsistencies in the draft already that have been addressed",
          "createdAt": "2022-01-26T00:52:58Z",
          "updatedAt": "2022-01-26T00:52:58Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOF8lax85CbLrn",
      "title": "Remove KeyGen definition",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/31",
      "state": "OPEN",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This may be defined as a property of the profile along with details of the pairing-friendly curve in use. For BLS curves it probably makes sense to reference the BLS Signatures IETF draft (hopefully that is getting an update?).",
      "createdAt": "2022-01-25T22:23:33Z",
      "updatedAt": "2022-04-04T21:28:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "For reference the draft is located here https://github.com/cfrg/draft-irtf-cfrg-bls-signature",
          "createdAt": "2022-01-26T09:12:35Z",
          "updatedAt": "2022-01-26T09:15:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "In particular this section https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.3",
          "createdAt": "2022-01-26T09:16:06Z",
          "updatedAt": "2022-01-26T09:16:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Depending on the outcome of #87 if this is merged then we can close this as the definition for key gen in the spec has diverged from BLS signatures",
          "createdAt": "2022-03-21T02:29:15Z",
          "updatedAt": "2022-03-21T02:29:15Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Following the discussion in the 4/4/2022 call, I agree the spec should allow implementers to use random keys; the currently proposed implementation could be move to an appendix or a profile.",
          "createdAt": "2022-04-04T19:03:02Z",
          "updatedAt": "2022-04-04T19:03:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Agree with @christianpaquin, to provide further context the spec is currently not clear that the exact KeyGen operation defined is not required by implementations and instead they are free to generate keys in other ways if they wish.",
          "createdAt": "2022-04-04T21:28:03Z",
          "updatedAt": "2022-04-04T21:28:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Either a note at the top of this operations definition or shifting it to an appendix is likely the way we will resolve this",
          "createdAt": "2022-04-04T21:28:48Z",
          "updatedAt": "2022-04-04T21:28:48Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOF8lax85CbhY5",
      "title": "Consider renaming nonce in the proof to presentation message",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/33",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed in the WG call on the 24th of Jan, the usage of the term nonce was found to confuse reviewers of #21, upon discussing this the suggestion was to potentially rename this to presentation message as was the case with uProve. This is to convey the structure we are talking about may not be limited to being used as just a cryptographic nonce, instead it may be used to convey other information accompanying the proof generated",
      "createdAt": "2022-01-26T00:54:36Z",
      "updatedAt": "2022-01-28T00:38:06Z",
      "closedAt": "2022-01-28T00:38:06Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Fixed in #36",
          "createdAt": "2022-01-28T00:38:06Z",
          "updatedAt": "2022-01-28T00:38:06Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOF8lax85CbiGG",
      "title": "Add documentation on how contributors can build the HTML / TXT version of spec locally",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/34",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "Requires users to have make installed, list commands and add to a contributors document in the repository",
      "createdAt": "2022-01-26T01:00:19Z",
      "updatedAt": "2022-03-06T23:17:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 37,
      "id": "I_kwDOF8lax85CkCkW",
      "title": "Holder Binding",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/37",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the spec is missing a way to bind a signature to a user. The proposal from [here](https://github.com/w3c-ccg/ldp-bbs2020/issues/37) is to use BLS keys. Essentially the process will be the following,\r\n\r\n1. User creates BLS keys i.e., BLS_SK and BLS_PK in G1 (`BLS_PK = P * BLS_SK `) where `P` a point in G1\r\n2. The Issuer will use the BLS_PK of the user as a commitment i.e.,\r\n```\r\nA = (P1 + BLS_PK + h0 * s + h[1] * msg[1] + h[2] * msg[2] + \u2026 + h[L] * msg[L]) * (1/(e + x))\r\n```\r\n3. The user will have to know BLS_SK to derive a BBS+ proof creating the binding. \r\n\r\nAn issue is what base points to use i.e., `P` (base point for use with BLS) and `P1` (base point for use with BBS+). Those points need to be different. A choice is to use `P` as defined by the [BLS signatures spec](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/), which is the base point of G1 as defined from the [pairing-friendly-curves-draft](https://datatracker.ietf.org/doc/draft-irtf-cfrg-pairing-friendly-curves/) spec.\r\n\r\nThe advantage is that BLS will most likely use the base point as defined by the pairing-friendly-curves spec, so we will be in spec when it comes to BLS keys. The negative is that we will need to define a different base point for BBS+ (i.e, `P1`). My proposal is to just use `P1 = P*2`. Another option is to use a random point in G1 as the base point for BBS+ if there is some security reason to do so.",
      "createdAt": "2022-01-27T21:14:25Z",
      "updatedAt": "2022-02-23T09:31:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "To be clear this proposal would yield a couple of use-ability benefits\r\n\r\n1. The commitment required by the issuer of the BBS signature to construct a bound variant is just an ordinary public key in G1, so no need to standardise the representation of new cryptographic information\r\n2. The pop mechanism used by a holder to proove to an issuer they possess the private key associated to the supplied public key for binding becomes just an ordinary BLS signature, so no need to standardise the representation of new cryptographic information here and a protocol to support it (e.g creating some form of POP and verifying it) ",
          "createdAt": "2022-01-28T00:45:31Z",
          "updatedAt": "2022-01-28T09:30:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Together with this in place if agreed I think would allow us to remove the more general blind sign API from the core draft if we fail to find substantive use cases justifying its presence, discussed more in #29 ",
          "createdAt": "2022-01-28T00:46:42Z",
          "updatedAt": "2022-01-28T09:32:16Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> To be clear this proposal would yield a couple of use-ability benefits\r\n> \r\n> 1. The commitment required by the issuer of the BBS signature to construct a bound variant is just an ordinary public key in G1, so no need to standardise the representation of new cryptographic information\r\n> 2. The pop mechanism used by a holder to proove to an issuer they possess the private key associated to the supplied public key for binding becomes just an ordinary BLS signature, so no need to standardise the representation of new cryptographic information here and a protocol to support it (e.g creating some form of POP and verifying it)\r\n> \r\n\r\nExactly. The main goal is to make the spec simpler and more readable. In compliance with the discussion at #29 the idea is that if people just want to use the core operations of bbs+ (for example for use-cases like #39) they can do so without having to concern themselves with the details of blind signatures (which do take a significant amount of the spec currently). On the other hand, for use-cases like the ones proposed [here](https://github.com/decentralized-identity/bbs-signature/issues/29#issuecomment-1023851074), people can just as easily use the spec extension.",
          "createdAt": "2022-01-28T12:21:27Z",
          "updatedAt": "2022-01-28T12:21:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "After thinking about this more I propose that any formal support for a BBS signature that features a cryptographic binding to the holder / prover be left to an extension spec, this keeps the core BBS signature scheme draft simple and focused",
          "createdAt": "2022-02-23T09:31:13Z",
          "updatedAt": "2022-02-23T09:31:13Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOF8lax85CkHdK",
      "title": "Message Generators Creation Method",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/38",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikelodder7"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Since the consensus seems to be to move to global fixed message generators shared between issuers (see #19 ) the next step would be to decide how to create those generators.  Opening this issue to create some discussion around possible proposals. My understanding is that they will be deterministically generated by a common seed (created from some nothing-up-my-sleeve value).\r\n\r\nI would also propose for the process to be such that it will create a strong binding between index and generator (i.e., something like `hash-to-curve(seed, dst, index)`) to help with indexing in applications and avoiding ambiguities.",
      "createdAt": "2022-01-27T21:38:22Z",
      "updatedAt": "2022-03-11T03:32:53Z",
      "closedAt": "2022-03-11T03:32:53Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 I think last time we chatted you potentially had a good proposal for how this could be done?",
          "createdAt": "2022-01-28T03:55:57Z",
          "updatedAt": "2022-01-28T03:55:57Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's my proposal\r\n\r\n1. Set the global domain separator to be `GLOBAL_DST='BBS_SETUP_GENERATOR_IKM_1_0_0\\0\\0\\0'` read as 32 bytes.\r\n2. Decide on a nothing up my sleeve value for the GLOBAL_SEED like some Shakespeare poem or quote.\r\n3. Hasher = SHAKE256(GLOBAL_DST, GLOBAL_SEED)\r\n\r\nCalculate the generators as follows\r\n\r\n4. Set the generator `DST=BBS_BLS12381G1_XOF:SHAKE-256_SSWU_RO_`\r\n5. Set generators to empty collection\r\n6. for i < num_generators \r\n7. tv = Hasher.Read(64) // Read out 64 bytes from XOF\r\n8. generators[i] = Hash2Curve(tv, DST)\r\n9. output generators\r\n\r\nThe advantage of this approach is if we determine the global approach to be insecure we change the GLOBAL_SEED to be the signer's public key leaving all else the same. If we change curves then DST is updated to reflect that in the name. \r\n",
          "createdAt": "2022-01-28T19:54:18Z",
          "updatedAt": "2022-01-28T19:54:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "A couple of things we will need to generalise in spec text is the underlying curve and subgroup, note the [current tool](https://github.com/decentralized-identity/bbs-signature/tree/main/tooling/message-generators) is coupled to BLS12-381 ",
          "createdAt": "2022-01-29T22:01:30Z",
          "updatedAt": "2022-01-29T22:01:30Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure but the curve can easily be swapped ",
          "createdAt": "2022-01-30T03:51:08Z",
          "updatedAt": "2022-01-30T03:51:08Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Yeap agreed, just taking a note so we don't loose track of it",
          "createdAt": "2022-01-30T20:51:11Z",
          "updatedAt": "2022-01-30T20:51:11Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 for that method.",
          "createdAt": "2022-01-31T17:34:30Z",
          "updatedAt": "2022-01-31T17:34:30Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add a check for point at infinity and the base generator.",
          "createdAt": "2022-02-07T19:32:27Z",
          "updatedAt": "2022-02-07T19:32:27Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can hash-to-curve return infinity? \ud83e\udd14",
          "createdAt": "2022-02-07T19:33:09Z",
          "updatedAt": "2022-02-07T19:33:09Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With very small odds 1/2^256. It\u2019s nice to check for it in case an attacker inserts one",
          "createdAt": "2022-02-07T19:34:34Z",
          "updatedAt": "2022-02-07T19:34:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Could we generalize this to check other generators other than just these? e.g what about the generator used for the blinding factor?",
          "createdAt": "2022-02-07T22:59:52Z",
          "updatedAt": "2022-02-07T22:59:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 is this ready for a PR?",
          "createdAt": "2022-02-07T23:00:03Z",
          "updatedAt": "2022-02-07T23:00:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "If so would you be willing to contribute one?",
          "createdAt": "2022-02-07T23:00:27Z",
          "updatedAt": "2022-02-07T23:00:27Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yea it is. I can contribute one",
          "createdAt": "2022-02-07T23:06:53Z",
          "updatedAt": "2022-02-07T23:06:53Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 bump on this one, I think it should be defined under operations, generically (e.g agnostic of the underlying curve). Then the specific cipher suite can profile it",
          "createdAt": "2022-02-23T21:52:14Z",
          "updatedAt": "2022-02-23T21:52:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I've opened #71 in an attempt to move this issue forward.",
          "createdAt": "2022-02-24T01:01:31Z",
          "updatedAt": "2022-02-24T01:01:31Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there's one improvement we could make here to improve efficiency. At the moment the assumption seems to be that we reject infinity and the default generator by proceeding to the next XOF hash output, but that implies that we have to perform hash-to-curve for every previous generator in order to rule out those values. Instead, I think we should handle the infinity and default generator cases by initializing a new XOF based on the previous output (I'm not sure if cloning the current hash state and adding more input is widely supported). This has the advantage that in order to access generator 20, for example, you only need to advance the XOF output 20 times and can skip 20 hash-to-curve operations, which are much more expensive.",
          "createdAt": "2022-02-25T01:10:33Z",
          "updatedAt": "2022-02-25T01:10:33Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don\u2019t see how that\u2019s more efficient since you already read those out anyway with the current construction.  The checking for infinity and base point is for the security proof. The odds of this happening in practice is 2^-256",
          "createdAt": "2022-02-25T01:47:28Z",
          "updatedAt": "2022-02-25T01:47:28Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay so we're not going to reject those points when creating the generators? It is very unlikely to happen.",
          "createdAt": "2022-02-25T01:56:28Z",
          "updatedAt": "2022-02-25T01:56:28Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No you would still reject them but the odds of it actually happening is Incredibly low",
          "createdAt": "2022-02-25T01:58:10Z",
          "updatedAt": "2022-02-25T01:58:10Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also the current algorithm already allows you just read out to generator 20 without having to do 20 hash to curves",
          "createdAt": "2022-02-25T01:59:42Z",
          "updatedAt": "2022-02-25T01:59:42Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems like it only lets you do that if you assume that all the previous points were accepted. Although I'm not sure now what it means to reject a point. Maybe we can add that to the algorithm.",
          "createdAt": "2022-02-25T02:14:36Z",
          "updatedAt": "2022-02-25T02:14:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Also the current algorithm already allows you just read out to generator 20 without having to do 20 hash to curves\r\n\r\nYeah I think the point here that @andrewwhitehead is raising is what if one of the generators between 1 and 19 evaluated to infinity so the algorithm had to recompute a generators, in this case strictly the 20th generator is actually the 19th but to be sure you have to compute all in order.",
          "createdAt": "2022-02-25T02:39:45Z",
          "updatedAt": "2022-02-25T02:39:45Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Wouldn't modifying this algorithm in the way you describe @andrewwhitehead also make the generator computation fully parallelizable?",
          "createdAt": "2022-02-25T02:43:09Z",
          "updatedAt": "2022-02-25T02:44:11Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019m not seeing how since it still depends on the previous value",
          "createdAt": "2022-02-25T02:44:40Z",
          "updatedAt": "2022-02-25T02:44:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "In the proposal made by andrew it would mean the current generator computation would always know which bytes to start with for its hash to curve operation there would never be the potential for \"bad\" generators that came before it (e.g bytes drawn from the XOF that when hashed to curve, evaluated to infinity).\r\n\r\nI think the tradeoff we are playing with here is the efficiency of re-initializing the XOF function per-generator and skipping to read a certain set of bytes vs the algorithm as it is described above.",
          "createdAt": "2022-02-25T02:51:16Z",
          "updatedAt": "2022-02-25T02:51:16Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tplooker Good point on the parallelization, you would still need to go through the hash output of course but it would give more options if points did not depend on previous hash-to-curve outputs.",
          "createdAt": "2022-02-25T03:08:54Z",
          "updatedAt": "2022-02-25T03:08:54Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOF8lax85Cl0UN",
      "title": "[USECASE] Privacy Preserving Authorization/Access Tokens",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/39",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently the most prolific model for expressing authorization/access tokens on the web are those like JWT based ones as used by the OAuth2.0 protocol. In order to provide these tokens with the necessary authenticity and integrity guarantees the tokens are secured using conventional cryptographic primitives like traditional digital signatures and or structures like HMACs.  To make use of one of these access tokens issued by a protocol like OAuth2.0, a relying party most commonly includes the access token as issued, in the Authorization header of an HTTP request they make to a resource server to prove authority. Some limitations of this model are:\r\n- That repeated requests to the same resource server correlates the relying party. \r\n- These access tokens are most often bearer in nature, which means if the token is intercepted by a malicious third party, they then obtain the same level of access as the relying party at the resource server. \r\n- Finally when authorization has been granted to a relying party from an authorization server that gives it access across multiple resource servers, having a single access token can leak certain information un-intentionally to the various resource servers as the access token is used.\r\n\r\nAn access token secured with a BBS signature could help to solve some of these challenges in the following ways:\r\n\r\n1. An access token secured with a BBS signature would never be directly revealed via a request to a resource server, thus mitigating the correlation risk. Instead each time a relying party were to make a request to a resource server they instead would compute a derived proof of the access token and include that result in the request to the resource server. The resource server still obtains the same level of confidence (if not better) around proof of authority associated to the request, without strongly correlating the client via the signature on the access token.\r\n2. Because an access token secured with a BBS signature is never directly revealed via a request to a resource server, instead only a derived proof which cannot be replayed, the likely hood of the access token being intercepted by a malicious third party is strongly mitigated.\r\n3. Finally because BBS Signatures enable multi-message signing and selective disclosure during the deriving of a proof, a relying party could leverage this to derive proofs from a single access token that proves authority to perform actions at independent resource servers without the risk of un-intentionally information leakage.",
      "createdAt": "2022-01-28T09:58:58Z",
      "updatedAt": "2022-02-15T08:48:27Z",
      "closedAt": "2022-02-15T08:48:26Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Added into the draft in https://github.com/decentralized-identity/bbs-signature/commit/bf70e40f8aab8472e34e907953e8c7788efd6a78 ",
          "createdAt": "2022-02-15T08:48:26Z",
          "updatedAt": "2022-02-15T08:48:26Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOF8lax85CoEOy",
      "title": "Message Encoding",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/40",
      "state": "OPEN",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Data can be encoded multiple ways depending on how it will be used with other ZKPs. For example, it will not be useful to hash an integer to a 32 byte value using SHA256 and expect it to work properly with Range Proofs. The following is a list of encodings and the use cases they can be used:\r\n\r\n1. **Hashed**: for aribitrary length data fields that will not fit in the base field e.g. images, strings, biometrics, blockchain transaction info. Use hash2field or some other method to hash the data into a 32 byte base field value.\r\n2. **Bytes**: a value that is already in the base field\r\n3. **Numbers**: for range proofs. The value is zero-centered by take computing the base field modulus `z`=`q` / 3 integer division as the zero center and adding the positive number or substracting the negative number. To support complex numbers like decimal, the number is converted to fixed point arithmetic. The [Q format](https://en.wikipedia.org/wiki/Q_(number_format)) is used for these numbers as Q64.160. This leaves two bytes to avoid numbers greater than `q`. While it does not represent the full breadth of IEEE754 numbers, it does give a considerable resolution -2<sup>63</sup> to 2<sup>63</sup>-2<sup>-160</sup> signed and 0 to 2<sup>64</sup>-2<sup>-160</sup> unsigned or about 48 decimal places of precision. If decimals are rounded to the nearest integer, then Q format is not necessary.\r\n4. **Null**: Hard coded as 5. Means the value is not included or not used.\r\n5. **Empty**: Hard coded as 11. Means the value is included but is an empty string or zero bytes. For example, a person does not have a middle name but a value is required to be entered.\r\n6. **Ignored**: Hard coded as 23. For data fields that were ignored or not answered by the person. This is different than empty where the person's answer is literally nothing vs they chose not to answer it at all.\r\n\r\nSmall safe primes were used for the last three but can really be any value that is not `0` or `1`.\r\n\r\n### Comparing numbers to Null, Empty, Ignored\r\n\r\nNo DLEQ proof is needed to check for this since the verifier gets to pick the bounds and in theory this could be done but isn't meaningful",
      "createdAt": "2022-01-28T19:57:31Z",
      "updatedAt": "2022-03-06T23:17:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019m fine with the encodings. I was thinking about the scope though, i.e., is the bbs+ spec the best place to define them. To my knowledge crypto specs don\u2019t usually define data representations.\r\n\r\nFrom the bbs+ perspective will it make a difference If 5 means Null or something else?",
          "createdAt": "2022-01-31T17:34:54Z",
          "updatedAt": "2022-01-31T17:34:54Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don\u2019t think so as long as we agree what means what",
          "createdAt": "2022-01-31T18:02:09Z",
          "updatedAt": "2022-01-31T18:02:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Being addressed in #61 ",
          "createdAt": "2022-03-06T23:17:21Z",
          "updatedAt": "2022-03-06T23:17:21Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOF8lax85Csil6",
      "title": "Supporting deterministic signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/43",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mikelodder7"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "BBS Signatures as defined in academic literature are non-deterministic in nature. In general non-deterministic digital signatures can be difficult from an implementation perspective due to their dependency on a sound RNG. It causes complexities around confirming implementation correctness because the RNG often has to be mocked or seeded in a particular way. There is the potential to modify the signature construction in this draft to make signatures deterministic, @mikelodder7 could you share your proposal for this?\r\n\r\nThe main questions I think we as a WG should be asking are:\r\n- Do we want deterministic signatures?\r\n- Do we want to take on the scope of deterministic signatures in the current draft?\r\n- Given we are deviating from academic literature, what security proofs do we need?",
      "createdAt": "2022-01-31T04:56:03Z",
      "updatedAt": "2022-03-06T23:19:03Z",
      "closedAt": "2022-03-06T23:19:03Z",
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My suggestion is this:\r\n\r\nu512() is a function that converts 64 bytes as a 512-bit number.\r\n\r\nFor regular signing:\r\n\r\ninputs: \r\n- base order `q`\r\n- secret key `x`\r\n- messages `mi,...,mn`\r\n\r\n1. hasher = SHAKE256(x, mi, ..., mn)\r\n2. e = uint512(hasher.read(64)) % q\r\n3. s = uint512(hasher.read(64)) % q\r\n4. finish as normal\r\n\r\nFor blind signing:\r\ninputs:\r\n- base order `q`\r\n- secret key `x`\r\n- known_messages `mi,...,mn`\r\n- commitment `U`\r\n\r\n1. hasher = SHAKE256(x, U, mi,...,mn)\r\n2. e = uint512(hasher.read(64)) % q\r\n3. s = uint512(hasher.read(64)) % q\r\n4. finish as normal",
          "createdAt": "2022-02-03T20:25:46Z",
          "updatedAt": "2022-02-03T20:25:46Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this method, but a comment from [here](https://datatracker.ietf.org/doc/html/rfc6979#section-3.2) worries me, i.e., \"Performing a simple modular reduction would induce biases that would be detrimental to signature security\"\r\n\r\nIs this something that we will have to also worry about?\r\n",
          "createdAt": "2022-02-03T20:54:44Z",
          "updatedAt": "2022-02-03T20:54:44Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This method already addresses the bias by pulling double the bytes. See https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-13#section-5.1.",
          "createdAt": "2022-02-03T20:58:22Z",
          "updatedAt": "2022-02-03T20:58:22Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The bias is something to be aware of, but this method handles it properly.",
          "createdAt": "2022-02-03T20:58:42Z",
          "updatedAt": "2022-02-03T20:58:42Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI, this is how it should be done with a single signer context. Threshold signing should not be restricted to this since all sorts of attacks can happen with deterministic signing.",
          "createdAt": "2022-02-07T19:24:11Z",
          "updatedAt": "2022-02-07T19:24:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Currently covered in #62 ",
          "createdAt": "2022-02-15T08:47:18Z",
          "updatedAt": "2022-02-15T08:47:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing with the merging of #62, resolution was to include this, initial test vectors conforming to this approach have been added in #67 ",
          "createdAt": "2022-03-06T23:19:03Z",
          "updatedAt": "2022-03-06T23:19:03Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOF8lax85Cwar2",
      "title": "[Proposal] An interop profile document",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/46",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Given the discussion in #8 around how the core bbs signature draft should relate to underlying cryptographic primitive selection, I wanted to propose an approach that may be inline with this emerging consensus.\r\n\r\nInstead of mentioning in the core bbs signature draft anything around concrete curves or digest algorithms we could define a seperate document which is an opinionated \"bbs signature profile\" aimed at promoting interoperable implementations. The profile would also host test vectors to facilitate this process.\r\n\r\nIf this approach is accepted by the community then I would suggest we immediately start work on one profile that uses the following.\r\n- BLS12-381 as the pairing friendly curve\r\n- SHAKE256 as the digest algorithm\r\n\r\nAlternatively if having multiple document is too complex we could elect to merge these, however we would need to be careful in how we structure the document.",
      "createdAt": "2022-01-31T22:11:44Z",
      "updatedAt": "2022-02-16T04:40:52Z",
      "closedAt": "2022-02-16T04:40:52Z",
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "I think ideally, you just name the algorithm and define it concretely for those parameters... a profile for their configuration seems a bit excessive to me.\r\n\r\nI do think you should make it obvious how someone might replace either in your spec, but I don't think you need to take ownership of defining that generality for all of IETF.\r\n",
          "createdAt": "2022-01-31T22:17:16Z",
          "updatedAt": "2022-01-31T22:17:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Ok so a counter proposal would be to generalize section 5 https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-overview which is currently empty to be more \"profiles\" with the definition of BLS12-381 under that alongside concrete test vectors?",
          "createdAt": "2022-01-31T23:51:51Z",
          "updatedAt": "2022-01-31T23:51:51Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes I think the draft should define profiles generically, plus a BLS12-381 profile concretely. That's the only curve we currently have implementations for, and we need some test vectors to make it normative.\r\n\r\nEach profile needs to define a few things either directly or by reference, and I suggest we name the profiles using a method similar to the [Noise protocol names](https://noiseprotocol.org/noise.html#protocol-names-and-modifiers). The name would presumably be used as a DST in generator creation.\r\n\r\nBesides the basic curve operations (KeyGen, hash-to-curve), and which group is used for the signature, I believe the profile should also specify the message encoding method. For a simple message encoding to include in the first draft I'd suggest just calling it something like `H2C-SHAKE256`, and requiring that all messages which aren't already scalar values must be strings hashed using `hash-to-curve` with `SHAKE256` as the digest algorithm (NB the hash used in generator creation does not have to be the same as the one used in message encoding).\r\n\r\nIn this case the profile name might be something like `BBS-2022:BLS12381-G2:H2C-SHAKE256` (it seems to read better with colons instead of underscores). I suppose another component could be added to the name if custom generators are used?",
          "createdAt": "2022-02-01T18:14:27Z",
          "updatedAt": "2022-02-01T18:21:57Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "Have a look at:\r\n\r\n- https://www.rfc-editor.org/rfc/rfc9162.html\r\n\r\n- https://datatracker.ietf.org/doc/html/rfc8812\r\n\r\nfor examples of registering things.",
          "createdAt": "2022-02-02T15:30:44Z",
          "updatedAt": "2022-02-02T15:30:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This issue has been addressed in #47 and #60, with the general consensus being around defining the BLS12-381 ciphersuite/profile within the draft",
          "createdAt": "2022-02-16T04:40:51Z",
          "updatedAt": "2022-02-16T04:40:51Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOF8lax85C0yau",
      "title": "Register algorithms for BBS signatures in JOSE and COSE IANA registry",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/48",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "As raised by @OR13 on a recent PR review we should consider the scope to register the relevant JOSE and COSE algs with the IANA registry as a part of the core draft.",
      "createdAt": "2022-02-01T19:55:28Z",
      "updatedAt": "2022-03-21T21:23:04Z",
      "closedAt": "2022-03-21T21:23:04Z",
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "Here is a good example to copy from: \r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc8812\r\n\r\nI would just do this in the current spec.\r\n\r\nThe sooner these are registered with IANA, the sooner we can all be using this suite with confidence.\r\n\r\nI think its a huge mistake to build on this suite without doing this work...because you may find that your signature or key representations change out under you, and your interoperability is destroyed because you have no name for their former and newer serializations.",
          "createdAt": "2022-02-02T15:16:27Z",
          "updatedAt": "2022-02-02T15:17:12Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As long as it doesn't lock implementors into only using JOSE/COSE",
          "createdAt": "2022-02-07T19:56:56Z",
          "updatedAt": "2022-02-07T19:56:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Of course not, just defines how the scheme can be used in those data representations",
          "createdAt": "2022-02-07T22:58:41Z",
          "updatedAt": "2022-02-07T22:58:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Its worth noting that the current standard JOSE and COSE forms do not support the style of cryptographic representation required by a protocol like BBS Signatures. However [JWP](https://github.com/json-web-proofs/json-web-proofs) is likely to define one that will, so the ability to register suitable algorithms in the IANA registry, in this draft, will likely be dependent on that drafts completion, alternatively another internet draft could be written after this to define the registration.",
          "createdAt": "2022-02-16T07:54:21Z",
          "updatedAt": "2022-02-16T07:54:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Based on the perspective shared above I'm proposing we close this issue on the grounds that it is out of scope for the current drafts to make IANA registrations for specific data representation forms like JOSE and COSE, marking as pending-close on that basis.",
          "createdAt": "2022-03-21T02:33:59Z",
          "updatedAt": "2022-03-21T02:33:59Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "@tplooker I mostly care about the `OKP`, `crv`, `alg` side of these registrations.... Are they going to be handled in a different IETF spec? if so, can we link to something before closing this, so future searchers know where to join in / help ?",
          "createdAt": "2022-03-21T12:50:09Z",
          "updatedAt": "2022-03-21T12:50:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "w.r.t BLS12-381 key representation [this draft](https://tplooker.github.io/draft-looker-cose-bls-key-representations/draft-looker-cose-bls-key-representations.html) is where the definitions for JOSE and COSE iana registrations are mastered.\r\n\r\nw.r.t to the algorithmic registration for BBS in JWP (an extension of JOSE) refer to [here](https://json-web-proofs.github.io/json-web-proofs/draft-jmiller-json-proof-algorithms.txt). No current extension draft for usage of BBS in COSE exists yet.",
          "createdAt": "2022-03-21T21:20:11Z",
          "updatedAt": "2022-03-21T21:20:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@OR13 does that help?",
          "createdAt": "2022-03-21T21:21:36Z",
          "updatedAt": "2022-03-21T21:21:36Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "- (jwk) https://tplooker.github.io/draft-looker-cose-bls-key-representations/draft-looker-cose-bls-key-representations.html\r\n- (alg) https://json-web-proofs.github.io/json-web-proofs/draft-jmiller-json-proof-algorithms.txt\r\n\r\ngood to close",
          "createdAt": "2022-03-21T21:22:46Z",
          "updatedAt": "2022-03-21T21:22:46Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOF8lax85C990s",
      "title": "Cite relevant prior academic works",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/52",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The BBS Signature scheme is based on a wealth of prior academic work that should be appropriately referenced. Any deviations from these works should also be documented in an informative appendix while the scheme continues to develop. Lets use this issue to collate these sources",
      "createdAt": "2022-02-03T20:50:48Z",
      "updatedAt": "2022-03-06T23:16:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "[Anonymous Attestation Using the Strong Diffie Hellman Assumption Revisited](https://www.researchgate.net/publication/306347781_Anonymous_Attestation_Using_the_Strong_Diffie_Hellman_Assumption_Revisited)",
          "createdAt": "2022-02-03T20:52:48Z",
          "updatedAt": "2022-02-03T20:52:48Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First revision from bbs to bbs+: [Constant-Size Dynamic k-TAA (2006)](https://link.springer.com/chapter/10.1007/11832072_8)\r\n\r\nMost recent work (to my knowledge) on bbs+ (paywalled): [A Novel Dynamic Group Signature with Membership Privacy(2021)](https://ieeexplore.ieee.org/abstract/document/9346238)\r\n\r\nOther relevant work but not strictly about bbs+:\r\n\r\n- [Short Group Signatures (2004)](https://link.springer.com/chapter/10.1007/978-3-540-28628-8_3)\r\n\r\n- [Short Signatures Without Random Oracles (2004)](https://link.springer.com/chapter/10.1007/978-3-540-24676-3_4)\r\n\r\n- [Signature Schemes and Anonymous Credentials from Bilinear Maps (2004)](https://link.springer.com/chapter/10.1007/978-3-540-28628-8_4)\r\n",
          "createdAt": "2022-02-03T21:10:43Z",
          "updatedAt": "2022-02-03T21:10:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to the discussion in #69 and #70",
          "createdAt": "2022-03-06T23:16:27Z",
          "updatedAt": "2022-03-06T23:16:27Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "I_kwDOF8lax85DDhyM",
      "title": "Indexes and messages notation",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/54",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "The spec makes heavy use of lists of messages and indexes. We need a consistent way to represent those.\r\n\r\n**- Option 1**:\r\nRepresent indexes with a consisted format like `I_t`, `I_d` corresponding to the total and disclosed messages. Represent the messages with something like,\r\n\r\n    (msg[i] for i in I_d)   // or I_t\r\n\r\nAs such `spkGen` for example will be,\r\n\r\n    spkGen(spk, PK, I_t, I_d, (msg[i] for i in I_d), pm)\r\n\r\n**- Option 2**:\r\nDefine that all signatures on `L` messages will use the `L` first generators. With that, instead of the indexes of all the signed messages we can pass just the `totalSignedMessages`. That will also allow for a solution like [here](https://github.com/decentralized-identity/bbs-signature/issues/10#issuecomment-1018041832) with\r\n\r\n    spkGen(spk, PK, revealedMessages, totalSignedMessages, pm)\r\n\r\nwhere `revealedMessages` is a map between index and message. The drawback here is that when creating commitments for blind signatures, the user will need to choose the `n` first generators, with `n = Total_Committed_Messages` (i.e., always follow the example flow from the [blind signatures spec](https://github.com/decentralized-identity/bbs-signature/blob/main/draft-blind-bbs-signatures.md)), which could be restrictive for some applications.\r\n\r\n**- Option 3**:\r\nA compination of both, i.e.,\r\n\r\n    spkGen(spk, PK, Indexes, revealedMessages, pm)\r\n\r\nwhere again `revealedMessages` is a map between index and message and `Indexes` the indexes of all the messages",
      "createdAt": "2022-02-05T18:20:43Z",
      "updatedAt": "2022-03-02T17:56:29Z",
      "closedAt": "2022-03-02T17:56:29Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "With the merge of #64 is there anything outstanding with this issue @BasileiosKal? or can we close this?",
          "createdAt": "2022-03-02T04:58:39Z",
          "updatedAt": "2022-03-02T04:58:39Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeap. Further discussions on generators and indexes is better to be held elsewhere (like #68). Closing.",
          "createdAt": "2022-03-02T17:56:29Z",
          "updatedAt": "2022-03-02T17:56:29Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOF8lax85DvVOX",
      "title": "Document rationale for why BBS Signatures are only efficient when the signatures generated are in G1 and public keys are in G2",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/59",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Unlikes BLS signatures which as per [the spec](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-02#section-2.1) define two possible variations in the scheme based on which sub-group is used for the signatures and public keys. Because of the unique mathamatical computations involved for proof generation (SPK gen) being only efficient when performed in G1, the effective variant of BBS signatures that would instead use G2 is impractical. We should document this in the spec.",
      "createdAt": "2022-02-13T21:32:49Z",
      "updatedAt": "2022-02-16T08:59:22Z",
      "closedAt": "2022-02-16T08:59:21Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOF8lax85ETuUH",
      "title": "Named message generators",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/68",
      "state": "OPEN",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm finding that it would be beneficial to define generators more generally, instead of just having `H_0` for blind signatures and `H_1 ... H_n` for indexed messages. Extensions to the BBS signature scheme may want to reserve one or more message indexes for particular purposes (wallet binding, revocation, etc), but this leads to conflict when multiple extensions are used at once. You would likely need to define a new signature scheme for every supported combination in order to specify what message indexes are used for what purpose.\r\n\r\nInstead, I believe we can define special-purpose message generators which have unique identifiers rather than indexes. You can also think of these as 'unordered' generators, with standard usage that is consistently defined across various credential schemas. A few potential uses that I've identified:\r\n\r\n- a 'linked secret'/'wallet binding' generator for preventing use of credentials without the secret (Indy's use case)\r\n- a 'device binding' generator (for a secret value that can be authenticated as generated by a trusted module)\r\n- revocation entry and revocation group generators for linking to an accumulator or other revocation mechanism\r\n- a schema identifier generator\r\n- a credential ID generator\r\n- a credential set ID generator (for a collection of credentials that can be presented in combination)\r\n- a credential creation time generator\r\n- a credential expiration time generator\r\n\r\nWe could also reformulate a couple things in these terms:\r\n\r\n- `H_0` becomes the 'blinded signature' or 'commitment' generator\r\n- `P1` could be replaced by a 'base point' generator - freeing it up to be used as a holder binding generator as in #37 (NB. in this case the associated message would always be `1`)\r\n\r\nThese generators might be defined either specific to an issuer key or globally by adding a unique identifier to the hash-to-curve input. Some thought would be needed here to define the process exactly. For debugging purposes, messages tied to these generators might also be represented as a dictionary while numbered messages are represented as a list, for example:\r\n\r\n```json\r\n{\r\n  \"revocation index\": 1,\r\n  \"revocation group\": \"mydomain.com/users\",\r\n  \"schema\": \"http://schema.org/Person\"\r\n}\r\n```",
      "createdAt": "2022-02-21T16:40:49Z",
      "updatedAt": "2022-03-04T10:47:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> `P1` could be replaced by a 'base point' generator - freeing it up to be used as a holder binding generator as in https://github.com/decentralized-identity/bbs-signature/issues/37\r\n\r\nIn particular - this could be made into an issuer-specific (public key-specific) generator, potentially alleviating security concerns with the other generators being universal.",
          "createdAt": "2022-02-21T17:10:01Z",
          "updatedAt": "2022-02-21T17:10:01Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead I really like the thinking here I agree there are many applications of generators within BBS signatures for special purposes. IMO in order to keep the core draft simple I think we leave operations that involve using generators with a contract like proposed in #64, put simply the core draft should not be aware of any specific application of a particular generator. Instead we can profile on top of the core draft a \"bound\" variant of the BBS signature scheme that defines the generator used for cryptographic holder binding and the likes",
          "createdAt": "2022-02-21T20:58:25Z",
          "updatedAt": "2022-02-21T20:58:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1. This is definitely very usefully. An issue IMO is how we define those special purpose generators. Would the generators used for blind signatures be considered \"special purpose\" in that case?? If yes this would be more complicated than just defining specific use and identifiers for 5-10 generators. Finally, shouldn't we also try to define the \"special\" messages corresponding to those \"special\" generators??\r\n\r\nOne way could be:\r\n1. define the core operations to act on any generator (as in PR #64 which as @tplooker mentioned leaves the core operations agnostic and hence simple). Since the operations will take as input a list of generators and not indexes or identifiers they will not know if the generator is special or not.\r\n2.  define the concept of messages \"committed\" using a generator (i.e., the concept of the mapping between the message and the generator, briefly touched again on PR #64).\r\n3.  define some special generators and the meaning of the messages \"committed\" with them (i.e., a message \"committed\" with special generator \"special_generator_1\" will represent the signatures expiration time etc.). This can be an extra section. No change will be needed in the core operations.\r\n\r\nThe generators used for blinding will not be considered \"special\", which avoids many complexities. @andrewwhitehead is this what you had in mind?? ",
          "createdAt": "2022-02-21T22:44:23Z",
          "updatedAt": "2022-02-21T22:44:23Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The difficult complexity arises when we want to start tracking the allocation of ordinary message generators in certain contexts for special purposes, my inclination is to instead keep these seperate. \r\n\r\nFor instance we dont want a situation to arise where a prover tries to fool a verifier into saying here is a proof from a \"bound\" BBS signature where the first message is un-revealed but because that generator is used in the same way as \"non bound\" BBS signatures some other mechanism would have to be used by the verifier to disambiguate that they are truely looking at a proof generated from a \"bound\" BBS signature.",
          "createdAt": "2022-02-22T02:26:12Z",
          "updatedAt": "2022-02-22T02:26:12Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The counter problem this creates is because the number of message generators is effectively un-bounded how do we ensure when we select \"special generators\" that they do not collide with message generators?",
          "createdAt": "2022-02-22T02:27:41Z",
          "updatedAt": "2022-02-22T02:27:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This complexity gets even hard to solve for if we want to support arbitrary blind message signing but also maintain conceptually different generators (e.g a set of message generators and a set of blind message generators)",
          "createdAt": "2022-02-22T02:29:01Z",
          "updatedAt": "2022-02-22T02:29:01Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> +1. This is definitely very usefully. An issue IMO is how we define those special purpose generators. Would the generators used for blind signatures be considered \"special purpose\" in that case?? If yes this would be more complicated than just defining specific use and identifiers for 5-10 generators. Finally, shouldn't we also try to define the \"special\" messages corresponding to those \"special\" generators??\r\n\r\nI probably shouldn't include the `H_0` generator in this because it adds confusion, and that generator is used in the SPK (although I'm not sure at the moment why it isn't treated as a normal hidden message). It's fine to continue defining it as the zeroth indexed generator. And yes, the format of the messages committed with a particular \"special\" generator will need to be defined, but that can be specified in the same extension draft where the generator is named.\r\n\r\n> 1. define the core operations to act on any generator (as in PR [Messages and generators notation update for readability\u00a0#64](https://github.com/decentralized-identity/bbs-signature/pull/64) which as @tplooker mentioned leaves the core operations agnostic and hence simple). Since the operations will take as input a list of generators and not indexes or identifiers they will not know if the generator is special or not.\r\n\r\nI think I agree with this.\r\n\r\n> 2. define the concept of messages \"committed\" using a generator (i.e., the concept of the mapping between the message and the generator, briefly touched again on PR [Messages and generators notation update for readability\u00a0#64](https://github.com/decentralized-identity/bbs-signature/pull/64)).\r\n\r\nAlso makes sense.\r\n\r\n> 3. define some special generators and the meaning of the messages \"committed\" with them (i.e., a message \"committed\" with special generator \"special_generator_1\" will represent the signatures expiration time etc.). This can be an extra section. No change will be needed in the core operations.\r\n\r\nAt the moment I think it would be best to define the general concept of 'extension generators' and how to create them independent of the curve being used (ie. hash a URI to a group element, perhaps), in the core draft. Then extensions to the BBS draft can simply say something like \"define the credential index generator as an extension generator with URI <http://...>\". Depending on uptake the implementations might cache certain generators that are frequently used. I don't think we need to add any specific instances of these generators to the core draft currently.\r\n\r\nNaming-wise we could also distinguish between 'ordered' and 'unordered' generators.",
          "createdAt": "2022-02-22T03:30:11Z",
          "updatedAt": "2022-02-22T03:48:36Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The counter problem this creates is because the number of message generators is effectively un-bounded how do we ensure when we select \"special generators\" that they do not collide with message generators?\r\n\r\nWe just need to select them randomly or based on a hash. The chance of collision is on the same order as with selecting a secret key, I believe.\r\n\r\n> This complexity gets even hard to solve for if we want to support arbitrary blind message signing but also maintain conceptually different generators (e.g a set of message generators and a set of blind message generators)\r\n\r\nI'm not really sure what you're getting at here, the generators are the same in any case. It seems reasonable that the issuer will only accept commitments for certain known message generators depending on the protocol being executed.\r\n\r\nIncidentally parties should never be sending message generators themselves, they should only be referred to or known implicitly.",
          "createdAt": "2022-02-22T03:38:21Z",
          "updatedAt": "2022-02-22T03:38:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> At the moment I think it would be best to define the general concept of 'extension generators' and how to create them independent of the curve being used (ie. hash a URI to a group element, perhaps), in the core draft. Then extensions to the BBS draft can simply say something like \"define the credential index generator as an extension generator with URI http://.../\". Depending on uptake the implementations might cache certain generators that are frequently used. I don't think we need to add any specific instances of these generators to the core draft currently.\r\n\r\nAh ok, I think I understand better now. Thanks you! So the concept is to define an alternative way of creating generators, something like `Hash2Curve(Hasher(GID), DST)`, where `GID` a special generator identifier??\r\n\r\nTwo things worry me though. \r\n1. To @tplooker point, domain separation becomes very important for some of those use cases. We will not be able to define the necessary DSTs here though.\r\n2. Applications should not be able to define their own generator identifiers (`GID` above). A URI could contain random or \u201crandom looking\u201d elements. The prover could then try to convince the verifier that they supplied correct \"special generator URIs\". If those are not specified by some spec or profile, there is no way for the verifier to know that the random looking elements they contain are not maliciously formed (which will result to maliciously formed generators). the prover could perform \"pre-image\" attacks to create generators that would allow them to present proofs for messages they don\u2019t have etc. \r\n\r\nIMO if the definition of special generators does not raise complexity too much, it can be useful including it to the spec but only as a point that other profiles and specs can expand upon and we should make it clear that this is the case, i.e., that applications must not define their own special generators.",
          "createdAt": "2022-02-22T18:03:04Z",
          "updatedAt": "2022-02-22T18:03:04Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems reasonable that the issuer will only accept commitments for certain known message generators depending on the protocol being executed.\r\n\r\nFor blind signatures, I think there is benefit in allowing the use of any arbitrary generator, to support use cases like in issue #29 (and more specifically [here](https://github.com/decentralized-identity/bbs-signature/issues/29#issuecomment-1023851074)) where a \u201cmessage\u201d generator for one signature could become a \u201ccommitment\u201d generator for another.\r\n\r\n> Incidentally parties should never be sending message generators themselves, they should only be referred to or known implicitly.\r\n\r\nDefinitely. We must document that in the spec.",
          "createdAt": "2022-02-22T18:14:16Z",
          "updatedAt": "2022-02-22T18:21:48Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For blind signatures, I think there is benefit in allowing the use of any arbitrary generator, to support use cases like in issue https://github.com/decentralized-identity/bbs-signature/issues/29 (and more specifically https://github.com/decentralized-identity/bbs-signature/issues/29#issuecomment-1023851074) where a \u201cmessage\u201d generator for one signature could become a \u201ccommitment\u201d generator for another.\r\n\r\nTechnically any message generator can be used in a commitment. I'm just saying that from a business logic and security perspective the issuer should only be issuing blinded signatures in specific use cases, and the holder will basically be told what form the commitment should take. In fact all the cases I can think of work better with named generators than with positional ones, because they can better restrict the interpretation of the message \u2013\u00a0for example, as a linked secret, instead of just 'message 1'.",
          "createdAt": "2022-02-22T18:28:45Z",
          "updatedAt": "2022-02-22T18:28:45Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right. So i guess the question i have (although this may be better discussed separately) is will the blind signatures extension define specific generator URIs to be used, i.e., only named generators, which may not allow the above [use case](https://github.com/decentralized-identity/bbs-signature/issues/29#issuecomment-1023851074) but increase simplicity and security or will blind signatures be able to use any generator increasing flexibility, and leave the exact definition of the named generator URIs to another spec (like a profile or a registry)?? \r\n\r\nRegardless I think the concept of the \"special\" named generators is worth documenting in the spec. I do agree that many use cases will benefit from it. As i said applications should not define their own named generators but technically an Issuer could, as long as the verifier can validate that those named generators are as defined from the issuer. I would prefer to just say that only other specs can define URIs for named generators though (maybe even an IANA registry??). This also has the advantage that those specs can define the necessary DSTs.",
          "createdAt": "2022-02-22T21:42:29Z",
          "updatedAt": "2022-02-22T21:42:29Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think the blind signatures extension needs to refer to any specific generators except `P1` and `H0` or whatever fills that role. It could have a non-normative section about generator selection maybe. Another nice thing about the named generators is that you can compose multiple commitments more easily since they aren't sensitive to ordering, which might help in that particular use case. (I notice that the example of a separate attribute provider only hides the attribute value if it has a large range, otherwise the issuer could discover the value by testing.)\r\n\r\nAgree that applications should not be defining their own named generators (or whatever we call them), I think it's more of an ecosystem-level concept, and it makes sense to me to have a registry for them. I'm not sure what kind of DST is required, maybe it should just be the BBS signature scheme identifier as with the current generators?",
          "createdAt": "2022-02-22T22:13:21Z",
          "updatedAt": "2022-02-22T22:13:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Currently, I don't think any special mechanism for 'named' generator creation needs to be defined, as we can define everything in terms of `CreateGenerators` (see #71).\r\n\r\n- The current generators `(P1, H1, ... Hn)` can be defined by `CreateGenerators(PROTOCOL_DST, CORE_SEED, n+1)[0..n]`. CORE_SEED would normally be a spec-defined global seed value, but could be the issuer public key for issuer-specific generators, or an application-specific value if desired.\r\n- Extensions may define one or more seeds for their own generators, as well as usage details. For example a 'credential metadata' spec could define a seed which was a URI pointing at the specification. It would then outline that generator `0` for the given seed is used for the credential schema, generator `1` for the credential ID, and generator `2` for the issuance date in YYYYMMDD format.\r\n- Using the same mechanism, the blind signature spec would define the `s` generator (currently `H0`) as `CreateGenerators(PROTOCOL_DST, BLIND_SIGN_SEED, n)[0]`.",
          "createdAt": "2022-03-02T20:18:48Z",
          "updatedAt": "2022-03-02T20:19:33Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As a further update following #70, it looks like there is no avoiding `H0` so it would have to be defined in the core. In that case I think it should just be the 0th element of the `CreateGenerators(PROTOCOL_DST, CORE_SEED, n+1)` sequence (basically the same as now).\r\n\r\nIf we do decide to replace `P1` (need to create a separate issue for this) then element `0` could be that base point, element `1` would be `H0`, and the message generators would be elements `2..n+1`.",
          "createdAt": "2022-03-03T21:00:52Z",
          "updatedAt": "2022-03-03T21:00:52Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Even if we decide to change `P1`, It may be useful to define it in the core spec separately from the generators created from `CreateGenerators` (i.e., as its own \"named\" generator). That way, even if we move to issuer specific generators, `P1` will not change (in all literature `P1` is fixed).",
          "createdAt": "2022-03-04T10:47:08Z",
          "updatedAt": "2022-03-04T10:47:08Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOF8lax85EdnEX",
      "title": "Ensure SpkGen algorithm is still consistent with academic literature",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/69",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Opening this to track the ongoing work happening in the background after the merging of #62, @BasileiosKal and @mikelodder7 will co-ordinate on this and once complete we can close this issue",
      "createdAt": "2022-02-23T21:44:59Z",
      "updatedAt": "2022-02-24T14:52:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to track some issues. All of those may become mute from issue #70.\r\n\r\n1. After talking with Mike i understood that the problem was not that the equations between the spkGen and spkVerify are not consistent but that they are not consistent with the paper, especially the ones going into the SPK. Specifically, the first equation proven by the SPK in the spec now is `Abar - D = - A' * e - H0 *r2` while the same equation in the paper is `Abar - D = - A' * e + H0 *r2`. The second equation is the same in both cases. From my calculations, there is an extractor for those equations, however its quite different from the one used in the paper, which means we must describe it in the spec. IMO it would be better to change `r2^ = r2~ + c * r2` to  `r2^ = r2~ - c * r2` so at least the equations going into the SPK will be the same as in the paper, meaning that we don't have to describe a new extractor in the spec. Changing the formulas is fine but i would prefer equivalent equations to go into the SPK so we don't have to describe a new extractor, especially since it doesn't seem to give to much of an efficiency advantage (it's only calculating one more negative).\r\n\r\n2. Just to track another issue here, Mike mentioned that the `m^_i` in `C2` in spkVerify may need to go with a \"-\", although looking at it now it seems consistent?? because of the `-r3~` and `-r3^` multiplied with `D`? I may be missing something.",
          "createdAt": "2022-02-24T14:52:54Z",
          "updatedAt": "2022-02-24T14:52:54Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOF8lax85Eduuo",
      "title": "Simpler SpkGen option",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/70",
      "state": "OPEN",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm curious what's wrong with this simpler SPK alternative which doesn't specifically use `h_0` and `s`, treating them as a hidden message: https://hackmd.io/8t8o56mvTL6p-VZyayLnTA?view\r\n\r\nOne benefit here is that blind signatures become a true extension of the core spec, probably using a [named generator](#68), and signatures which don't involve this generator at all can be supported.",
      "createdAt": "2022-02-23T22:26:05Z",
      "updatedAt": "2022-03-07T17:34:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is truly very interesting. How will you prove zero knowledge though?? Following the same logic from the [paper](https://eprint.iacr.org/2016/663.pdf) doesn't seem possible, especially for `Abar` (the issuer will have to publish `Gbar ^ (-e)` for every signature, but the simulator will not know which one to use since they don't know the signature. Note that in the papers version the issuer publishes `Gbar ^ x` which is the same for all signatures)",
          "createdAt": "2022-02-24T00:09:33Z",
          "updatedAt": "2022-02-24T00:09:33Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At first glance, I think you just take a random `p` and `D`, set `A' = Gbar_1*p` and `Abar = Gbar_2*p - D`? I need to go through it a bit more though.",
          "createdAt": "2022-02-24T00:20:55Z",
          "updatedAt": "2022-02-24T00:29:04Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wright, that makes sense. In general, although I do agree that we may need to look more into it, this is a strong +1 from me. It simplifies spkGen so much that I think it is worth moving away from the papers. We will need to describe the simulator/ extractor in the spec though. IMO it's worth it.\r\n\r\nAlso, I think `C2` in the prover should be\r\n```\r\nC2 = D*r3~ - sum_over_R(H_i * m~_i)\r\n```\r\nAnd then in the verifier it should be\r\n```\r\nC2 = (-P1 - sum_over_D(H_i * m_i)) * c + D * r3^ - sum_over_R(H_i * m^_i)\r\n```\r\n(we may want to invert all the + and - for efficiency. i,e., leave the equations the same and only change `D*r3~` to `D*(-r3~)` in the prover and `D*r3^` to `D*(-r3^)` to the verifier. I think that can also work)",
          "createdAt": "2022-02-24T12:57:26Z",
          "updatedAt": "2022-02-24T14:45:28Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, yes I just negated `r3` in `C2` consistent with the current proof.",
          "createdAt": "2022-02-24T16:19:37Z",
          "updatedAt": "2022-02-24T16:19:37Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@andrewwhitehead prove that this is secure. If you're going to deviate from the original paper spec then please provide a proof of security.",
          "createdAt": "2022-02-28T21:22:42Z",
          "updatedAt": "2022-02-28T21:22:42Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's actually trivial to convert from this proof output to the current proof output and still have it verify, which tells me it must be secure from the verifier's perspective. Is there more to the original proof than the Lemma 2 paragraph?\r\n\r\nIn any case, for a proof from this method `(A', Abar, D, e^, r2^, m^_0, {m^_i}, c)` one can just set `Abar2 = Abar + D`, `r3^ = - r2^`, `s^ = m^_0` and output `(A', Abar2, D, e^, r2^=0, r3^, s^, {m^_i}, c)`. A prover could do this now and save a few cycles (the `r3^` negation is only because it's negated earlier here).",
          "createdAt": "2022-03-01T00:34:07Z",
          "updatedAt": "2022-03-01T00:50:50Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do also agree with @mikelodder7 that we should supply a proof of security on the spec, i.e., describe an extractor and a simulator, rather than mapping to the original proof value (although that is good for having confidence in the security of the new method). Those do seem to be more or less constructed by @andrewwhitehead though and from my testings everything seems to work. Still more reviews are needed (and will likely come from the cfrg).",
          "createdAt": "2022-03-01T16:37:45Z",
          "updatedAt": "2022-03-01T16:37:45Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes I agree it needs a formal proof, but I'm still curious why the original proof goes to the trouble it does with H_0, as it seems like an intentional choice.",
          "createdAt": "2022-03-01T17:02:13Z",
          "updatedAt": "2022-03-01T17:02:13Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is curious. \u03a4he only thing that comes to mind is that they wanted to just use the proof of knowledge they had on [Camenisch, Drijvers and Hajny, 2016](https://www.researchgate.net/profile/Jan-Camenisch/publication/310823143_Scalable_Revocation_Scheme_for_Anonymous_Credentials_Based_on_n-times_Unlinkable_Proofs/links/599bdfd745851574f4ac7bcd/Scalable-Revocation-Scheme-for-Anonymous-Credentials-Based-on-n-times-Unlinkable-Proofs.pdf) for weak Boneh-Boyen signatures, which they do reference as \"inspiration\" for the bbs+ proof. In that proof (for weak Boneh-Boyen signatures), if we map `sigma` to `A`, `m` to `e` and `g1` to `B` we will get essentially the \"standard\" bbs+ proof I think.",
          "createdAt": "2022-03-01T17:39:28Z",
          "updatedAt": "2022-03-01T17:42:05Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the document now to add an attempt at the proof.",
          "createdAt": "2022-03-01T20:06:59Z",
          "updatedAt": "2022-03-01T20:06:59Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there's two ways this could be integrated in the current spec(s).\r\n\r\n- Simply update `SpkGen` and `SpkVerify` to follow this method, but explicitly handling `s` as an unrevealed message. This would mean that the `s` generator would need to be defined in the core spec, whether it is chosen to be global or issuer-specific. Commitments, commitment proofs, blinded signature creation, and unblinding would still be defined in the separate specification.\r\n\r\n- `Sign`, `Verify`, `SpkGen`, and `SpkVerify` can be updated to remove any mention of `s`. This would change the representation of the basic signature to have just `A` and `e` components. Since the blind signing extension spec already needs to define its own `BlindSign` method in order to include the commitment value, this does seem like a reasonable option to me. Note that blind signatures would still be compatible with the core methods, but `s` would be handled as an unrevealed message against a standard generator (defined in the extension spec).",
          "createdAt": "2022-03-02T19:27:06Z",
          "updatedAt": "2022-03-02T19:33:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would go with option 1. IMO changing the signature would raise more questions and require more proofs (and unforgability proofs would be much harder constructed and described). This also facilitates the fact that `s` should be treated differently at least in `spkGen` i.e., as a secret message that is never revealed. That also requires `s` to be uniform random (not much use if the verifier is able to guess it) so it is easier to define it that way in `sign`.\r\n\r\nThe reason i think we should keep using `s` in `spkGen` is that if we don't then if `A` becomes known it can be used to reveal all the messages from the proof since it holds that `e(A, D) = e(B, A')`. The adversary could just keep trying hidden messages -which most likely will not be that many- and check the equality until they find `B`. Granted this \"attack\" is highly unlikely (maybe if the issuer's records get compromised, and only `A` is revealed?), but that will not even be possible if `B` contains a uniformly random element.",
          "createdAt": "2022-03-02T21:12:13Z",
          "updatedAt": "2022-03-02T21:42:11Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems likely that if `A` becomes known then `s` would also be known, no?\r\n\r\nIn any case I did find this in section 5.2 of CL16:\r\n\r\n>Our protocol is quite similar to the most recent qSDH-based DAA schemes [Che09,BL10,CU15]. However, a few key changes were needed to achieve provable security and address the problems mentioned in Sect. 2. First, we use a BBS+ signature for the membership credential, instead of the simplified credential where the s-value is ommited as used in the recent schemes [Che09,BL10,CU15]. This credential is proven to be unforgeable, where the simplified version is not.",
          "createdAt": "2022-03-02T21:59:35Z",
          "updatedAt": "2022-03-02T21:59:35Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems likely that if A becomes known then s would also be known, no?\r\n\r\nYea which kinda raises an issue now that i think about it. If the signature is revealed at any point any subsequent proof presentations will be insecure (not zero knowledge). \r\n\r\nMaybe a some slight modification of the original proposal is needed?? Just throwing an idea, maybe defining first `D = B * r2` and then `A' = A * (r1*r2)` and `Abar = A'*(-e) + D * (r1) = A'*x`?? I have not test the modification at all formally for security, but from a very quick look it seems it may hold and i think it may also solve the above issue.",
          "createdAt": "2022-03-02T22:39:26Z",
          "updatedAt": "2022-03-02T22:39:26Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So here's the proposed modification and the security analysis; https://hackmd.io/@Vasileios/H190hWAg5\r\n\r\nEssentially it's the same method as the [original proposal](https://hackmd.io/8t8o56mvTL6p-VZyayLnTA?view) from @andrewwhitehead but using an additional random number when blinding `A` in a way that doesn't raise complexity too much. This changes a little the specifics of the proof and makes spkGen to have 2 additional steps but it avoids the above problem, i.e., it no longer holds that `e(A, D) = e(B, A')`. Notice also that the simulator is essentially the same as the one in [CDL16](https://eprint.iacr.org/2016/663.pdf).",
          "createdAt": "2022-03-03T13:38:35Z",
          "updatedAt": "2022-03-03T13:38:35Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me, and the intent of the original seems clearer now. I slightly prefer setting `r3 = -1/r2` so that the verifier doesn't need to negate anything, but if message responses need to be in the form `m^i = m~i - c*m_i` then that might change anyway.",
          "createdAt": "2022-03-03T17:56:08Z",
          "updatedAt": "2022-03-03T17:56:08Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Looks good to me, and the intent of the original seems clearer now. I slightly prefer setting r3 = -1/r2 so that the verifier doesn't need to negate anything, but if message responses need to be in the form m^i = m~i - c*m_i then that might change anyway.\r\n\r\nThanks! That's a good point. I negated the `1/r2` and left the messages as `m^i = m~i + c*m_i`. This seems to be the most efficient way.\r\n\r\nI guess the next step is that we should decide if it is worth to update the spec and move away from the papers. As it is now, it seems that the `spkGen` will be more efficient and with 3-4 less steps + less point multiplications with scalars. So I don't see why to not update it since there is a more efficient version with a proof of security. Granted the security proof needs more reviews but those will likely come from the cfrg.",
          "createdAt": "2022-03-04T10:55:21Z",
          "updatedAt": "2022-03-04T11:03:39Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree that the reviews will come from the cfrg. If we\u2019re that confident in the changes let\u2019s write up a paper and submit it to be peer reviewed.",
          "createdAt": "2022-03-04T12:37:45Z",
          "updatedAt": "2022-03-04T12:37:45Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can If @andrewwhitehead is interested. I was thinking maybe working on a paper that will give an overview of bbs+ as it forms in the spec with a little more detailed security analyses compared to the original paper (+binding +blinding maybe??). Maybe we can merge the 2. First though, I don't think that having something like that been reviewed by the academic community is necessary to move with the update. Secondly, simplifying the spkGen algorithm it may not be enough novelty to have a paper submitted to a good conference (not to mention a journal).  \r\n\r\nIn the end the question kinda remains, publishing a paper will take at the very least a couple of months. In the mean time should we update the spec?? (IMO yes but i do also understand the counter point).",
          "createdAt": "2022-03-04T18:51:48Z",
          "updatedAt": "2022-03-04T18:51:48Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm happy to help out where I can, but probably can't commit to following through with a paper or conference presentation right now.\r\n\r\nJust to summarize the suggested update, ignoring sign changes (`s`, `s~`, `s^` should be named explicitly as well)...\r\n\r\n- `A'` is set to `Ar1*r2` instead of `Ar1`\r\n- `D` is set to `Br2` instead of `Br1 - H0r2`\r\n- `Abar` is set to `A'(-e) + Br1*r2` instead of `A'(-e) + Br1`, still equal to `A'x`\r\n- `C1` shows that `Abar = A'(-e) + Dr1` instead of `Abar = A'(-e) + D + H0r2`\r\n- `C2` remains essentially the same\r\n- `s^` uses the same formula as unrevealed messages, `s~ + cs` instead of `s~ + c(s - r2 * r3)` used to cancel out the extra `H0r2` factor in `D`\r\n\r\nBecause we are not looking to support the revocation mechanism in the paper, including the SPK generation performed in cooperation by the host and the TPM (`Sign Proceed`), it makes sense that the SPK can be simplified a little.",
          "createdAt": "2022-03-04T19:47:55Z",
          "updatedAt": "2022-03-04T21:46:00Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes. We may also be able to adjust the `Sign Proceed` operation to work with the simplified version. I may have to look more into it but In the protocol I think `s` isn't communicated between the host and the TPM meaning that there is no reason to \"randomize\" it beforehand using `s'`. Treating it as any other hidden message may work.",
          "createdAt": "2022-03-07T17:34:37Z",
          "updatedAt": "2022-03-07T17:34:37Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOF8lax85EyFjQ",
      "title": "Deterministic SPK",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/73",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Although deterministic proof generation should not be used in practice it may be useful to support it, so we can more easily create and update test vectors. This MUST NEVER be used in practice. The main idea is to incorporate a secret key managed by the holder of the bbs signature into spkGen that is going to be used for the generation of the random elements. This secret MUST be unique for every proof generation procedure. One possible method then, is to use the same algorithm as in deterministic signing, i.e.,\r\n```\r\nH = XOF(Holders_SK || msg_i1 ||\u2026||msg_iR || pm)\r\nr1~ = OS2IP(H.read(64)) mod q\r\nr2~ = OS2IP(H.read(64)) mod q\r\n              .\r\n              .\r\n              .\r\n```\r\nIn spkGen, maybe we can also use [RFC 8937](https://www.rfc-editor.org/rfc/rfc8937.html), which gives good security properties and is easy to use, since you don't need direct access to the secret key itself. Each random element (in the non-deterministic case) could be\r\n```\r\nrandom_element_i = OS2IP(HKDF-Expand(HKDF-Extract(HASH(Sig(Holders_SK, DST)), PRF(L)), i, 64)) mod q\r\n```\r\nTo get a deterministic spk, we could just replace the PRF with an XOF or hash. That said, this does \"bound\" the holder to use a secret, even in the non-deterministic case.\r\n",
      "createdAt": "2022-02-28T11:30:24Z",
      "updatedAt": "2022-03-02T00:10:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In Rust this is often done by making the method generic over a `rand::Rng + CryptoRng` and then substituting a deterministic generator, like a seeded ChaCha permutation.",
          "createdAt": "2022-03-02T00:10:10Z",
          "updatedAt": "2022-03-02T00:10:10Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDOF8lax85EyHKt",
      "title": "Adding the revealed messages to the chalenge to avoid forgery",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/74",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "The following is a method that could possibly allow the prover to reveal messages for which they don't have a signature, taking advantage of the Fiat\u2013Shamir challenge not containing the revealed messages. Let the prover with a signature `(A, e, s)` on messages `msg_1`, `msg_2` and `msg_3`, creating an spk revealing only `msg_1`. Going through the spkGen process the prover will calculate\r\n```\r\nC2_prover = D*(-r3~) +H0 * (s~) + H_2 * m~_2 + H_3 * m~_3\r\n```\r\nThe proof value will be,\r\n```\r\nspk = (Abar, A\u2019, D, c, e^, r2^, r3^, s^, m^_2, m^_3)\r\n```\r\nFrom the verification process we know that if `T = P1 + H_1 * msg_1` then \r\n\r\n```\r\n#EQ1: T*c + D * (-r3^) + H0*s^ + H_2 * m^_2 + H_3 * m^_3 = C2_prover\r\n```\r\n\r\nLet the prover now calculate the following,\r\n1.\t`c\u2019  = c ^ -1 mod q`\r\n2.\t`msg_adv  = m^_2 * c'`\r\n\r\nand instead of revealing spk, they send `spk2`,\r\n```\r\nspk2 = (Abar, A\u2019, D, c, e^, r2^, r3^, s^, m^_3)\r\n```\r\nwith revealed messages `msg_1` and `msg_adv`. \r\n\r\nThe verifier receiving `spk2` and `msg_1`, `msg_adv` will calculate `C1_verifier`, `C2_verifier` and check the pairing equality. Note that since `Abar, A\u2019, D, c, e^, r2^` remain the same between `spk` and `spk2`, `C1_prover = C1_verifier` and `e(A', PK) = e(Abar, P2)`. To calculate `C2_verifier` the verifier will first calculate `T2` as,\r\n\r\n```\r\nT2 = P1 + H_1 * msg_1 + H_2 * msg_adv = P1 + H_1 * msg_1 + H_2 * (m^_2 * c')\r\n```\r\nFrom that the verifier will calculate,\r\n```\r\nC2_verifier = T2*c + D * (-r3^) + H0*s^ + H_3 * m^_3 =\r\n   = D * (-r3^) + H0*s^ + (P1 + H_1 * msg_1) * c +  H_2 * (m^_2 * c' * c)  H_3 * m^_3 =  \r\n   = D * (-r3^) + H0*s^ + T * c +  H_2 * m^_2 +  H_3 * m^_3  = C2_prover\r\n```\r\nThe last equality follows from #EQ1. As a result, the verification will succeed for `msg_1` and `msg_adv`.\r\n\r\nObviously, this should not be possible, since this proves knowledge of a signature that the prover doesn't have (which contains `msg_adv`). If I'm correct on the above, most likely the only issue is with the Fiat\u2013Shamir heuristic. Note that if the protocol was interactive, that method will not work, since the prover would have to \"commit\" to the messages prior of getting the challenge `c`. Hence we should also pass the revealed messages to the hash of the challenge during spkGen and spkVerify, to \"commit\" them before the challenge is created. ",
      "createdAt": "2022-02-28T11:37:48Z",
      "updatedAt": "2022-03-07T19:59:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No this is not correct. BBS+ is unforgeable like ECDSA. This includes in proofs. You have a bug in your math. If you compute it correctly you can\u2019t forge proofs or signatures ",
          "createdAt": "2022-02-28T20:40:31Z",
          "updatedAt": "2022-02-28T20:40:31Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you highlight the bug in the maths here?",
          "createdAt": "2022-02-28T20:57:10Z",
          "updatedAt": "2022-02-28T20:57:10Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem is sending msg_adv and not m^_2. m^_2 = m~_2 +cm_2. msg_adv = m_2c' + m_2. If you calculate with that difference the equation does not balance. @BasileiosKal. ^^",
          "createdAt": "2022-02-28T21:02:45Z",
          "updatedAt": "2022-02-28T21:02:45Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It appears to work in my quick test. I think just adding the number of revealed messages to the challenge hash might be sufficient, unless there's a way to do the same thing in reverse to make that balance.",
          "createdAt": "2022-02-28T21:08:28Z",
          "updatedAt": "2022-02-28T21:08:28Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So your saying I should have over 1/c* my first name as the revealed message? In practice will someone believe that? No. The procedure for revealed messages should include the mapping of how they got to the cryptographic value.",
          "createdAt": "2022-02-28T21:15:35Z",
          "updatedAt": "2022-02-28T21:15:35Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For example, let's assume m_2 is my first name. The mapping is hash to Z_q*. If I received msg_adv, I would hash to Z_q* and check it. The hashing effectively destroys the 1/c computation and the proof fails.",
          "createdAt": "2022-02-28T21:18:00Z",
          "updatedAt": "2022-02-28T21:18:00Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not seeing how this is even working.  Just tried in my rust code and it fails.",
          "createdAt": "2022-02-28T21:18:31Z",
          "updatedAt": "2022-02-28T21:18:31Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would probably not be useful for any hashed values, but it could work for numeric values since the prover can run the protocol many times until they get a `msg_adv` value within a useful range.",
          "createdAt": "2022-02-28T21:32:17Z",
          "updatedAt": "2022-02-28T21:32:17Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do also agree this is hard to take advantage in practice but we should be protected against it either way. \r\n\r\nA forgery is still dangerous IMO.  If it's a name we talking about this may not be of use but what if it's a revocation ID and I'm able to present a different one??\r\n\r\nThe message mappings are not mandatory and IMO the proof should be safe without them. We could make hashing of the messages mandatory but I think there are simpler solutions.\r\n\r\n> I think just adding the number of revealed messages to the challenge hash might be sufficien\r\n\r\nYeap that may be anotherore efficient solution\r\n",
          "createdAt": "2022-02-28T21:35:03Z",
          "updatedAt": "2022-02-28T21:35:03Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Still not seeing how this attack even works. I just tried it and my proof fails.",
          "createdAt": "2022-02-28T21:38:26Z",
          "updatedAt": "2022-02-28T21:38:26Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I added a reproduction [here](https://github.com/andrewwhitehead/bbs-issue-74). (Edit: updated to add the unforged proof check.)",
          "createdAt": "2022-02-28T21:57:17Z",
          "updatedAt": "2022-02-28T22:34:12Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@andrewwhitehead That example is not using an unsigned message.  The point of this is that mh isn't even signed. Try it with another random message that's not in the signature.",
          "createdAt": "2022-03-01T00:42:05Z",
          "updatedAt": "2022-03-01T00:42:05Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mikelodder7 The point is that the proof verifies with the revealed message `m_adv` which is not the same as what was signed (`mh`).",
          "createdAt": "2022-03-01T00:54:43Z",
          "updatedAt": "2022-03-01T00:54:43Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, it's not sufficient to add the number of revealed messages, I believe the actual revealed messages have to be added to the hash to prevent substitution.",
          "createdAt": "2022-03-01T01:49:27Z",
          "updatedAt": "2022-03-01T01:49:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I remember @christianpaquin mentioning on a WG call that UProve included a similar mechanism?",
          "createdAt": "2022-03-01T01:55:40Z",
          "updatedAt": "2022-03-01T01:55:40Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I remember @christianpaquin mentioning on a WG call that UProve included a similar mechanism?\r\n\r\nYes, in the [U-Prove spec](https://github.com/microsoft/uprove-csharp-sdk/blob/master/docs/U-Prove%20Cryptographic%20Specification%20V1.1%20Revision%203.pdf), the prover hashes (among other things) the disclosed attribute indices and their values (see `c_p` calculation on page 18).",
          "createdAt": "2022-03-01T15:56:32Z",
          "updatedAt": "2022-03-01T15:56:32Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The problem is sending msg_adv and not m^_2. m^_2 = m~_2 +cm_2. msg_adv = m_2c' + m_2. If you calculate with that difference the equation does not balance. @BasileiosKal. ^^\r\n\r\nIf we take  `msg_adv = m~_2 * c' + msg_2` then when the verifier calculates `C2` they will get\r\n```\r\nC2_verifier = (P1 + H_1 * msg_1 + H_2 * (m~_2*c' + msg_2))*c + D * (-r3^) + H0*s^ + H_3 * m^_3 =\r\n   = D * (-r3^) + H0*s^ + (P1 + H_1 * msg_1 + H_2 * msg_2) * c  + H_2 * m~_2 + H_3 * m^_3 =  \r\n   = D * (-r3~) + H0*s~ - (P1 + H0*s + H_1 * msg_1 + H_2 * msg_2  + H_3 * msg_3) * c  + ...\r\n         ... + (P1 + H_1 * msg_1 + H_2 * msg_2) * c  + H0*(s*c) + H_2 * m~_2 + H_3 * m~_3  + H_3 * msg_3 *  c =\r\n   = D * (-r3~) + H0*s~ + H_2 * m~_2 + H_3 * m~_3 = C2_prover\r\n```\r\nSo i don't see where I'm wrong to be honest, but i could be missing something.",
          "createdAt": "2022-03-01T16:14:09Z",
          "updatedAt": "2022-03-01T16:14:09Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Actually, it's not sufficient to add the number of revealed messages, I believe the actual revealed messages have to be added to the hash to prevent substitution.\r\n\r\nRight, I guess nothing stops the prover from passing the \"wrong\" number of messages from the start (i.e., 2 in the example above). Maybe, aside from the revealed messages, we should also pass the `H_i` (or their indexes) similar to what U-prove does?? @christianpaquin where there any attacks that passing things like `<D>` and `<C>` in the challenge avoided, or it was for general good security practices??",
          "createdAt": "2022-03-01T16:22:31Z",
          "updatedAt": "2022-03-01T16:26:44Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOF8lax85FEO4w",
      "title": "BBS spk security against an untrusted/compromised issuer",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/75",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Let\u2019s say that the issuer gets compromised, i.e., both their secret key `x` and the records with the signatures they signed will become known. Let\u2019s assume a holder has a bbs+ signature `(A, e, s)` from that issuer with `A = B * (1/(e+x))` where `B = P1 + H0*s + H_1*msg_1 + \u2026 + H_L*msg_L`. Any spk will be of the form, `spk = (A', Abar, D, ...)` where \r\n```\r\nA' = A * r1 =  B * r1 * (1/(e+x))\r\n```\r\n and \r\n```\r\nAbar = A' * x =  B * r1 * (x/(e+x))\r\n```\r\nThe values `(B, B*x, A', Abar)` essentially form a DDH tuple, which is easy to solve using pairings. Specifically, it will hold, \r\n```\r\ne(B*x, A\u2019) = e(B*x, B*r1*(1/(e+x))) = e(B, B) ^(r1*(x/(e+x))) = e(B, B*r1*(x/(e+x)))\r\n```\r\nmeaning that,\r\n```\r\ne(B*x, A') = e(B, Abar)\r\n```\r\nSo, if an adversary who knows `x` and `s`, sees (or has already seen) a proof with `A\u2019` and `Abar`, they can just try different messages, construct `B` and check the above equality between the pairings. Since the messages will not be many this is not hard to do and will result in the secret messages of the holder been revealed. \r\n\r\nIf the Issuer is untrusted, they can use the above equation to track the holder by correlating the spk's with specific signatures.\r\n\r\nThis is mitigated a little by using blind or bound signatures. If the commitment is not revealed an adversary will not be able to construct `B` by trying possible hidden messages. However, it is reasonable to assume here that if the issuers secret key and the signatures they signed are revealed so will the commitments (they will be known -and possibly recorded- by the issuer). Furthermore, if the issuer is untrusted. they can still correlate the holder.\r\n\r\nAs a result, the bbs+ proofs are not secure against an untrusted or compromised issuer. This is not that much of an issue and is like what happens in most PKIs but it might be worth documenting it in the security considerations in the spec so we will have an accurate security model.",
      "createdAt": "2022-03-03T18:07:34Z",
      "updatedAt": "2022-04-01T08:46:37Z",
      "closedAt": "2022-04-01T08:46:37Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Really interesting issue, IMO this definitely needs to be in the security considerations section. ",
          "createdAt": "2022-03-03T21:36:35Z",
          "updatedAt": "2022-03-03T21:36:35Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> So, if an adversary who knows x and s, sees (or has already seen) a proof with A\u2019 and Abar, they can just try different messages, construct B and check the above equality between the pairings. Since the messages will not be many this is not hard to do and will result in the secret messages of the holder been revealed.\r\n\r\nOne potential mitigation we should look to include here is for issuers to not keep a copy of signatures they issue? So if the issuer is compromised chances are the attacker doesnt get a copy of the s value for a signature?",
          "createdAt": "2022-03-03T21:37:21Z",
          "updatedAt": "2022-03-03T21:37:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> One potential mitigation we should look to include here is for issuers to not keep a copy of signatures they issue? So if the issuer is compromised chances are the attacker doesnt get a copy of the s value for a signature?\r\n\r\nYes, that's a good point. An honest issuer should discard at the very least `s` and not keep a record of it. If an adversary doesn't have `s`, even if they have the issuer's secret key, the above doesn't work. We should also instruct the holders of the signature that revealing `s` could compromise the security of the proof if the issuer's secret key is leaked.",
          "createdAt": "2022-03-04T00:12:23Z",
          "updatedAt": "2022-03-04T10:48:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Yes agreed, because `s` is apart of the original signature over all messages and the primary attack vector here is being able to reveal, un-revealed messages in a proof of a signature involving `s` chances are that if the issuers private key is compromised and so is `s` the attacker probably also got a copy of the original messages signed by the signature. None the less we should document this consideration carefully in the spec so implementers are aware.",
          "createdAt": "2022-03-04T20:50:41Z",
          "updatedAt": "2022-03-04T20:50:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I've tagged this issue as ready for PR as it appears we are clear around the resolution which is to add a note to the security considerations section",
          "createdAt": "2022-03-06T23:14:26Z",
          "updatedAt": "2022-03-06T23:14:26Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm having trouble seeing what correlation is enabled here.\r\n\r\n    e(B*x, A') = e(B, Abar)\r\n\r\nThis seems self-evident given that `Abar = A'x`, plus you could substitute any point for `B` in the equation and the result would be the same. That said, it did seem to me like there was a problem when this issue was initially filed.",
          "createdAt": "2022-03-21T20:58:45Z",
          "updatedAt": "2022-03-21T21:01:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is absolutely correct. Tbo kinda annoyed with my self that i missed it. I'm really sorry about that. Although It does seem to me that the issuer may still find a relationship that would correlate the prover. For example, they could calculate `K = e(p1*c, B*r1)` (since they know e, x, d) and check `e(p1*c, A') = K*(1/x+e)`. Another thing i missed though is that any method like that works on type 2 or 3 pairings. However we are exclusively using type 3 since we are using the construction of CDL16. Maybe just a note documenting that will suffice instead of the addition in #86.",
          "createdAt": "2022-03-22T13:33:00Z",
          "updatedAt": "2022-03-22T13:33:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Just re-opening this issue so we can be sure to capture any updated text required in the security considerations merged in #86 ",
          "createdAt": "2022-03-23T21:29:34Z",
          "updatedAt": "2022-03-23T21:29:34Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed in #91. Closing",
          "createdAt": "2022-04-01T08:46:37Z",
          "updatedAt": "2022-04-01T08:46:37Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOF8lax85FL7G0",
      "title": "Update core operations to clarify the form of input messages",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/76",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Currently the core sign, verify, spkGen and spkVerify operations are silent on the form the messages take into the algorithm, based on conversations with @mikelodder7 these are most often inputed in the form of scalars as outputed by the MapToScalar function being proposed in #61. We should clarify this further in the spec.",
      "createdAt": "2022-03-06T23:53:49Z",
      "updatedAt": "2022-03-21T02:29:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 78,
      "id": "I_kwDOF8lax85FQQWd",
      "title": "Domain separation of generated signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/78",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "At the moment within the scope of this specification there are several points of extension, such as\r\n\r\n- How messages are mapped to their appropriate scalar values\r\n- How the generators used to commit each message are created (e.g from a global, issuer specific or signature specific seed)\r\n\r\nMany of these above decisions will be limited or at least formally defined in a concrete [ciphersuite](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-bls12-381-ciphersuite) to promote interoperability. However with multiple possible cipher suites overtime that make different choices, how do we ensure that a signature generated under one cipher suite is not confused with one generated under another cipher suite. \r\n\r\nOne proposal to limit the possibility of this occurring is to define that the first message in a BBS signature MUST always be revealed further more this message could contain a range of information OR something more limited like a cipher suite identifier. As raised by @BasileiosKal on the call, putting too much information in this revealed message is likely to create a correlation risk that would erode some of the benefit that BBS signatures provide, so perhaps a better middle ground would be to instead encode the cipher suite identifier (e.g for the current BLS12381 cipher suite in the spec this could be the hash scalar produced from the string `BBS_BLS12381G1_XOF:SHAKE-256`)",
      "createdAt": "2022-03-07T20:29:15Z",
      "updatedAt": "2022-03-31T08:25:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you do this approach you can no longer link messages across signatures anymore. The better approach which the original paper says is to use unique generators per signer or as we've started calling it local create generators based on the signers public key.",
          "createdAt": "2022-03-07T21:18:13Z",
          "updatedAt": "2022-03-07T21:19:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you please elaborate on how this is the case, the preferred proposal is merely to have the first message be a protocol identifier? I dont see how this would prevent cross signature?",
          "createdAt": "2022-03-07T21:36:56Z",
          "updatedAt": "2022-03-07T21:36:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Local generators would still not fully address the security concern described above, for example as a holder or verifier I would not know which message mapping methods are being used in the cipher suite so a malicious party could use this to attack in certain scenarios",
          "createdAt": "2022-03-07T21:40:12Z",
          "updatedAt": "2022-03-07T21:40:12Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If each message is mapped differently to a scalar per issuer then that means my name will not map to the same value in two different signatures and therefore I can't prove they are equal.",
          "createdAt": "2022-03-07T21:41:38Z",
          "updatedAt": "2022-03-07T21:41:38Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you want a correlating identifier then why even use BBS+?!?",
          "createdAt": "2022-03-07T21:42:07Z",
          "updatedAt": "2022-03-07T21:42:07Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It solves the problem because local generators are unique per signer therefore the commitments are different and serve the same purpose as the cipher suite. ",
          "createdAt": "2022-03-07T21:43:25Z",
          "updatedAt": "2022-03-07T21:44:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Mike I think you are miss reading the actual proposal here e.g the first message is simply just the scalar mapped representation of the cipher suite id `BBS_BLS12381G1_XOF:SHAKE-256`, this is not correlating nor negates the ability to prevent cross signature linking.",
          "createdAt": "2022-03-07T21:47:21Z",
          "updatedAt": "2022-03-07T21:47:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Further more as I said above signer specific generators alone would not address the security concern about how different cipher suites may elect to support different message mapping procedures",
          "createdAt": "2022-03-07T21:47:59Z",
          "updatedAt": "2022-03-07T21:48:11Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I understand it better now. Thanks. That helps to clarify it.",
          "createdAt": "2022-03-07T21:51:19Z",
          "updatedAt": "2022-03-07T21:54:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 great, would you support such a proposal?",
          "createdAt": "2022-03-07T22:40:44Z",
          "updatedAt": "2022-03-07T22:40:44Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me. I do like the proposal. \r\n\r\nI may prefer the domain separation string to be an optional parameter of the `sign`, `verify` etc functions, so we would avoid saying that the first message MUST always be revealed, which may be confusing (for clarity, i would prefer the input list of messages to be just the attributes the issuer wants to sign). This way, if the prover and the holder have already agreed on what cyber suite to use, it will not be necessary for the prover to actually \"reveal\" that message since the verifier will already \"know it\".",
          "createdAt": "2022-03-07T23:01:28Z",
          "updatedAt": "2022-03-07T23:01:28Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Agree, in a practical sense I would expect the sign and verify APIs would take the cipher suite id as a seperate parameter rather than as the first message, that way it is clear it wouldn't actually have to be communicated to another party as the expectation is that this is communicated at a higher level similar to the DST.",
          "createdAt": "2022-03-08T00:27:14Z",
          "updatedAt": "2022-03-08T01:34:39Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "To me the proposal is clear, so I will submit a PR to further the conversation",
          "createdAt": "2022-03-08T02:49:48Z",
          "updatedAt": "2022-03-08T02:49:48Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it would be better to calculate this domain separation message in the same way as the challenge, using all the parameters that need to be enforced to avoid malleability which aren't going to vary at the time of presentation. This value would likely be cached by the prover. It may or may not be provided by the issuer at the time of issuance, I think generally it would be unless trying to save a minuscule amount of bandwidth. The inputs should include at least:\r\n\r\n- the cipher suite (and by extension the hash function and curve details)\r\n- the issuer's public key (to avoid issues such as #85)\r\n- the number of signed messages\r\n- the generator points used, in a standard order\r\n\r\nNB that the last two are necessary if the generators are not always deterministically generated from the issuer's public key and the number of messages, as they were in the earlier text. This leaves only a few things to hash into the presentation challenge:\r\n\r\n- `A'`, `Abar`, `D`, `C1`, `C2`\r\n- the revealed message indices and values (see #74), including the value of the domain separation message \u2013 and by extension the values above\r\n- the presentation nonce\r\n\r\nThe domain separation message could optionally include a byte string containing application-specific scope information. This would probably be the place for things like a schema identifier or revocation registry identifier (required-revealed attributes), and could be used to discriminate signatures that are meant to be bound to a specific session (adding a signature nonce).",
          "createdAt": "2022-03-21T23:23:51Z",
          "updatedAt": "2022-03-22T16:26:08Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the generators, couldn't the Verifier \"validate\" them using the global seed?? Other than that its a +1 from me.\r\n\r\nAlso I think we must update the blindSignatures extension to accommodate these changes. I imagine that in the extension the number of signed messages etc., will also have to take into consideration the blinded messages and so on.",
          "createdAt": "2022-03-28T20:51:45Z",
          "updatedAt": "2022-03-28T20:51:45Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Regarding the generators, couldn't the Verifier \"validate\" them using the global seed?? Other than that its a +1 from me.\r\n\r\nThis is a good question to me, if the cipher suite always fully defines the generators then I can see how perhaps this inclusion could be redundant, however if someone were to define a BBS signature cipher suite that uses signature specific, random or issuer specific generators then maybe it becomes useful to have these protected through the integrity of the signature?\r\n\r\n> Also I think we must update the blindSignatures extension to accommodate these changes. I imagine that in the extension the number of signed messages etc., will also have to take into consideration the blinded messages and so on.\r\n\r\n+1 to this too I will open an issue to track more generally that we will need to revise the blind signature extension draft to be consistent with the core draft.",
          "createdAt": "2022-03-28T21:27:39Z",
          "updatedAt": "2022-03-28T21:27:52Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's possible that the generator values could be left out, for now at least I'm erring on the side of caution and adding them.",
          "createdAt": "2022-03-28T23:47:47Z",
          "updatedAt": "2022-03-28T23:47:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> It's possible that the generator values could be left out, for now at least I'm erring on the side of caution and adding them.\r\n\r\nCould you elaborate on the potential concern here?",
          "createdAt": "2022-03-29T00:29:33Z",
          "updatedAt": "2022-03-29T00:29:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> This is a good question to me, if the cipher suite always fully defines the generators then I can see how perhaps this inclusion could be redundant, however if someone were to define a BBS signature cipher suite that uses signature specific, random or issuer specific generators then maybe it becomes useful to have these protected through the integrity of the signature?\r\n\r\nJust another thought here, maybe what is actually featured in this message is the cipher suite id + an additional data structure, where the structure and contents of which is dictated by the cipher suite itself? So for ciphersuites like the current one in the spec we dont have to include all the generators because they are fixed (e.g derived from a global seed) whereas another ciphersuite would be free to include them in the additional data structure if they saw benefit?",
          "createdAt": "2022-03-29T02:49:32Z",
          "updatedAt": "2022-03-29T02:49:32Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "So for example for the [current ciphersuite](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-bls12-381-ciphersuite) we could define that the additional data structure just contains the public key and number of signed messages.",
          "createdAt": "2022-03-29T02:50:42Z",
          "updatedAt": "2022-03-29T02:50:42Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It may be a little confusing as to why we allow generators to be included in the additional data structure (if we document the possibility somehow) since we don't allow ciphersuits to define their own generators. This is also related with the discussion in #68, but even if we allow ciphersuits to define the generators seed, it will be no different from the situation with the current ciphersuits (i.e., the validity of the generators could be derived from that seed). \r\n\r\nAlso it may be hard to define in the ciphersuits which generators to add to the \"signature domain separation\" since their exact number will most likely not be known. In contrast, at signing time, the issuer will know exactly which generators they will use. As an alternative we could perhaps add the seed value.\r\n\r\n> It's possible that the generator values could be left out, for now at least I'm erring on the side of caution and adding them.\r\n\r\nI imagine It is more secure since the verifier will be \"forced\" to \"check\" the correctness of the generators every time, otherwise it will be left on the verifier to do the check if they want to. I'm not opposed to that, since i don't imaging it will raise complexity, though i don't see the requirement changing if the generators are derived from the issuers pk, or a specific requirement to do so now.",
          "createdAt": "2022-03-29T18:54:21Z",
          "updatedAt": "2022-03-29T18:54:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the generators depend only on the seed value, then yes we can hash that instead and be more efficient. Maybe we should add security guidelines for ciphersuites to ensure agreement over the generators in the event that they do use a custom setup procedure.",
          "createdAt": "2022-03-30T18:44:41Z",
          "updatedAt": "2022-03-30T18:44:41Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. IMO we should make the generators only depend on a seed (which could also be the signers pk). Ciphersuites could define their own seeds if they want to. I don't really see a requirement to allow ciphersuites to define their own generators all together, which is also less secure. That said we should also define the security requirements of the generators, even if we only allow ciphersuit specific seeds.",
          "createdAt": "2022-03-30T19:09:37Z",
          "updatedAt": "2022-03-30T19:09:37Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes it should be part of the common reference string (CRS). That way if they do define their own generators (like just picking them at random) we allow for it. The seed should be the safest and most compatible approach ",
          "createdAt": "2022-03-31T08:25:54Z",
          "updatedAt": "2022-03-31T08:25:54Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOF8lax85FQeMK",
      "title": "Security Review of Differences",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/79",
      "state": "OPEN",
      "author": "brentzundel",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The work on the specification is progressing well, but there seem to be a number of changes being considered that will cause this specification to deviate from the published and peer-reviewed academic papers.\r\n\r\nWhile there may be more, I am concerned in particular about:\r\n#19 \r\n#37\r\n#70 \r\n#78\r\n\r\nIf these changes, or any others, are made which result in a deviation from the security proofs of the source material, then new security proofs need to be written before this spec is submitted as a draft to IETF.",
      "createdAt": "2022-03-07T21:30:34Z",
      "updatedAt": "2022-03-07T23:49:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks Brent I think we need to be careful to seperate where there are true deviations from academic literature VS ones where the literature was just not aiming to define anything at that layer, for example #78 is not a deviation from academic literature its just merely a mechanism to ensure cipher suite domain separation",
          "createdAt": "2022-03-07T21:44:58Z",
          "updatedAt": "2022-03-07T21:44:58Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that deterministic signatures also have to be evaluated in the context of the unforgeability proof.",
          "createdAt": "2022-03-07T21:59:34Z",
          "updatedAt": "2022-03-07T21:59:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "For example #62 from @mikelodder7 should be included.",
          "createdAt": "2022-03-07T22:08:32Z",
          "updatedAt": "2022-03-07T22:08:32Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "62 is computing the same thing as before it\u2019s just removing the same  check from being performed twice. It doesn\u2019t need a security proof",
          "createdAt": "2022-03-07T22:15:08Z",
          "updatedAt": "2022-03-07T22:19:08Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do also agree. From the above IMO #19 has the biggest need for a security analyses. The reason I feel confident to keep using the proposed change is that it doesn't really change the security proofs of the original academic material (both the unforgeability and the zero knowledge proof of knowledge work the same). \r\n\r\nAlso note that the construction on section 5 of the original paper considers as the issuers public key only `w` and all other generators are created for all parties from a \"common reference string functionality\" and not from the issuer (similarly to what that issue proposes).\r\n\r\nFor some of the other issues, a security proof was written and is currently discussed for #70 although it does need reviews, #37 is essentially just a commitment the same with the ones considered in the original paper and as @tplooker noted, i don't see what security proof #78 will need.",
          "createdAt": "2022-03-07T22:16:01Z",
          "updatedAt": "2022-03-07T22:16:01Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 62 is computing the same thing as before it\u2019s just removing the same check from being performed twice\r\n\r\nI think @tplooker meant the changes to the equations going in the SPK from the ones in the paper, not the duplicate checks part (which i do like).",
          "createdAt": "2022-03-07T22:24:49Z",
          "updatedAt": "2022-03-07T22:24:49Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "AFAIK there are no changes to the SPK that I made and should already match the original paper",
          "createdAt": "2022-03-07T22:33:00Z",
          "updatedAt": "2022-03-07T22:33:00Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> AFAIK there are no changes to the SPK that I made and should already match the original paper\r\n\r\nI think the first equation is different as i mentioned [here](https://github.com/decentralized-identity/bbs-signature/issues/69#issuecomment-1049939299). This is maybe better discussed elsewhere, (like #69 or maybe in a call?), but not saying that the math are not balanced, just that right now the first equation of the SPK is different (i think its `Abar - D = - A' * e - H0 *r2`, which is not simply the negation of what the paper uses). Whenever the change was introduced, it may need a security analyses (although it may be easier to update to use the same equations as in the paper).",
          "createdAt": "2022-03-07T22:45:44Z",
          "updatedAt": "2022-03-07T23:49:19Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOF8lax85FRXyd",
      "title": "Define the hash_to_curve operation using SHAKE-256 XOF for BLS12-381 ciphersuite",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/80",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently the [latest hash to curve draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14) only defines [suites](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14#section-8.8) for the BLS12-381. However due to the efficiencies involved in using SHAKE-256 we need to define the suite within this spec.",
      "createdAt": "2022-03-08T03:41:45Z",
      "updatedAt": "2022-03-09T00:42:39Z",
      "closedAt": "2022-03-09T00:42:39Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not really clear to me what the efficiencies are. SHAKE-256 doesn't seem to have a clear advantage over SHA256 from [here](http://bench.cr.yp.to/results-hash.html#amd64-skylake) and [here](https://keccak.team/sw_performance.html).  @mikelodder7 is the intent to use the faster KangarooTwelve(which is not standardized if I'm not mistaken) or the ParallelHashXOF256?? Also why not use ParallelHash256 if thats the case (do we need an XOF for hash2curve??).",
          "createdAt": "2022-03-08T20:10:25Z",
          "updatedAt": "2022-03-08T20:10:25Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We\u2019re using shake in other areas of the code and it is faster when used in hash to curve. Hash to curve requires multiple calls to sha256 vs one to shake",
          "createdAt": "2022-03-08T21:21:03Z",
          "updatedAt": "2022-03-08T21:21:03Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That clears it up! Thanks! That helped a lot to clarify it! I'm curious as to why since that is the case, the spec opts for use of expand_message_xmd with sha256 instead of expand_message_xof with shake256 when it comes to bls12-381.",
          "createdAt": "2022-03-08T21:43:00Z",
          "updatedAt": "2022-03-08T21:43:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> That clears it up! Thanks! That helped a lot to clarify it! I'm curious as to why since that is the case, the spec opts for use of expand_message_xmd with sha256 instead of expand_message_xof with shake256 when it comes to bls12-381.\r\n\r\nLikewise, this was not immediately clear to me either especially considering other hash_to_curve suites elect to use SHAKE-256 defined in the draft.",
          "createdAt": "2022-03-09T00:41:26Z",
          "updatedAt": "2022-03-09T00:41:26Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in #81 ",
          "createdAt": "2022-03-09T00:42:39Z",
          "updatedAt": "2022-03-09T00:42:39Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOF8lax85F0g0F",
      "title": "Correspondence between proof and public key",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/85",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In general, I was under the impression that a signature can be used to derive proofs that would be validated with only 1 specific key (the issuers PK).\r\n\r\nThat does not seem to be the case. The holder can present proofs for credentials signed from an issuer with public key `PK`, that will be validated with `PK * y = P2 * (x*y)`, where `y` a scalar chosen by the holder. My question is: Is this dangerous?? It is not really a forgery. It may compromise the issuer's and/or holder's accountability though, i.e., an issuer may falsely claim that they never signed a specific credential or a holder that they never possessed (and used to create an spk) a credential signed from that issuer.\r\n\r\nYou can find the detailed mathematics here: https://hackmd.io/@Vasileios/HyuXt_kf9\r\n  and a reproduction here: https://github.com/BasileiosKal/dif-bbs-issue\r\n\r\nIn general the method is the following; Let the holder having the signature `(A, s, e)` on some messages. Let also the holder wanting to create a proof that would be validated with `PK * y` instead of `PK`, for some scalar `y`. During spkGen they will calculate `Abar_f = A\u2019 * y * e + B * r1 * y` and `D_f = B * r1 * y + H0 * r2`. Note that `e(Abar_f, P2) = e(A', PK * y)`. Changing some additional values in the proof, the holder can present the spk; `(A\u2019, Abar_f, D_f, \u2026)` that will be validated with `PK * y`. \r\n\r\nA similar method works with a signature. The holder can present `(A*(y^-1), s, e*y)` which is a valid signature for the key `PK * y` (which is why the above method doesn't go against the security proofs given in the literature, i.e., a bbs proof, proves knowledge of a signature not only from the secret key `x` but also for a signature from the \"secret key\" `y * x`).\r\n\r\nIf a mitigation is needed, maybe including the issuer's PK as one of the signed messages will be an efficient solution, that solves the issuer\u2019s and/or holder\u2019s accountability issue.",
      "createdAt": "2022-03-16T18:20:35Z",
      "updatedAt": "2022-03-16T22:46:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The PK is known by the verifier so if the holder does this then it won\u2019t validate properly ",
          "createdAt": "2022-03-16T18:39:51Z",
          "updatedAt": "2022-03-16T18:39:51Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 that is probably a valid assumption to make in many circumstances, however if it is the position we take, we need to document it in the security considerations. e.g a verifier should be aware when trusting the verifier to supply the public key of the signer to verify that this condition exists.",
          "createdAt": "2022-03-16T18:45:43Z",
          "updatedAt": "2022-03-16T18:45:43Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed",
          "createdAt": "2022-03-16T18:47:40Z",
          "updatedAt": "2022-03-16T18:47:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The fact this computation on the public key exists without a mitigation also degrades the non-repudiable nature of signatures also (e.g an issuer could use it as a way to say \"i didn't sign the signature used to generate this spk\")",
          "createdAt": "2022-03-16T18:47:47Z",
          "updatedAt": "2022-03-16T18:47:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Where a valid mitigation could be @mikelodder7's suggestion above.",
          "createdAt": "2022-03-16T18:48:16Z",
          "updatedAt": "2022-03-16T18:48:16Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The PK is known by the verifier so if the holder does this then it won\u2019t validate properly\r\n\r\nAgreed. That is why there is not really a forgery here. However to @tplooker point, it does degrade the non-repudiable property of the protocol. Another example can be that a malicious issuer could claim that they originally signed a specific credential (and that the holder should pay them for that service for example).\r\n\r\nIn general i would be interested if there is also any other way to take advantage of that. Regardless IMO its kinda a weird property (with easy mitigation) that i would expect to not hold though. IMO, protocol designers need to be aware of it, and its possible mitigation, as to not introduce any vulnerabilities because they assumed otherwise.",
          "createdAt": "2022-03-16T19:20:27Z",
          "updatedAt": "2022-03-16T19:34:28Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually there\u2019s no need for any mitigation here. The technique could apply to ANY signature and public key. If the issuer alters their public key then no signature will verify or proof. The advantage of pairing based signatures is they can actually recover the signature to a working state but ECDSA schnorr and Ed25519 cannot.",
          "createdAt": "2022-03-16T21:53:04Z",
          "updatedAt": "2022-03-16T21:53:04Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I think the threat model here is the holder creates a proof with a `PK = PK * y` and transmits the `PK` to the verifier alongside the spk and the verifier ends up concluding the underlying signature proven by the spk was not signed by the private key associated to `PK` instead of `PK *y`. How does this apply to ECDSA and Ed25519 when they dont feature an spk phase",
          "createdAt": "2022-03-16T21:59:54Z",
          "updatedAt": "2022-03-16T21:59:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "OR the signer uses the fact that the holder can do this while generating the proof to repudiate (deny) the underlying signature associated to the SPK.",
          "createdAt": "2022-03-16T22:02:46Z",
          "updatedAt": "2022-03-16T22:02:46Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The same problem exists with BLS signatures too. The verifier in ANY case should not get the public key from the holder. The point I\u2019m saying is if the public key changes in any way the other signatures fall apart. The holder isn\u2019t forging a proof here but randomizing it. That\u2019s why There sometimes called randomizable signatures",
          "createdAt": "2022-03-16T22:02:56Z",
          "updatedAt": "2022-03-16T22:02:56Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The signer could do this anyway",
          "createdAt": "2022-03-16T22:03:35Z",
          "updatedAt": "2022-03-16T22:03:35Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Ok so are you saying it would be sufficient to just add something along the lines of \"The verifier in ANY case should not get the public key from the holder\" to the security considerations section?",
          "createdAt": "2022-03-16T22:05:02Z",
          "updatedAt": "2022-03-16T22:05:02Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That\u2019s why holders should call verify whenever they receive a signature regardless of the scheme including Ed25519. That\u2019s just good practice in general ",
          "createdAt": "2022-03-16T22:05:02Z",
          "updatedAt": "2022-03-16T22:05:02Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We could, but to me it\u2019s good practice to never trust the holder. You trust the signer therefore you get the key information from them",
          "createdAt": "2022-03-16T22:06:43Z",
          "updatedAt": "2022-03-16T22:06:43Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I completely agree that we should never trust the holder however the issue is not about that (after all if the holder is allowed to present whatever pk they want they can just forge whatever credential they choose). The issue has to do with untrusted issuers. The above issue essentially says that there is no way currently to hold accountable an issuer for a credential they signed when it comes to the proofs. This to me seems like it could be a problem in some scenarios (which i don't think its true for other signatures schemes).",
          "createdAt": "2022-03-16T22:14:51Z",
          "updatedAt": "2022-03-16T22:14:51Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But I can do that anyway as a issuer without having to do this method. ",
          "createdAt": "2022-03-16T22:16:24Z",
          "updatedAt": "2022-03-16T22:16:24Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see how. The signature it self guarantees the non-repudiable property. How could i do the same thing when it comes to a proof (i.e., claim it was from a different pk??)",
          "createdAt": "2022-03-16T22:22:43Z",
          "updatedAt": "2022-03-16T22:22:43Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To hold the issuer accountable requires them to register the key. Otherwise the issuer can just delete the signing key and claim they didn\u2019t create it.",
          "createdAt": "2022-03-16T22:24:02Z",
          "updatedAt": "2022-03-16T22:24:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True, my point though is that they can do that even if they register their key. What if they register their key, use it to sign a credential and then claim they never did sign that credential themselves but it was signed by someone else?? Or what if they register my pk squared to a not so careful CA and claim that they are the ones signing my credentials??  You cant prove them wrong in those cases without a mitigation (It is not only about claiming they never signed something, they can also claim they did sign something they haven't).",
          "createdAt": "2022-03-16T22:46:11Z",
          "updatedAt": "2022-03-16T22:46:11Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDOF8lax85GGntF",
      "title": "Convert challenge hash to scalar value",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/89",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently in the in spkgen and spkverify operations, the challenge is not appropriately being converted to its scalar representation, this needs to be rectified, issue originally raised during review of #84 [see here](https://github.com/decentralized-identity/bbs-signature/pull/84#pullrequestreview-911423521)",
      "createdAt": "2022-03-22T01:16:33Z",
      "updatedAt": "2022-03-22T01:16:33Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 90,
      "id": "I_kwDOF8lax85GkqlR",
      "title": "Updates to blind signature extension draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/90",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We made significant progress on the core draft over the past couple of months, which is likely to have created some in-consistencies in how the blind sign draft maps onto it as an extension, this issue is just open to track this work and re-alignment.",
      "createdAt": "2022-03-28T21:32:13Z",
      "updatedAt": "2022-03-28T21:32:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 94,
      "id": "I_kwDOF8lax85HEYLC",
      "title": "Parameterise the bytes drawn from the XOF so they are defined by the cipher suite",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/94",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Throughout the operations defined by the spec there are numerous calls to the XOF where a certain number of bytes are read, via the .read() function. How many bytes are read is dependent on several decisions at the cipher suite level (e.g the curve used) hence the current \"magic numbers\" like 64 being used in these operations needs to be parameterised in the cipher suite definition.",
      "createdAt": "2022-04-04T21:23:27Z",
      "updatedAt": "2022-04-05T20:05:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This could be added as a simple ciphersuite parameter (a constant), or it could be defined generically.\r\n\r\nThe BLS signature draft uses `ceil((3 * ceil(log2(r))) / 16)` bytes (48 bytes for BLS12-381), while the draft currently uses 64 bytes. We could use the formula from the BLS signature draft or simply read `2n` bytes where `n` is the width of an encoded field element.",
          "createdAt": "2022-04-04T21:34:30Z",
          "updatedAt": "2022-04-04T21:34:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another option could be `ceil((r+k)/8)` where `k` the security level of the ciphersuite. So for bls it would be the same (48 bytes) but for bn462 would be 74 bytes instead of 87 (that it would if we used the `ceil((3 * ceil(log2(r))) / 16)` formula). `2n` will definitely be secure, but it may be too inefficient. It would be 64 bytes for bls and 116 for bn462 if I'm not mistaken.",
          "createdAt": "2022-04-05T19:40:37Z",
          "updatedAt": "2022-04-05T19:40:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "How about we leave it to the cipher suite to pick the exact value but have the above as a recommended way of calculating it?",
          "createdAt": "2022-04-05T19:42:27Z",
          "updatedAt": "2022-04-05T19:42:27Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1. Just instead of a recommendation i think we should have `ceil((r+k)/8)` (or `2n` etc) as the minimum value that a ciphersuite must choose though.",
          "createdAt": "2022-04-05T20:05:08Z",
          "updatedAt": "2022-04-05T20:05:08Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 9,
      "id": "PR_kwDOF8lax84s53qY",
      "title": "Add meeting details to README",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/9",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-07T16:52:48Z",
      "updatedAt": "2021-10-07T18:46:46Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8ef9959beab15364dd28e1816d8daa040164608d",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "add-meetings",
      "headRefOid": "83ca77c2b6f7cb9155e0b01cb689d41abf3c4642",
      "closedAt": "2021-10-07T18:46:46Z",
      "mergedAt": "2021-10-07T18:46:46Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "580bd262102859b1a06fb82c7089b60771e1a0de"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84uJnZd",
          "commit": {
            "abbreviatedOid": "83ca77c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-07T18:46:40Z",
          "updatedAt": "2021-10-07T18:46:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOF8lax84t5asa",
      "title": "Remove mention of specific of hash function",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/12",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "An attempt to start discussion around #8 in regards to the digest algorithm. \r\n\r\nAt a minimum I am interpreting from that issue we agree that our usage of a digest algorithm should be specified once and referenced throughout the draft. The outstanding issue is whether the draft should just provide guidance around recommended digest algorithms or adopt an approach more akin to EdDSA where a particular digest algorithm forms a core part of the signature specification (e.g implementers MUST use BLAKE2B or SHAKE256)",
      "createdAt": "2021-10-31T22:13:52Z",
      "updatedAt": "2021-11-15T18:28:25Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "580bd262102859b1a06fb82c7089b60771e1a0de",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/hash-function",
      "headRefOid": "7a6d70429d5eb7b9b718de909052ddbea4f6d6fc",
      "closedAt": "2021-11-15T18:28:01Z",
      "mergedAt": "2021-11-15T18:28:01Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9fc1ef136c2d437d59d11688a3fbaa1632421c75"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84vW2EV",
          "commit": {
            "abbreviatedOid": "7a6d704"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-01T18:26:04Z",
          "updatedAt": "2021-11-01T18:26:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOF8lax84t5bNx",
      "title": "move ecc signature comparission to appendix",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/13",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The comparing of bbs signatures to more traditional digital signature schemes like ECDSA is interesting informative content, but it is perhaps better discussed in the appendix rather than forming a core section in the draft, this PR proposes we move it accordingly.",
      "createdAt": "2021-10-31T22:27:06Z",
      "updatedAt": "2021-11-15T18:27:52Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "580bd262102859b1a06fb82c7089b60771e1a0de",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/remove-ecc-signatures-comparison",
      "headRefOid": "0bb0d372ed1cfabd9112eb8dd51d63a5f1e8ee43",
      "closedAt": "2021-11-15T18:27:45Z",
      "mergedAt": "2021-11-15T18:27:45Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9a9602526a0642ce4816ad472cb50d200eb1c76c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84vW1hZ",
          "commit": {
            "abbreviatedOid": "0bb0d37"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-01T18:23:39Z",
          "updatedAt": "2021-11-01T18:23:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOF8lax84u4XLB",
      "title": "Changes in the handling of reveled message indexes",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/14",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes in spkGen and spkVerify, in the direction discussed in the last WG call, of a more agile spec (aligned with option 1 from @tplooker's comment [here](https://github.com/decentralized-identity/bbs-signature/issues/10#issuecomment-939546272)). Specifically,\r\n\r\n1. Added a revealed message indexes vector in the input to spkVerify\r\n2. Added a recommendation for proof value encoding, similar to the one from ECDSA [RFC6979](https://datatracker.ietf.org/doc/html/rfc6979), with an additional preceding structure (taken from #10 , aligned with option 3 from the same [comment](https://github.com/decentralized-identity/bbs-signature/issues/10#issuecomment-939546272) as above).\r\n3. Changed some of the indexing in spkGen and spkVerify to accommodate the changes above",
      "createdAt": "2021-11-23T00:20:55Z",
      "updatedAt": "2021-12-13T19:14:29Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "91149814047a7c1fe11139bc787c2ea194efc5e0",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "revealed_msg_indices",
      "headRefOid": "f05fbb24d7e7d4de05c11b6989eab19b00ba8a36",
      "closedAt": "2021-12-13T19:14:29Z",
      "mergedAt": "2021-12-13T19:14:28Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "0914df5a07eb0cf3eff6b4629ec2e34fcd9cc48b"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done applying changes!",
          "createdAt": "2021-11-24T23:29:36Z",
          "updatedAt": "2021-11-24T23:29:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Waiting for discussion at next working group meeting to merge",
          "createdAt": "2021-11-28T19:30:11Z",
          "updatedAt": "2021-11-28T19:30:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84wmZY6",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-24T21:01:54Z",
          "updatedAt": "2021-11-24T21:01:54Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n- RIdxs, vector of unsigned integers (indices of revealed messages).\r\n```",
              "createdAt": "2021-11-24T21:01:54Z",
              "updatedAt": "2021-11-24T21:01:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84wmZqm",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-24T21:03:44Z",
          "updatedAt": "2021-11-24T21:03:44Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "```suggestion\r\nHow a signature is to be encoded is not covered by this document. (TODO perhaps add some additional information in the appendix)\r\n```",
              "createdAt": "2021-11-24T21:03:44Z",
              "updatedAt": "2021-11-24T21:03:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84wmZu4",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-24T21:04:11Z",
          "updatedAt": "2021-11-24T21:04:12Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "```suggestion\r\n- RIdxs, vector of unsigned integers (indices of revealed messages).\r\n```",
              "createdAt": "2021-11-24T21:04:11Z",
              "updatedAt": "2021-11-24T21:04:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84wmZ1a",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Looking good, suggested a few changes",
          "createdAt": "2021-11-24T21:04:45Z",
          "updatedAt": "2021-11-24T21:04:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84wpz6n",
          "commit": {
            "abbreviatedOid": "c2909a9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-25T19:40:29Z",
          "updatedAt": "2021-11-25T19:40:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84xgrN6",
          "commit": {
            "abbreviatedOid": "c2909a9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T19:13:37Z",
          "updatedAt": "2021-12-13T19:13:37Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "```suggestion\r\n13. Y2 = d \\* r3^ + h0 \\* s^ + h\\[i1\\] \\* m^\\[i1\\] + ... + h\\[iR\\] \\* m^\\[iR\\] - T2 \\* c\r\n```",
              "createdAt": "2021-12-13T19:13:37Z",
              "updatedAt": "2021-12-13T19:13:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOF8lax84vuKnC",
      "title": "Checks for the blind message generators and PoK during signing",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/17",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Related to #16.\r\n\r\n1. Added an explicit use of BlindMessageProofVerify in BlindSign to validate the PoK of committed messages, and a check that the generators used in the commitment are not also used for the known messages.\r\n2. Changed some of the notation to accommodate those changes above. The new notation can be also used more easily if we want to add support for blind signing with multiple commitments.",
      "createdAt": "2021-12-12T10:59:24Z",
      "updatedAt": "2022-01-24T19:12:06Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "commitment_generators_validation",
      "headRefOid": "243d31012ce2b436be31b0be4f54db1f64b18557",
      "closedAt": "2022-01-24T19:12:06Z",
      "mergedAt": "2022-01-24T19:12:05Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "bab36cced182c0a1122b543fb50cefb7078184f0"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call on 15th of dec @BasileiosKal has an action to make some changes requested by @andrewwhitehead and @mikelodder7 ",
          "createdAt": "2021-12-13T19:23:54Z",
          "updatedAt": "2021-12-13T19:23:54Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree and I updated this pr.  However, it does seem that a wider update to the spec may be needed.  It may also be useful to specify the domain parameters used by each function, similarly to the format from [here](https://www.ietf.org/archive/id/draft-irtf-cfrg-rsa-blind-signatures-02.html).<br/>\r\nIt also seems like [this ](https://github.com/decentralized-identity/bbs-signature/issues/19) issue (#19 ) will be relevant i.e., if we don't change the way the generators are created, it may be confusing to refer to them as domain parameters and have them be both issuer and number of messages specific. ",
          "createdAt": "2021-12-23T23:41:08Z",
          "updatedAt": "2021-12-23T23:43:11Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "Agreed. Perhaps we use the current spec as an example for creating the domain parameters. The point is they need to be distinct points whose discrete log is unknown ",
          "createdAt": "2021-12-23T23:44:43Z",
          "updatedAt": "2021-12-23T23:44:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #19, @andrewwhitehead to supply a review to this PR",
          "createdAt": "2022-01-10T19:39:59Z",
          "updatedAt": "2022-01-10T19:39:59Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think my only objections are around the variable naming. I have an issue open around that, and we can do another pass renaming things later.",
          "createdAt": "2022-01-24T18:10:15Z",
          "updatedAt": "2022-01-24T18:10:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 24th Jan, resolved to merge",
          "createdAt": "2022-01-24T19:12:00Z",
          "updatedAt": "2022-01-24T19:12:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84xdBbY",
          "commit": {
            "abbreviatedOid": "a13753d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T00:18:43Z",
          "updatedAt": "2021-12-13T00:18:44Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "When we say \"octet string\" here are we meaning a string with some form of defined encoding like hexadecimal or instead are we assuming any parameters that are binary in nature be supplied as byte array?",
              "createdAt": "2021-12-13T00:18:44Z",
              "updatedAt": "2021-12-13T00:18:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84xdBfH",
          "commit": {
            "abbreviatedOid": "a13753d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T00:20:14Z",
          "updatedAt": "2021-12-13T00:20:14Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Probably should define `ceil` in terminology also even though it probably obvious to most",
              "createdAt": "2021-12-13T00:20:14Z",
              "updatedAt": "2021-12-13T00:20:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84xdFUq",
          "commit": {
            "abbreviatedOid": "a13753d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T01:34:54Z",
          "updatedAt": "2021-12-13T01:34:54Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "My understanding is that currently by octet string we mean just a byte array with no specific encoding, mainly used to represent points in extension fields using the format described [here ](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-10) in [subsection 2.5](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-10#section-2.5), or for representing nonnegative integers using the conversions described [here](https://www.rfc-editor.org/rfc/rfc8017.txt) at section 4.",
              "createdAt": "2021-12-13T01:34:54Z",
              "updatedAt": "2021-12-13T01:34:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yCdmc",
          "commit": {
            "abbreviatedOid": "5120485"
          },
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "The part about the key being 48 * (messages +1) isn\u2019t always accurate. I would like to rename these generators to domain parameters as this is the more common with cryptography. That means the public key has a fixed size of 96 bytes. \r\n\r\nThe reason for the distinction is the domain parameters have no secret meaning vs a public key indicates a secret key behind it",
          "createdAt": "2021-12-23T17:00:40Z",
          "updatedAt": "2021-12-23T17:00:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zWAYB",
          "commit": {
            "abbreviatedOid": "243d310"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-24T19:11:27Z",
          "updatedAt": "2022-01-24T19:11:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOF8lax84vuhiv",
      "title": "Blind Sign Flow Example",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/18",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An example for the flow by which the Holder gets a signature with committed messages. The holder commits U messages using the first U generators from the Issuers PK.",
      "createdAt": "2021-12-12T20:06:51Z",
      "updatedAt": "2021-12-21T20:31:40Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "0914df5a07eb0cf3eff6b4629ec2e34fcd9cc48b",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "blind_sign_example",
      "headRefOid": "3695dee5e2f4d6b0a3c8fe934ec404913c0c2a2c",
      "closedAt": "2021-12-21T20:31:40Z",
      "mergedAt": "2021-12-21T20:31:40Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Informational and in the appendix, no objections on last working group call, merging.",
          "createdAt": "2021-12-21T20:31:35Z",
          "updatedAt": "2021-12-21T20:31:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84xgt51",
          "commit": {
            "abbreviatedOid": "35d9d99"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T19:25:20Z",
          "updatedAt": "2021-12-13T19:25:21Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n|        | <-(1)------- nonce ---------- |        |\r\n```",
              "createdAt": "2021-12-13T19:25:20Z",
              "updatedAt": "2021-12-13T19:25:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOF8lax84wvGmp",
      "title": "Clarified presentation message requirements",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/21",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarified usage of nonce when use in a non-interactive protocol.",
      "createdAt": "2022-01-10T14:03:36Z",
      "updatedAt": "2022-02-07T19:53:42Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "845bf8ad9e9f5eba34f58b579352b775d5011d11",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "nonce-issue-15",
      "headRefOid": "af8fb5542b234ee68c838117d946c2128ef90812",
      "closedAt": "2022-02-07T19:53:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addresses issue #15 ",
          "createdAt": "2022-01-10T19:40:49Z",
          "updatedAt": "2022-01-10T19:40:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on Jan 10th WG call, resolved to merge after 1 day if no further objection or feedback.",
          "createdAt": "2022-01-10T19:45:51Z",
          "updatedAt": "2022-01-10T19:45:51Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure the text `BBS signatures are nondeterministic` is still true depending how the nonces are chosen. It also might be good to refer to `e` and `s` specifically in the context of nonce selection (at least I think those are the relevant nonces?). I'm not sure why a signed document would include a ZKP of a signature rather than the signature itself but maybe there's a use for that.",
          "createdAt": "2022-01-10T22:42:17Z",
          "updatedAt": "2022-01-10T22:42:17Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, I also can't imagine how blinded signatures would be used in a non-interactive or deterministic context.",
          "createdAt": "2022-01-10T23:14:04Z",
          "updatedAt": "2022-01-10T23:14:04Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">I'm not sure why a signed document would include a ZKP of a signature rather than the signature itself but maybe there's a use for that.\r\n\r\nThe use case I referred [here](https://github.com/decentralized-identity/bbs-signature/issues/15#issuecomment-978239178) if you want to sign a statement without identifying yourself, think role-based signature similar to role-based access. A BBS+ cred owner could sign a statement, disclosing some attributes attested by a trusted issuer.\r\n",
          "createdAt": "2022-01-11T14:37:52Z",
          "updatedAt": "2022-01-11T14:37:52Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I also can't imagine how blinded signatures would be used in a non-interactive or deterministic context.\r\n\r\nOne scenario that dates way back to Chaum's credential days was toll booths, where passing cars could present a payment by signing a booth ID + timestamp. Prover just broadcasts the proof to get access to a resource, using a (verifier ID + timestamp + small random value) as the nonce. Verifiers can prevent replays by keeping a local cache of used nonces (deleting as the timestamps get too old).",
          "createdAt": "2022-01-11T14:53:13Z",
          "updatedAt": "2022-01-11T14:53:13Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead any concrete proposal that could be suggested here to move this PR along?",
          "createdAt": "2022-01-24T03:26:57Z",
          "updatedAt": "2022-01-24T03:26:57Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Comments from the Jan 24th meeting: yes, the nonce terminology contradicts the deterministic use cases. Perhaps renaming it to something more neutral would help generalize the supported scenarios. In U-Prove, e.g., the `nonce` was called `presentation message`, which could be a nonce (for interactive scenarios), a verifierID+timestamp for user-initiated non-interactive scenarios, or static content for digital signature use cases.",
          "createdAt": "2022-01-24T19:35:25Z",
          "updatedAt": "2022-01-24T19:35:25Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "> Comments from the Jan 24th meeting: yes, the nonce terminology contradicts the deterministic use cases. Perhaps renaming it to something more neutral would help generalize the supported scenarios. In U-Prove, e.g., the `nonce` was called `presentation message`, which could be a nonce (for interactive scenarios), a verifierID+timestamp for user-initiated non-interactive scenarios, or static content for digital signature use cases.\r\n\r\nI think that's a good description of an application of a nonce, when it's used in a deterministic scenario, but not general enough. `Challenge` may be used when interaction is needed in a non-deterministic manner. A `nonce` can then become a `presentation message`, a `challenge`, or even a `pin` to be more specific. This makes me think that `nonce` is indeed a good way that's general enough to refer to this input.",
          "createdAt": "2022-01-24T21:48:16Z",
          "updatedAt": "2022-01-24T21:48:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@christianpaquin apologies but we have renamed the spec file name so we leverage existing tooling around managing ID drafts, can you please rebase your PR accordingly?",
          "createdAt": "2022-01-26T00:51:50Z",
          "updatedAt": "2022-01-26T00:51:50Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the PR, merging with latest changes on main, and removing some mentions of potential use cases causing confusion.  \r\n\r\nThe main use case I have in mind for BBS+ signature is to build anonymous credentials, where the holder is not only given certified attributes, but also holds a private key (in one of the never-disclosed attributes, like in U-Prove and Idemix). Since BBS+ can, in its generalization, be used to encode key-less, bearer-only signatures on arbitrary messages, the previous \"signing the nonce\" text was confusing, so I removed it for now.\r\n\r\nThis being said, where should we specify such a use for BBS+ signature? Should that be a totally different spec (similar to CL sig vs. Idemix?) or a simpler profile?",
          "createdAt": "2022-01-27T22:52:56Z",
          "updatedAt": "2022-01-27T22:52:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> This being said, where should we specify such a use for BBS+ signature? Should that be a totally different spec (similar to CL sig vs. Idemix?) or a simpler profile?\r\n\r\nJust so I can clarify when you say a more opinionated signature scheme what do you mean exactly, one that features holder cryptographic binding or something else?",
          "createdAt": "2022-01-28T00:16:26Z",
          "updatedAt": "2022-01-28T00:16:26Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "how many days with approval before merge for this work item?",
          "createdAt": "2022-01-31T21:47:31Z",
          "updatedAt": "2022-01-31T21:47:31Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Resolved to merge on WG call 7th of Feb, awaiting conflict resolution ",
          "createdAt": "2022-02-07T19:11:22Z",
          "updatedAt": "2022-02-07T19:11:22Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Conflict merge resolution is very confused on my system, so closing this and opening new, cleaner PR #55.",
          "createdAt": "2022-02-07T19:53:42Z",
          "updatedAt": "2022-02-07T19:53:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84yj4t4",
          "commit": {
            "abbreviatedOid": "d23c300"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-10T19:45:02Z",
          "updatedAt": "2022-01-10T19:45:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zWi6J",
          "commit": {
            "abbreviatedOid": "d23c300"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T21:41:35Z",
          "updatedAt": "2022-01-24T21:41:36Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "While I share the idea that there are very good use cases where deterministic nonce can be used here, I think they make more sense in higher level protocols. Especially, since the wording used here may incorrectly guide implementors to adopt timestamp for a nonce.\r\nI think a shorter guidance describing that this parameter be unique, and random enough would be more appropriate.\r\n\r\nSpecific implementations may still make a conscious choice to use deterministic value where security or risk impact tolerates this. For example: attendees at a conference can prepare a proof by using the room number for a conference where both verifier and presenter know this nonce and require no interaction, thus simplifying the verification experience.",
              "createdAt": "2022-01-24T21:41:36Z",
              "updatedAt": "2022-01-24T21:41:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zWjfl",
          "commit": {
            "abbreviatedOid": "d23c300"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T21:44:15Z",
          "updatedAt": "2022-01-24T21:44:15Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't know what standard in cryptography is used to reference to good randomness. Maybe [this RFC](https://datatracker.ietf.org/doc/html/rfc4086) may be more appropriate to quote here?",
              "createdAt": "2022-01-24T21:44:15Z",
              "updatedAt": "2022-01-24T21:44:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlt6R",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T22:54:09Z",
          "updatedAt": "2022-01-27T22:54:09Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Agreed that we need clearer usage \"profiles\" to scope the implementation choices. Really interested in defining these.",
              "createdAt": "2022-01-27T22:54:09Z",
              "updatedAt": "2022-01-27T22:54:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zl5wY",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T00:18:00Z",
          "updatedAt": "2022-01-28T00:18:01Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I think somewhere we need to relate the concept of a nonce to a presentation message, is here the most appropriate place to do that?",
              "createdAt": "2022-01-28T00:18:01Z",
              "updatedAt": "2022-01-28T00:18:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zl8Jf",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T00:38:45Z",
          "updatedAt": "2022-01-28T00:38:46Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Given that we now no longer formally have the concept of a nonce in the draft itself",
              "createdAt": "2022-01-28T00:38:45Z",
              "updatedAt": "2022-01-28T00:38:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zmQI1",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T03:38:29Z",
          "updatedAt": "2022-01-28T03:38:29Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "> Just so I can clarify when you say a more opinionated signature scheme what do you mean exactly, one that features holder cryptographic binding or something else?\r\n\r\nYes, at a minimum. This could be achieved (I think) by making one of messages the \"private key\" and you shouldn't reveal it. I've seen in another thread someone proposing tying it to the BLS key (?), I need to look into the details of that...",
              "createdAt": "2022-01-28T03:38:29Z",
              "updatedAt": "2022-01-28T03:38:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zmQUL",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T03:40:47Z",
          "updatedAt": "2022-01-28T03:40:47Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "> I think somewhere we need to relate the concept of a nonce to a presentation message, is here the most appropriate place to do that?\r\n\r\nAh yes, didn't realized that changed already when I merged. I definitely need to update that section to reflect that.",
              "createdAt": "2022-01-28T03:40:47Z",
              "updatedAt": "2022-01-28T03:40:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zqbRU",
          "commit": {
            "abbreviatedOid": "9cdad00"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T22:19:37Z",
          "updatedAt": "2022-01-28T22:19:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Updated",
              "createdAt": "2022-01-28T22:19:37Z",
              "updatedAt": "2022-01-28T22:19:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zqe6n",
          "commit": {
            "abbreviatedOid": "9cdad00"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T22:47:04Z",
          "updatedAt": "2022-01-28T22:47:04Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nThe signature proofs of knowledge generated in this specification are created using a specified presentation message. A verifier-specified cryptographically random value (e.g., a nonce) featuring in the presentation message provides strong protections against replay attacks, and is RECOMMENDED in most use cases. In some settings, proofs can be generated in a non-interactive fashion, in which case verifiers MUST be able to verify the uniqueness of the presentation message values.\r\n```",
              "createdAt": "2022-01-28T22:47:04Z",
              "updatedAt": "2022-01-28T22:47:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zw4-J",
          "commit": {
            "abbreviatedOid": "af8fb55"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T21:47:08Z",
          "updatedAt": "2022-01-31T21:47:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOF8lax84wv9WU",
      "title": "Add various comments as FIXMEs",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/22",
      "state": "MERGED",
      "author": "schanzen",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Related to #7 and #8\r\n\r\nDid a pass of the document and was wondering to what degree it is supposed to be normative. If it is **not** supposed to be, it should be made clear(er) what the diff over the respective papers (informative references to those missing) is.\r\nAlso, normative references (such as those to the HKDF) are not required then.\r\n\r\nIf it is supposed to be normative, it requires the definition of (at least) one concrete instantiation (with hash functions/curves) and normative test vectors and wire formats.\r\n\r\nOnce we can clarify those points I can replace the FIXMEs aligning with the target.",
      "createdAt": "2022-01-10T17:50:51Z",
      "updatedAt": "2022-01-25T22:56:11Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e",
      "headRepository": "schanzen/bbs-signature",
      "headRefName": "comments",
      "headRefOid": "70c145526d995440b5d876eeedbb537bf85e51da",
      "closedAt": "2022-01-25T22:56:11Z",
      "mergedAt": "2022-01-25T22:56:11Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "56d413acd3d43588c93964ba3f38d88a094a220d"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Purely editorial changes, multiple approvals, discussed on WG, merging, thanks @schanzen ",
          "createdAt": "2022-01-25T22:56:07Z",
          "updatedAt": "2022-01-25T22:56:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84ykm-4",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T23:23:57Z",
          "updatedAt": "2022-01-10T23:23:57Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think those 680 and 1400 numbers are also in microseconds not milliseconds?",
              "createdAt": "2022-01-10T23:23:57Z",
              "updatedAt": "2022-01-10T23:23:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykoYi",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T23:34:23Z",
          "updatedAt": "2022-01-10T23:34:24Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Why does it need justification?",
              "createdAt": "2022-01-10T23:34:24Z",
              "updatedAt": "2022-01-10T23:34:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykocK",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T23:34:49Z",
          "updatedAt": "2022-01-10T23:34:49Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Same here, not sure what the suggested change would be.",
              "createdAt": "2022-01-10T23:34:49Z",
              "updatedAt": "2022-01-10T23:34:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yl99T",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:23:31Z",
          "updatedAt": "2022-01-11T08:23:31Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Because above it it says \"The scheme features many important properties:\"\r\nIt is unclear why this generic property is important.\r\nI changed this sentence above in the pull request already.\r\nIf this is just a general note then it is not an important property of the scheme I think.",
              "createdAt": "2022-01-11T08:23:31Z",
              "updatedAt": "2022-01-11T08:23:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yl_T5",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:25:55Z",
          "updatedAt": "2022-01-11T08:25:55Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "It also kind of implies that there is space time tradeoff and that BBS can sign any number of messages in 680/1400ms. So maybe the 3.7 and 5.4 actually refer to ECDSA. Not sure.",
              "createdAt": "2022-01-11T08:25:55Z",
              "updatedAt": "2022-01-11T08:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ymA6S",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:31:11Z",
          "updatedAt": "2022-01-11T08:31:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Well let me rephrase it using the words from the (original) text:\r\nHow is \"Verification requires 2 pairing operations.\" a \"[property that] allow[s] the scheme to be used in applications where privacy and data minimization techniques are desired and/or required.\"?\r\nThat is what the text currently says, and it is unclear (to me) where the connection is.",
              "createdAt": "2022-01-11T08:31:11Z",
              "updatedAt": "2022-01-11T08:31:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ymBz2",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:34:53Z",
          "updatedAt": "2022-01-11T08:34:54Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Also, the \"encoding\" of the signature would usually refer to a normative (interoperable) wire format of the signature. Maybe what is meant here is that the signatures are \"represented\" as a single group element and two field elements?\r\nLater in the text it is also stated that \"How a signature is to be encoded is not covered by this document. (TODO perhaps add some additional information in the appendix)\"",
              "createdAt": "2022-01-11T08:34:53Z",
              "updatedAt": "2022-01-11T08:35:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yu6b3",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T01:16:04Z",
          "updatedAt": "2022-01-13T01:16:04Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "@mikelodder7 I think you originally wrote this could you clarify, IMO this section can likely be removed from the spec as it is entirely non-normative.",
              "createdAt": "2022-01-13T01:16:04Z",
              "updatedAt": "2022-01-13T01:16:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yu6jN",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T01:17:10Z",
          "updatedAt": "2022-01-13T01:17:11Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I think I agree with your comment here but could you clarify what you mean by \"wire format\" specifically and what you would take as the definition of encoding format?",
              "createdAt": "2022-01-13T01:17:10Z",
              "updatedAt": "2022-01-13T01:17:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yu6mI",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T01:17:35Z",
          "updatedAt": "2022-01-13T01:17:35Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "If it is a duplicate then I think we should just remove it",
              "createdAt": "2022-01-13T01:17:35Z",
              "updatedAt": "2022-01-13T01:17:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yvD8o",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T02:41:09Z",
          "updatedAt": "2022-01-13T02:41:09Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Sure feel free to remove it.",
              "createdAt": "2022-01-13T02:41:09Z",
              "updatedAt": "2022-01-13T02:41:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yvxZ_",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T08:23:04Z",
          "updatedAt": "2022-01-13T08:23:05Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "As an implementer I would expect qualifiers such as \"32 octets\" or \"variable length\" (with a length field) for the members of the tuple and then a normative ordering of them (for example by having a wire format graphic or a concatenation of the octet strings).\r\nThe point is that when I eventually code my structs, I need to know the size of its members and their location.\r\nOtherwise I do not even know how to parse a test vector (if provided).\r\nThis unclarity may have to do with #8 which makes normative statements more difficult to incorporate.",
              "createdAt": "2022-01-13T08:23:04Z",
              "updatedAt": "2022-01-13T08:23:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84y9G62",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-18T01:55:26Z",
          "updatedAt": "2022-01-18T01:55:26Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Yeah I think this is covered by issue #2 and we should aim to review it on the next working group call to provide better clarity around the direction the WG would like to take this",
              "createdAt": "2022-01-18T01:55:26Z",
              "updatedAt": "2022-01-18T01:55:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSWwH",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:29:11Z",
          "updatedAt": "2022-01-24T03:29:12Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "@schanzen, could you update your PR to just remove this section entirely from the appendix?",
              "createdAt": "2022-01-24T03:29:12Z",
              "updatedAt": "2022-01-24T03:29:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSW4N",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:30:46Z",
          "updatedAt": "2022-01-24T03:30:47Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Have reviewed, @schanzen can you remove the duplicate language around SK, then we can resolve this FIX me",
              "createdAt": "2022-01-24T03:30:46Z",
              "updatedAt": "2022-01-24T03:30:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSXAF",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:32:17Z",
          "updatedAt": "2022-01-24T03:32:17Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "+1 reading the context it does not appear apparent why this needs to be bulleted as it is, I would vote to remove it.",
              "createdAt": "2022-01-24T03:32:17Z",
              "updatedAt": "2022-01-24T03:32:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSXDG",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:32:51Z",
          "updatedAt": "2022-01-24T03:32:51Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "+1 as above I think this should be removed also",
              "createdAt": "2022-01-24T03:32:51Z",
              "updatedAt": "2022-01-24T03:32:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zb0yS",
          "commit": {
            "abbreviatedOid": "70c1455"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-25T22:23:57Z",
          "updatedAt": "2022-01-25T22:23:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zb7fj",
          "commit": {
            "abbreviatedOid": "70c1455"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-25T22:55:43Z",
          "updatedAt": "2022-01-25T22:55:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOF8lax84wwBeS",
      "title": "Check the hash for the challenge of the Fiat-Shamir heuristic",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/23",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Attempts to fix #20\r\n\r\nChanges: \r\n\r\n1. SpkGen returns the computed challenge for Fiat-Shamir.\r\n2. SpkVerify checks that the challenge is correct.",
      "createdAt": "2022-01-10T18:13:34Z",
      "updatedAt": "2022-02-16T00:49:50Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "535d98143d46e10d2c358f76bb985e2c530d018a",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "issue20-fix",
      "headRefOid": "b3073be5a2bad2ddf6a579b23e8a0b275eab2af3",
      "closedAt": "2022-02-16T00:49:50Z",
      "mergedAt": "2022-02-16T00:49:50Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "82155a81bcbaf86c898851d2c07d83a4c98f963d"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call Jan 10th, waiting on a review from @mikelodder7 as the underlying issue was raised by him. ",
          "createdAt": "2022-01-10T19:53:34Z",
          "updatedAt": "2022-01-10T19:53:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal apologies but we have renamed the spec file name so we leverage existing tooling around managing ID drafts, can you please rebase your PR accordingly?",
          "createdAt": "2022-01-26T00:58:17Z",
          "updatedAt": "2022-01-26T00:58:17Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 7th Feb, awaiting review from @mikelodder7 for progress",
          "createdAt": "2022-02-07T19:13:22Z",
          "updatedAt": "2022-02-07T19:13:22Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would likely be more efficient to check the challenge hash before doing the pairing operations, in case that fails.",
          "createdAt": "2022-02-07T19:15:55Z",
          "updatedAt": "2022-02-07T19:15:55Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure it could be. I don\u2019t have a preference ",
          "createdAt": "2022-02-07T19:20:21Z",
          "updatedAt": "2022-02-07T19:20:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "updated",
          "createdAt": "2022-02-07T20:10:40Z",
          "updatedAt": "2022-02-07T20:10:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you review these latest changes please",
          "createdAt": "2022-02-12T23:02:09Z",
          "updatedAt": "2022-02-12T23:02:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "PR open for multiple weeks, discussed on WG call multiple times, multiple approvals, merging.",
          "createdAt": "2022-02-16T00:49:37Z",
          "updatedAt": "2022-02-16T00:49:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84yj6_q",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T19:55:16Z",
          "updatedAt": "2022-01-10T19:55:18Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "These steps are not necessary since they should be handled by the challenge hash.",
              "createdAt": "2022-01-10T19:55:17Z",
              "updatedAt": "2022-01-10T19:55:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yj7DV",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T19:55:34Z",
          "updatedAt": "2022-01-10T19:55:35Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I.E 11-16 are not necessary",
              "createdAt": "2022-01-10T19:55:34Z",
              "updatedAt": "2022-01-10T19:55:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yj7R3",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T19:56:38Z",
          "updatedAt": "2022-01-10T19:56:38Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "See https://hackmd.io/Q587Q9p7T5ab30NTn4MvTA#Change-selective-disclosure-proofs-to-just-be-Schnorr-Proofs-and-Fiat-Shamir",
              "createdAt": "2022-01-10T19:56:38Z",
              "updatedAt": "2022-01-10T19:56:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykFGm",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:42:52Z",
          "updatedAt": "2022-01-10T20:42:52Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Thank you for the link. It is very interesting. Perhaps I will have to think more about it but it seems to me that some of the steps are needed. If we change the hash calculated at step 9 here to contain Y1 and Y2 instead of C1 and C2 (and of course to be calculated in a later step), perhaps we could remove the checks at steps 15 and 16, and consequently remove C1 and C2 from the spk returned from SpkGen. However, steps 10 to 14 don't seem to me that we could remove them, they are an integral part of the Schnorr proof after all.",
              "createdAt": "2022-01-10T20:42:52Z",
              "updatedAt": "2022-01-10T20:42:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykFrQ",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:45:25Z",
          "updatedAt": "2022-01-10T20:45:26Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "The problem is it\u2019s being calculated twice. Once for the hash and then again checked for equality which is why I said in my write up they can be removed",
              "createdAt": "2022-01-10T20:45:26Z",
              "updatedAt": "2022-01-10T20:45:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykFvs",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:45:46Z",
          "updatedAt": "2022-01-10T20:45:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "If the values are different, the hash will be too. ",
              "createdAt": "2022-01-10T20:45:46Z",
              "updatedAt": "2022-01-10T20:45:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zw5hG",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "There is an implied change request by @mikelodder7 and there are conflicts that need to be addressed.",
          "createdAt": "2022-01-31T21:49:38Z",
          "updatedAt": "2022-01-31T21:49:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840eoqu",
          "commit": {
            "abbreviatedOid": "1a27339"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-11T17:00:19Z",
          "updatedAt": "2022-02-11T17:00:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840rfER",
          "commit": {
            "abbreviatedOid": "b3073be"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Having had the chance to review this PR more closely now, I agree with this approach and how it is algorithmically described. It is consistent with @mikelodder7's original issue described in #20. The PR does appear to have some overlap with #62, however on balance I think the scope of this PR makes it easier to review and merge in first.",
          "createdAt": "2022-02-16T00:48:50Z",
          "updatedAt": "2022-02-16T00:48:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOF8lax84xlpRj",
      "title": "Add ID tooling, remove redundant scripts",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/32",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- Add basic tooling for managing this spec as an ID draft based on https://github.com/martinthomson/internet-draft-template.\r\n- Removes some redundant scripts for old tooling.\r\n- Removes old HTML version.\r\n- Minor tweaks to draft naming based on #30 \r\n",
      "createdAt": "2022-01-25T23:22:30Z",
      "updatedAt": "2022-01-26T00:22:23Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "56d413acd3d43588c93964ba3f38d88a094a220d",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/id-tooling-setup",
      "headRefOid": "72f9be671202019daa497969f02efa049266e901",
      "closedAt": "2022-01-26T00:22:20Z",
      "mergedAt": "2022-01-26T00:22:20Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "e77c5ce55cad7274c1c3d35850023205edc702b9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Merging PR so we can get spec hosting working correctly, no substantive changes to the spec text.",
          "createdAt": "2022-01-26T00:22:15Z",
          "updatedAt": "2022-01-26T00:22:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zcDqD",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:55:26Z",
          "updatedAt": "2022-01-25T23:55:26Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "remove comments?",
              "createdAt": "2022-01-25T23:55:26Z",
              "updatedAt": "2022-01-25T23:55:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcD-b",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:58:00Z",
          "updatedAt": "2022-01-25T23:58:00Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Looks like you are no longer using markdown2rfc.... I had to bump the version recently... https://github.com/OR13/markdown2rfc\r\n\r\nI wanted to render latex equations as svgs... ",
              "createdAt": "2022-01-25T23:58:00Z",
              "updatedAt": "2022-01-25T23:58:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcEDT",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:58:43Z",
          "updatedAt": "2022-01-25T23:58:44Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "I love the idea of github handling this all for you tho, i would still probably want to test it locally.... consider adding some instructions to the readme to help with that? and adding the built assets to git ignore?",
              "createdAt": "2022-01-25T23:58:43Z",
              "updatedAt": "2022-01-25T23:59:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcFie",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:10:32Z",
          "updatedAt": "2022-01-26T00:10:32Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "It just describes how the tool is run copied directly from the template (https://github.com/martinthomson/internet-draft-template/blob/main/.github/workflows/update.yml#L2)",
              "createdAt": "2022-01-26T00:10:32Z",
              "updatedAt": "2022-01-26T00:10:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcFo8",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:11:26Z",
          "updatedAt": "2022-01-26T00:11:28Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Yeah I have seen some other repos that include the ability to do this locally to preview changes in final output form, was going to tackle in a follow up PR",
              "createdAt": "2022-01-26T00:11:27Z",
              "updatedAt": "2022-01-26T00:11:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcGTB",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:17:20Z",
          "updatedAt": "2022-01-26T00:17:20Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Have updated this workflow file essentially it is designed to be run once then deletes it self, just sets up tooling around the draft publication",
              "createdAt": "2022-01-26T00:17:20Z",
              "updatedAt": "2022-01-26T00:17:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcGWE",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:17:43Z",
          "updatedAt": "2022-01-26T00:17:43Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Note as above this workflow is just designed to be run once also",
              "createdAt": "2022-01-26T00:17:43Z",
              "updatedAt": "2022-01-26T00:17:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 35,
      "id": "PR_kwDOF8lax84xmKrD",
      "title": "Remove deterministic public key section from the spec",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/35",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Regardless of the outcome of #19 most in the group appear to agree that generators should always be considered an internal cryptographic structure instead of one that forces API consumers to manage externally, with that in mind we can remove any mention of deterministic public keys vs short form public keys and instead simplify to have only 1 type.\r\n\r\nFixes #26 ",
      "createdAt": "2022-01-26T04:49:12Z",
      "updatedAt": "2022-01-27T18:40:50Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "b49728ecb6ec3166ed095151a056869f8a3019f0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/remove-deterministic-public-key",
      "headRefOid": "bb79edaccb75da28a3fb006db3435b7f286067e2",
      "closedAt": "2022-01-27T18:40:47Z",
      "mergedAt": "2022-01-27T18:40:46Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ab16db1e228211dc88763060c0013cd70a26df92"
      },
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "`PK` has two generation paths with equivalent output. What happens with `PK` generation when `SK` isn't available, e.g. by a verifier?",
          "createdAt": "2022-01-26T15:43:44Z",
          "updatedAt": "2022-01-26T15:43:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@tmarkovski can you clarify when SK is not available what other option there is to generate PK?",
          "createdAt": "2022-01-26T21:59:41Z",
          "updatedAt": "2022-01-26T21:59:41Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "I misunderstood the initial intent. You're basically suggesting we turn DPK into PK, and hide the generator construction internal the implementation, since these keys don't need to managed externally anyway.",
          "createdAt": "2022-01-26T22:29:33Z",
          "updatedAt": "2022-01-26T22:29:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zgngW",
          "commit": {
            "abbreviatedOid": "bb79eda"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-26T22:37:20Z",
          "updatedAt": "2022-01-26T22:37:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zhCa8",
          "commit": {
            "abbreviatedOid": "bb79eda"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T01:53:59Z",
          "updatedAt": "2022-01-27T01:53:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOF8lax84xmrdL",
      "title": "Rename nonce to presentation message",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/36",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Implements the suggestion documented in issue #33 ",
      "createdAt": "2022-01-26T09:09:20Z",
      "updatedAt": "2022-01-28T00:37:45Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "1552d1b52c0feeb729b7b16640ce0be8a5e24cc4",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/nonce-presentation-message",
      "headRefOid": "e547196281bf67053153b3620fec5504e85a6dd2",
      "closedAt": "2022-01-28T00:37:41Z",
      "mergedAt": "2022-01-28T00:37:41Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "845bf8ad9e9f5eba34f58b579352b775d5011d11"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "PR opened multiple days, discussion was briefly had on last working group call also, multiple approvals, merging",
          "createdAt": "2022-01-28T00:37:36Z",
          "updatedAt": "2022-01-28T00:37:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zg7dt",
          "commit": {
            "abbreviatedOid": "28b0aaa"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T00:55:46Z",
          "updatedAt": "2022-01-27T00:55:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zk3WW",
          "commit": {
            "abbreviatedOid": "0299d68"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T18:54:33Z",
          "updatedAt": "2022-01-27T18:54:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I wouldn't say the PM is protected by the SPK, but it serves to tie the SPK to a specific context, ie. the current session between the prover and verifier.",
              "createdAt": "2022-01-27T18:54:33Z",
              "updatedAt": "2022-01-27T18:54:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlCp_",
          "commit": {
            "abbreviatedOid": "0299d68"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T19:41:18Z",
          "updatedAt": "2022-01-27T19:45:13Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Wouldn't we also need a nonce here to avoid replay? Or is the intention to use PM as the nonce when necessary?",
              "createdAt": "2022-01-27T19:41:18Z",
              "updatedAt": "2022-01-27T19:45:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlEwP",
          "commit": {
            "abbreviatedOid": "0299d68"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T19:50:01Z",
          "updatedAt": "2022-01-27T19:50:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n: A message generated and protected by the spk.\r\n```",
              "createdAt": "2022-01-27T19:50:02Z",
              "updatedAt": "2022-01-27T19:50:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlFeV",
          "commit": {
            "abbreviatedOid": "0299d68"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T19:53:02Z",
          "updatedAt": "2022-01-27T19:53:03Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The PM is in reality an arbitrary data structure that includes multiple pieces information such as a nonce, the guidance for this I think is best addressed through a revision to @christianpaquin PR #21.",
              "createdAt": "2022-01-27T19:53:02Z",
              "updatedAt": "2022-01-27T19:53:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlfSt",
          "commit": {
            "abbreviatedOid": "31dc82c"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T21:46:59Z",
          "updatedAt": "2022-01-27T21:46:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zl7kl",
          "commit": {
            "abbreviatedOid": "31dc82c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T00:33:32Z",
          "updatedAt": "2022-01-28T00:33:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n: A message generated and bound to the context of a specific spk.\r\n```",
              "createdAt": "2022-01-28T00:33:32Z",
              "updatedAt": "2022-01-28T00:33:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zl7ry",
          "commit": {
            "abbreviatedOid": "e547196"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-28T00:34:31Z",
          "updatedAt": "2022-01-28T00:34:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOF8lax84xx7lC",
      "title": "Generator demo",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/41",
      "state": "MERGED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a demo of how the BBS+ message generators can be created in Rust.",
      "createdAt": "2022-01-29T17:09:56Z",
      "updatedAt": "2022-01-29T21:39:24Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "845bf8ad9e9f5eba34f58b579352b775d5011d11",
      "headRepository": "mikelodder7/bbs-signature",
      "headRefName": "main",
      "headRefOid": "cc88bbda82a27cd3c7ef63cc769c38f6b73bf420",
      "closedAt": "2022-01-29T21:39:24Z",
      "mergedAt": "2022-01-29T21:39:24Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "b1d33726979e6660bbf68dd9f42039137729ca06"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks Mike, this is a great foundation, I'll merge this and do a small amount of re-organising so we have space for other tooling in future",
          "createdAt": "2022-01-29T21:39:18Z",
          "updatedAt": "2022-01-29T21:39:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zrY3E",
          "commit": {
            "abbreviatedOid": "cc88bbd"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-29T21:38:13Z",
          "updatedAt": "2022-01-29T21:38:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOF8lax84xzVK_",
      "title": "Split out blind sign functionality into a seperate draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/42",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Following discussion in the working group chat and conversation in issues #29 and #28. This PR attempts to move this forward by splitting the current draft into two:\r\n\r\n1. Core Draft - Responsible for defining the core BBS Signature Scheme operations sign, verify, spkgen and spkverify\r\n2. Extension Draft - Responsible for defining the blind sign functionality",
      "createdAt": "2022-01-30T23:03:27Z",
      "updatedAt": "2022-02-01T20:20:00Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "38f9001f0202b8481c6f22ec5e59a6e93a3ea1cf",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/split-draft",
      "headRefOid": "8e6742c2a0c794c0f4586fac4c6bef3dd6831439",
      "closedAt": "2022-02-01T20:19:58Z",
      "mergedAt": "2022-02-01T20:19:57Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2be94728d0fb5e2a281afe2881a7b49cf6e1b9d0"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, open multiple days, discussed on previous working group call and in #28, no net change in functionality just splitting it across two documents can re-merge later if required, merging.",
          "createdAt": "2022-02-01T20:19:48Z",
          "updatedAt": "2022-02-01T20:19:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zw5vu",
          "commit": {
            "abbreviatedOid": "359a9b1"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "strong +1 to splitting this... hopefully it can proceed faster.",
          "createdAt": "2022-01-31T21:50:40Z",
          "updatedAt": "2022-01-31T21:50:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zw_fJ",
          "commit": {
            "abbreviatedOid": "359a9b1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T22:16:35Z",
          "updatedAt": "2022-01-31T22:16:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84z1JAW",
          "commit": {
            "abbreviatedOid": "359a9b1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T17:55:10Z",
          "updatedAt": "2022-02-01T17:55:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This could probably be restructured since there's only 1 point.",
              "createdAt": "2022-02-01T17:55:10Z",
              "updatedAt": "2022-02-01T17:55:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z178U",
          "commit": {
            "abbreviatedOid": "fdaee11"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T20:12:43Z",
          "updatedAt": "2022-02-01T20:12:43Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Have restructured now thanks @andrewwhitehead ",
              "createdAt": "2022-02-01T20:12:43Z",
              "updatedAt": "2022-02-01T20:12:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z1884",
          "commit": {
            "abbreviatedOid": "8e6742c"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T20:17:01Z",
          "updatedAt": "2022-02-01T20:17:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOF8lax84x0LvY",
      "title": "Add basic usecases section",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/44",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This PR is the start of some documentation around possible usecases for the BBS scheme. Unsure about where it should live or the style these should be written in.",
      "createdAt": "2022-01-31T05:37:14Z",
      "updatedAt": "2022-02-01T20:12:21Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "ceae7fde0b9d557d2778a92dead371ecc7a241f5",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/use-cases",
      "headRefOid": "92e8bc040d6242866fb3a068afdb4f50b4ff19a5",
      "closedAt": "2022-02-01T20:12:18Z",
      "mergedAt": "2022-02-01T20:12:18Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "38f9001f0202b8481c6f22ec5e59a6e93a3ea1cf"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "No normative, informative appendix on the application of the scheme, multiple approvals, merging",
          "createdAt": "2022-02-01T20:12:14Z",
          "updatedAt": "2022-02-01T20:12:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zw50W",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T21:50:59Z",
          "updatedAt": "2022-01-31T21:50:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zy0G5",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T10:53:32Z",
          "updatedAt": "2022-02-01T10:55:45Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": " +1 for the DPoP comparison, it does seem that not much will change for the auth server though, unless we make whatever holder binding mechanism we agree on optional (which could be worth considering). IMO the biggest advantage will be when it comes to the RS, since they will only have to validate the bbs+ proof, instead of both the JWT and the DPoP.",
              "createdAt": "2022-02-01T10:53:32Z",
              "updatedAt": "2022-02-01T10:55:46Z"
            },
            {
              "originalPosition": 13,
              "body": "It may not be trivial how to sign a token (i.e., JSON) with bbs+. Should we point to JWP here perhaps?",
              "createdAt": "2022-02-01T10:53:36Z",
              "updatedAt": "2022-02-01T10:55:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zy2Tb",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T11:01:43Z",
          "updatedAt": "2022-02-01T11:01:43Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Agree, however the nuance here is that a BBS+ signature issued even without holder binding is still better than an ordinary JWT as it gives the ability for the resource server to detect a replay attack. While keeping the protocol relatively simple as the authorization server does not need up front key material from the relying party during an authZ request, nor does the resource server need to validate both a JWT and seperate DPoP.",
              "createdAt": "2022-02-01T11:01:43Z",
              "updatedAt": "2022-02-01T11:01:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zy2a7",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T11:02:09Z",
          "updatedAt": "2022-02-01T11:02:09Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Yeah potentially a good idea as a note? Feel free to suggest one",
              "createdAt": "2022-02-01T11:02:09Z",
              "updatedAt": "2022-02-01T11:02:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z1IHQ",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T17:53:15Z",
          "updatedAt": "2022-02-01T17:53:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nBBS Signatures due to their unique properties removes this source of correlation but maintains the same set of guarantees required by a resource server to validate an access token back to its relevant authority (note that an approach to signing JSON tokens with BBS that may be of relevance is the [JWP](https://json-web-proofs.github.io/json-web-proofs/draft-jmiller-json-web-proof.html) format and serialization). In the context of a protocol like OAuth2.0 the access token issued by the authorization server would feature a BBS Signature, however instead of the relying party providing this access token as issued, in their request to a resource server, they derive a unique proof from the original access token and include that in the request instead, thus removing this vector of correlation.\r\n```",
              "createdAt": "2022-02-01T17:53:15Z",
              "updatedAt": "2022-02-01T19:58:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z15X2",
          "commit": {
            "abbreviatedOid": "92e8bc0"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T20:01:57Z",
          "updatedAt": "2022-02-01T20:01:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "PR_kwDOF8lax84x2rPN",
      "title": "Fixed private key domain to 0 < SK < r",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/45",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As defined in `KeyGen`, `SK` should not be `0` or `r` in `SkToPk`. The `KeyGen` definition matches selection from `Zp*` from section 4.3 of [Camenisch, Drijvers, Lehmann](https://eprint.iacr.org/2016/663.pdf).",
      "createdAt": "2022-01-31T17:55:11Z",
      "updatedAt": "2022-01-31T21:43:22Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "ceae7fde0b9d557d2778a92dead371ecc7a241f5",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "sk-domain-fix",
      "headRefOid": "0847ffa4578ed029aa37ba84e50295a938735b24",
      "closedAt": "2022-01-31T21:43:22Z",
      "mergedAt": "2022-01-31T21:43:22Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "a5771a42d99466a1e87a06afeb2d1cdf8cec6b5d"
      },
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Probably shouldn\u2019t be any low value either like `1`",
          "createdAt": "2022-01-31T18:25:00Z",
          "updatedAt": "2022-01-31T18:25:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you suggest some spec text if you think this definition should be even more constrained?",
          "createdAt": "2022-01-31T19:25:19Z",
          "updatedAt": "2022-01-31T19:25:19Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Probably shouldn\u2019t be any low value either like `1`\r\n\r\nI don't see a problem if SK is indeed random. This is similar to the way it is defined [here ](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.2) i think.",
          "createdAt": "2022-01-31T19:31:13Z",
          "updatedAt": "2022-01-31T19:31:13Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Probably shouldn\u2019t be any low value either like `1`\r\n\r\nI updated the PR description to point to section 4.3 of CDL, where they pick SK at random from Zp*. This PR is mainly to correct an inconsistency in the spec.",
          "createdAt": "2022-01-31T21:07:49Z",
          "updatedAt": "2022-01-31T21:07:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor change, aligning to underlying academic work, multiple approvals, merging. Thanks @christianpaquin",
          "createdAt": "2022-01-31T21:43:15Z",
          "updatedAt": "2022-01-31T21:43:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zwY82",
          "commit": {
            "abbreviatedOid": "0847ffa"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T19:27:20Z",
          "updatedAt": "2022-01-31T19:27:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zwaKs",
          "commit": {
            "abbreviatedOid": "0847ffa"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T19:32:08Z",
          "updatedAt": "2022-01-31T19:32:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOF8lax84x4u7N",
      "title": "Restructure to allow for profile sections",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/47",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Minor restructure to the draft to make room for the concrete definition of a profile for the BBS signature scheme based on BLS12-381. Relevant discussion in #46 ",
      "createdAt": "2022-02-01T08:33:25Z",
      "updatedAt": "2022-02-01T19:57:34Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "a5771a42d99466a1e87a06afeb2d1cdf8cec6b5d",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/restructure-profiles",
      "headRefOid": "29698c97938835987d35cd05730c268ac65a1f2a",
      "closedAt": "2022-02-01T19:56:52Z",
      "mergedAt": "2022-02-01T19:56:51Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "63c561e7851a8e5ce5ee919ba95b5500e64709ae"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, minor re-structure of doc, blocking further progression of draft, merging.",
          "createdAt": "2022-02-01T19:57:34Z",
          "updatedAt": "2022-02-01T19:57:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zzkS9",
          "commit": {
            "abbreviatedOid": "29698c9"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T13:51:07Z",
          "updatedAt": "2022-02-01T13:51:07Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "we need a spec that does update the JOSE / COSE registry... eventually. \r\nI would prefer if we could do that here.",
              "createdAt": "2022-02-01T13:51:07Z",
              "updatedAt": "2022-02-01T13:51:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zzkUv",
          "commit": {
            "abbreviatedOid": "29698c9"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T13:51:12Z",
          "updatedAt": "2022-02-01T13:51:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84z1KPb",
          "commit": {
            "abbreviatedOid": "29698c9"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T17:57:54Z",
          "updatedAt": "2022-02-01T17:57:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84z14E6",
          "commit": {
            "abbreviatedOid": "29698c9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T19:56:44Z",
          "updatedAt": "2022-02-01T19:56:45Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "See #48 ",
              "createdAt": "2022-02-01T19:56:44Z",
              "updatedAt": "2022-02-01T19:56:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOF8lax84x7daP",
      "title": "Minor rework of abstract",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/49",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-01T20:57:36Z",
      "updatedAt": "2022-02-02T18:58:26Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2be94728d0fb5e2a281afe2881a7b49cf6e1b9d0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/rework-abstract",
      "headRefOid": "e28c68124f182331bb7ceed74f54701bf973eb92",
      "closedAt": "2022-02-02T18:58:22Z",
      "mergedAt": "2022-02-02T18:58:22Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "b08309ce8aed58d0acfe33bf0e119c69ac54ef5d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84z2ia8",
          "commit": {
            "abbreviatedOid": "03eb5d8"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T23:18:21Z",
          "updatedAt": "2022-02-01T23:18:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84z20ma",
          "commit": {
            "abbreviatedOid": "03eb5d8"
          },
          "author": "bumblefudge",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T01:46:31Z",
          "updatedAt": "2022-02-02T01:46:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nBBS is a digital signature scheme categorized as a form of short group signature that supports several novel properties. Notably, the scheme supports signing multiple messages whilst producing a single output digital signature. Through this capability, the possessor of a signature is able to derive proofs that selectively reveal subsets of the originally signed set of messages, whilst preserving the verifiable authenticity and integrity of the messages. Furthermore, these derived proofs are said to be zero-knowledge in nature as they do not reveal the underlying signature; instead, what they reveal is a proof of knowledge of the undisclosed signature.\r\n```",
              "createdAt": "2022-02-02T01:46:31Z",
              "updatedAt": "2022-02-02T01:46:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z20px",
          "commit": {
            "abbreviatedOid": "03eb5d8"
          },
          "author": "bumblefudge",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T01:47:05Z",
          "updatedAt": "2022-02-02T01:47:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I saw a rare opportunity to be helpful and I jumped on it :D ",
              "createdAt": "2022-02-02T01:47:05Z",
              "updatedAt": "2022-02-02T01:47:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z22Cw",
          "commit": {
            "abbreviatedOid": "03eb5d8"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T02:01:49Z",
          "updatedAt": "2022-02-02T02:01:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Much appreciated, thank you!",
              "createdAt": "2022-02-02T02:01:49Z",
              "updatedAt": "2022-02-02T02:01:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z3Ffp",
          "commit": {
            "abbreviatedOid": "e28c681"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T04:54:05Z",
          "updatedAt": "2022-02-02T04:54:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDOF8lax84x7ddn",
      "title": "Minor rework of introduction",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/50",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-01T20:57:53Z",
      "updatedAt": "2022-02-07T22:27:00Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2be94728d0fb5e2a281afe2881a7b49cf6e1b9d0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/rework-introduction",
      "headRefOid": "77a78a98b95be0e3dd5a8b7f001235ab70410a70",
      "closedAt": "2022-02-07T22:26:42Z",
      "mergedAt": "2022-02-07T22:26:42Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "6f6e986ca4988d6ce12ae6c1a6a4097fa2927b6e"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on Feb 7th call, multiple approvals, purely editorial, merging",
          "createdAt": "2022-02-07T22:26:38Z",
          "updatedAt": "2022-02-07T22:26:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84z2ihw",
          "commit": {
            "abbreviatedOid": "77a78a9"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T23:19:00Z",
          "updatedAt": "2022-02-01T23:19:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYMz",
          "commit": {
            "abbreviatedOid": "77a78a9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:14:09Z",
          "updatedAt": "2022-02-07T19:14:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYRx",
          "commit": {
            "abbreviatedOid": "77a78a9"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:14:28Z",
          "updatedAt": "2022-02-07T19:14:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYZX",
          "commit": {
            "abbreviatedOid": "77a78a9"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:14:56Z",
          "updatedAt": "2022-02-07T19:14:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOF8lax84x72b6",
      "title": "Minor tweaks to the terminology",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/51",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds a definition for r and splits the notational convention section into two parts",
      "createdAt": "2022-02-01T23:28:34Z",
      "updatedAt": "2022-02-15T08:18:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2be94728d0fb5e2a281afe2881a7b49cf6e1b9d0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/terminology-section",
      "headRefOid": "5a73c934ece3b8f580355e77ebe1df8c34c4f6b0",
      "closedAt": "2022-02-07T22:23:21Z",
      "mergedAt": "2022-02-07T22:23:21Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2cd2c0926460561b62543b748ffb67181153e656"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 7th Feb call no objections, merging",
          "createdAt": "2022-02-07T22:23:16Z",
          "updatedAt": "2022-02-07T22:23:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84z_yZF",
          "commit": {
            "abbreviatedOid": "5a73c93"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T20:12:27Z",
          "updatedAt": "2022-02-03T20:12:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYld",
          "commit": {
            "abbreviatedOid": "5a73c93"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:15:41Z",
          "updatedAt": "2022-02-07T19:15:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYmY",
          "commit": {
            "abbreviatedOid": "5a73c93"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:15:45Z",
          "updatedAt": "2022-02-07T19:15:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOF8lax84yHwNK",
      "title": "Ensuring SK > 0",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/53",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update `keyGen` to always return SK>0 and `KeyValidate` to check if SK = 0. \r\n\r\nAnother option would be to point to the [BLS draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.3) since the functions are the same. There is useful context for their choices [here](https://github.com/cfrg/draft-irtf-cfrg-bls-signature/issues/25).",
      "createdAt": "2022-02-05T16:23:51Z",
      "updatedAt": "2022-02-07T22:24:06Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6182a4958889acb673dde16b02762dc05c7062ac",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "update_keyGen",
      "headRefOid": "1ed06fe84da2a6bb9221555673559869b4e9cf2b",
      "closedAt": "2022-02-07T22:24:05Z",
      "mergedAt": "2022-02-07T22:24:05Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "af5cc53b9ae6d00c2257a669a5ef8a931a658527"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on Feb 7th WG call, no objections, aligning to changes in underlying spec that the section was born from, merging",
          "createdAt": "2022-02-07T22:24:04Z",
          "updatedAt": "2022-02-07T22:24:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840KaJE",
          "commit": {
            "abbreviatedOid": "1ed06fe"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:21:05Z",
          "updatedAt": "2022-02-07T19:21:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840LEID",
          "commit": {
            "abbreviatedOid": "1ed06fe"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T22:23:33Z",
          "updatedAt": "2022-02-07T22:23:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOF8lax84yMYMI",
      "title": "Added presentation message selection section.",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/55",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added presentation message selection section, to clarify randomness recommendations. Addresses issue #15.\r\n\r\nPreviously PR #21, but re-opening cleaner PR here.",
      "createdAt": "2022-02-07T19:52:04Z",
      "updatedAt": "2022-02-07T22:24:55Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6182a4958889acb673dde16b02762dc05c7062ac",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "nonce-issue-15-redux",
      "headRefOid": "4433d3cad1b511a916b5820cd51a73642fa75a5d",
      "closedAt": "2022-02-07T22:24:55Z",
      "mergedAt": "2022-02-07T22:24:55Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "79346d7ebd8a89476441673e8e68ac91f985e1ef"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 7th Feb WG call, no objections, multiple approvals, merging",
          "createdAt": "2022-02-07T22:24:50Z",
          "updatedAt": "2022-02-07T22:24:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840KjhM",
          "commit": {
            "abbreviatedOid": "4433d3c"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:58:05Z",
          "updatedAt": "2022-02-07T19:58:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840Kl_f",
          "commit": {
            "abbreviatedOid": "4433d3c"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T20:08:37Z",
          "updatedAt": "2022-02-07T20:08:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840LET7",
          "commit": {
            "abbreviatedOid": "4433d3c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T22:24:25Z",
          "updatedAt": "2022-02-07T22:24:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOF8lax84yM5E6",
      "title": "add link to blind sign extension draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/56",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed on Feb 7th WG call, this PR addresses the fact that a link to the blind sign draft was missing from the root readme.",
      "createdAt": "2022-02-07T22:49:59Z",
      "updatedAt": "2022-02-08T00:25:20Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6f6e986ca4988d6ce12ae6c1a6a4097fa2927b6e",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-readme",
      "headRefOid": "e2ba1b5cf036faa801954d05a0a9d554ef8ba813",
      "closedAt": "2022-02-08T00:25:18Z",
      "mergedAt": "2022-02-08T00:25:18Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2f0f0f5a6b8ba77acd13ea196f74580069b6e13d"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, facilitates better discovery of output from this WG no changes to actual drafts, merging",
          "createdAt": "2022-02-08T00:25:12Z",
          "updatedAt": "2022-02-08T00:25:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840LKgO",
          "commit": {
            "abbreviatedOid": "e2ba1b5"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T22:56:29Z",
          "updatedAt": "2022-02-07T22:56:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840LRfV",
          "commit": {
            "abbreviatedOid": "e2ba1b5"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T23:41:21Z",
          "updatedAt": "2022-02-07T23:41:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOF8lax84yXyyi",
      "title": "Moving the operations inside a code block",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/57",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Moving the entire function inside a code block to display correctly white spaces etc., in markdown. This is consistent to most other specs like [BLS signatures](https://github.com/cfrg/draft-irtf-cfrg-bls-signature/blob/master/draft-irtf-cfrg-bls-signature.md), [Blind RSA](https://github.com/cfrg/draft-irtf-cfrg-blind-signatures/blob/main/draft-irtf-cfrg-rsa-blind-signatures.md), [Frost](https://github.com/cfrg/draft-irtf-cfrg-frost/blob/master/draft-irtf-cfrg-frost.md) etc.",
      "createdAt": "2022-02-10T11:28:12Z",
      "updatedAt": "2022-02-10T18:48:11Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2f0f0f5a6b8ba77acd13ea196f74580069b6e13d",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "markdown_display_tweaks",
      "headRefOid": "79b904bd3f552bcadac28aeb5265b1a85d4a3d88",
      "closedAt": "2022-02-10T18:48:11Z",
      "mergedAt": "2022-02-10T18:48:11Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "535d98143d46e10d2c358f76bb985e2c530d018a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840aNN7",
          "commit": {
            "abbreviatedOid": "79b904b"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T18:34:01Z",
          "updatedAt": "2022-02-10T18:34:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDOF8lax84yoILV",
      "title": "SpkGen alternative high-level description",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/58",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "IMO the SpkGen algorithm on its own is a little hard to understand for someone that doesn\u2019t know how BBS+ work. This is a first attempt for providing an alternative, higher-level description and intuition of SpkGen, in 2 steps: the bbs signature blinding and the generalized Schnorr proof.",
      "createdAt": "2022-02-12T19:15:09Z",
      "updatedAt": "2022-02-16T00:40:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "55ba4a292f66e89a31b32793497ebc78b044dfe9",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "high-level-spkGen",
      "headRefOid": "c94a2dac40cfa21c4c42e6782b24392aec086e1b",
      "closedAt": "2022-02-16T00:40:56Z",
      "mergedAt": "2022-02-16T00:40:56Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "93cc1565a091dffa5067310b01c22bb5a78820b5"
      },
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps a follow-up PR to change the following:\r\n\r\n1. Points should be uppercase\r\n2. Scalars should be lowercase",
          "createdAt": "2022-02-14T16:15:27Z",
          "updatedAt": "2022-02-14T16:15:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal are you able to resolve conflicts with this PR?",
          "createdAt": "2022-02-15T07:47:56Z",
          "updatedAt": "2022-02-15T07:47:56Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @BasileiosKal are you able to resolve conflicts with this PR?\r\n\r\nupdated",
          "createdAt": "2022-02-15T20:38:53Z",
          "updatedAt": "2022-02-15T20:38:53Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Non-normative section, providing a good explanation of this complex algorithm, multiple approvals, PR open multiple days, merging.",
          "createdAt": "2022-02-16T00:40:51Z",
          "updatedAt": "2022-02-16T00:40:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840gT8k",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-12T19:45:29Z",
          "updatedAt": "2022-02-12T19:45:29Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Any commentary we can provide here on what P2 is?",
              "createdAt": "2022-02-12T19:45:29Z",
              "updatedAt": "2022-02-12T19:45:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840gT-C",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-12T19:46:50Z",
          "updatedAt": "2022-02-12T19:46:51Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Assuming r is as defined in terminology? If so, no need to change anything",
              "createdAt": "2022-02-12T19:46:51Z",
              "updatedAt": "2022-02-12T19:46:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840gT_S",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-12T19:48:09Z",
          "updatedAt": "2022-02-12T19:48:09Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n### Algorithmic Explanation\r\n```",
              "createdAt": "2022-02-12T19:48:09Z",
              "updatedAt": "2022-02-12T19:48:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840gWWS",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-12T22:19:59Z",
          "updatedAt": "2022-02-12T22:19:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThe following section provides an explanation of how the Signature Proof Of Knowledge Generation (SpkGen) works. \r\n\r\nLet the prover be in possession of a BBS signature `(A, e, s)` with `A = b * (1/(e + Sk))` where `Sk` the signer's secret key and,\r\n```",
              "createdAt": "2022-02-12T22:19:59Z",
              "updatedAt": "2022-02-12T22:19:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840g2Lj",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-13T17:54:07Z",
          "updatedAt": "2022-02-13T17:54:07Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yes, r is as defined in the Notation section (the prime order of G1 and G2).",
              "createdAt": "2022-02-13T17:54:07Z",
              "updatedAt": "2022-02-13T17:54:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840g2ru",
          "commit": {
            "abbreviatedOid": "a5d13a7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-13T18:17:28Z",
          "updatedAt": "2022-02-13T18:17:28Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "updated",
              "createdAt": "2022-02-13T18:17:28Z",
              "updatedAt": "2022-02-13T18:17:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840g4vc",
          "commit": {
            "abbreviatedOid": "c09ed88"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-02-13T19:48:12Z",
          "updatedAt": "2022-02-13T19:48:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840j0ju",
          "commit": {
            "abbreviatedOid": "c09ed88"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T15:33:13Z",
          "updatedAt": "2022-02-14T15:33:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOF8lax84ywZ76",
      "title": "Core draft restructure",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/60",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This PR is a proposal to restructure the draft drawing inspiration from the latest [BLS signatures draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04). Essentially the high-level structure of the document after this PR is merged will take the following form.\r\n\r\n- Introduction\r\n    - Terminology\r\n    - Notation\r\n    - Structure of this document\r\n- Conventions\r\n- Scheme Definition\r\n    - Parameters\r\n    - Operations\r\n        - KeyGen\r\n        - SkToPk\r\n        - ....\r\n- Security Considerations\r\n- Profile -> Ciphersuite\r\n    - Format\r\n    - BLS12-381 Ciphersuite\r\n- IANA Considerations\r\n- Appendix\r\n- .....\r\n",
      "createdAt": "2022-02-14T04:10:25Z",
      "updatedAt": "2022-02-15T07:46:40Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "535d98143d46e10d2c358f76bb985e2c530d018a",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/minor-restructure",
      "headRefOid": "397e9636bf785327d8e0647cc1664df56c717b86",
      "closedAt": "2022-02-15T07:46:13Z",
      "mergedAt": "2022-02-15T07:46:13Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "55ba4a292f66e89a31b32793497ebc78b044dfe9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-02-15T07:46:40Z",
          "updatedAt": "2022-02-15T07:46:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840j0vm",
          "commit": {
            "abbreviatedOid": "397e963"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T15:33:42Z",
          "updatedAt": "2022-02-14T15:33:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840j4Te",
          "commit": {
            "abbreviatedOid": "397e963"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T15:43:33Z",
          "updatedAt": "2022-02-14T15:43:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840kDLg",
          "commit": {
            "abbreviatedOid": "397e963"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T16:14:24Z",
          "updatedAt": "2022-02-14T16:14:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840lDF_",
          "commit": {
            "abbreviatedOid": "397e963"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T20:03:18Z",
          "updatedAt": "2022-02-14T20:03:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "PR_kwDOF8lax84yzKE8",
      "title": "Add message mapping to scalar",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/61",
      "state": "CLOSED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adds a section describing how to map messages to a scalar that can be cryptographically signed. ",
      "createdAt": "2022-02-14T16:36:19Z",
      "updatedAt": "2022-04-05T01:21:58Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "68f56263eac415e2dc3e022e60bd1544c0d352eb",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "ml/message-mapping",
      "headRefOid": "a9376bfb5b68f28ee886e5b69e171196680149da",
      "closedAt": "2022-03-21T21:11:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed briefly on WG call 21st of Feb, one proposal was to have the MapToScalar as a pre-sign pre-spkgen operations for converting messages into their appropriate scalars.",
          "createdAt": "2022-02-21T19:19:48Z",
          "updatedAt": "2022-02-21T19:19:48Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "@mikelodder7 Is MapToScalar the same extension point where membership values would be encoded such that set (non-)membership proofs can be later generated?",
          "createdAt": "2022-02-21T19:34:58Z",
          "updatedAt": "2022-02-21T19:34:58Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @mikelodder7 Is MapToScalar the same extension point where membership values would be encoded such that set (non-)membership proofs can be later generated?\r\n\r\nYes",
          "createdAt": "2022-02-22T23:30:07Z",
          "updatedAt": "2022-02-22T23:30:07Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I understand the use case for the first three encoding methods suggested here, however unsure what value the remaining few provide, could we remove these or elaborate more on their usage.\r\n\r\nI also think this section needs to be restructured formally to be more like the other operations defined in the spec, as currently the numeric encoding options for example describes the algorithm in a paragraph instead of say how the sign operation is performed.\r\n\r\nAlso we have to be very confident in the collision resistant properties of the numeric encoding method to prevent a message forgery attack like what is being discussed in #74.\r\n\r\nAnd guidance needs to be added for the second option around message generator selection/validation which is effectively a committed message, because failure to do so could lead a signer to use a generator twice.",
          "createdAt": "2022-03-01T07:49:50Z",
          "updatedAt": "2022-03-01T07:49:50Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I'd also note that option 2 is not actually a MapToScalar function as the input is already a scalar so I think we can disregard it from this section of the spec and instead supply appropriate guidance elsewhere.",
          "createdAt": "2022-03-02T04:55:14Z",
          "updatedAt": "2022-03-02T04:55:14Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> I understand the use case for the first three encoding methods suggested here, however unsure what value the remaining few provide, could we remove these or elaborate more on their usage.\r\n\r\nI believe these fixed values are intended as a means for the holder to generate a proof about a value that isn't being disclosed.  If the issuer sets the value to null/empty/ignored, that the holder can generate a proof of such to differentiate that message from one that is simply being hidden.\r\n\r\nWhile a similar signaling is also possible at the application level by having encoded values, I believe these are useful to represent when the value itself (encoded or not) is in the given null/empty/ignored state when being signed.  The alternative is to consider that an error, that every message MUST always have a defined value before it can be mapped to a scalar.",
          "createdAt": "2022-03-04T23:28:59Z",
          "updatedAt": "2022-03-04T23:28:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I believe these fixed values are intended as a means for the holder to generate a proof about a value that isn't being disclosed. If the issuer sets the value to null/empty/ignored, that the holder can generate a proof of such to differentiate that message from one that is simply being hidden.\r\n\r\nThanks @quartzjer makes sense, in that case I understand the potential for having a representation for null or ignored (maybe?). But empty appears to be better addressed at the application layer because not all data types have the concept of empty (e.g numeric data types).\r\n\r\nI continue to be cautious here, in the case of the numeric mapping function it must be as collision resistant as a hash function to be acceptable. ",
          "createdAt": "2022-03-05T00:05:51Z",
          "updatedAt": "2022-03-05T00:05:51Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It doesn\u2019t have to be collision resistant to map to the scalar. My first name will always map to the same value as a null would to another. They don\u2019t even have to be unique. However mapping to a scalar should be a separate discussion in an appendix as guidelines not requirements. ",
          "createdAt": "2022-03-05T00:09:48Z",
          "updatedAt": "2022-03-05T00:09:48Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019m going to update to be such",
          "createdAt": "2022-03-05T00:10:04Z",
          "updatedAt": "2022-03-05T00:10:04Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I'd like to hold off merging this PR while we discuss a proposal to break each mapping method out like is shown in #77 ",
          "createdAt": "2022-03-11T04:50:38Z",
          "updatedAt": "2022-03-11T04:50:38Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on the WG call, going to close this PR in favour of opening seperate ones for each mapping method, if not objection from @mikelodder7 ",
          "createdAt": "2022-03-21T18:21:38Z",
          "updatedAt": "2022-03-21T18:21:38Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Discussed on the WG call, going to close this PR in favour of opening seperate ones for each mapping method, if not objection from @mikelodder7\r\n\r\n\ud83d\udc4d\ud83c\udffb ",
          "createdAt": "2022-03-21T18:30:41Z",
          "updatedAt": "2022-03-21T18:30:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840mz6H",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T07:58:01Z",
          "updatedAt": "2022-02-15T07:58:02Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Think we should talk about usecases elsewhere\r\n\r\n```suggestion\r\nThe following is a list of mappings:\r\n```",
              "createdAt": "2022-02-15T07:58:02Z",
              "updatedAt": "2022-02-15T07:58:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840m0rn",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T08:01:06Z",
          "updatedAt": "2022-02-15T08:01:07Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nData to be signed can be mapped multiple ways depending on how it will be used downstream in various Zero-Knowledge Proof protocols. For example to be able to construct a range proof for a signed message, it must have been encoded in a particular way during the signing procedure.\r\n```",
              "createdAt": "2022-02-15T08:01:07Z",
              "updatedAt": "2022-02-15T08:01:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840m0wn",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T08:01:24Z",
          "updatedAt": "2022-02-15T08:01:25Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\n2. **Bytes**: a value that is already in the base field. No mapping method required.\r\n```",
              "createdAt": "2022-02-15T08:01:24Z",
              "updatedAt": "2022-02-15T08:01:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840m015",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T08:01:46Z",
          "updatedAt": "2022-02-15T08:01:47Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Can you explain the assignment of the value 5?",
              "createdAt": "2022-02-15T08:01:46Z",
              "updatedAt": "2022-02-15T08:01:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xBJG",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:30:34Z",
          "updatedAt": "2022-02-16T23:30:34Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Its the smallest safe prime. Otherwise there's no other special meaning.",
              "createdAt": "2022-02-16T23:30:34Z",
              "updatedAt": "2022-02-16T23:30:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840_cKH",
          "commit": {
            "abbreviatedOid": "c214191"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Very supportive of adding these flexible definitions of different mapping methods.",
          "createdAt": "2022-02-21T19:33:27Z",
          "updatedAt": "2022-02-21T19:33:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841EMh-",
          "commit": {
            "abbreviatedOid": "c214191"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-22T19:54:40Z",
          "updatedAt": "2022-02-22T19:54:40Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "consider adding an issue for the FIXME, so it can be tracked during issue review.",
              "createdAt": "2022-02-22T19:54:40Z",
              "updatedAt": "2022-02-22T19:55:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841Ei6P",
          "commit": {
            "abbreviatedOid": "c214191"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-22T21:29:23Z",
          "updatedAt": "2022-02-22T21:29:23Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "@OR13 this issue has already been addressed and updated in the latest draft see https://identity.foundation/bbs-signature/draft-bbs-signatures.html#section-1.2 PR is just out of date",
              "createdAt": "2022-02-22T21:29:23Z",
              "updatedAt": "2022-02-22T21:29:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841xbaa",
          "commit": {
            "abbreviatedOid": "a9376bf"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T19:23:13Z",
          "updatedAt": "2022-03-07T19:23:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOF8lax84yzYBr",
      "title": "Update algorithms for consistency and simplicity",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/62",
      "state": "MERGED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This updates `Sign` to be deterministic and includes updating SpkGen and SpkVerify to be mathematically correct and removes superfluous checks in verify and makes it simpler.\r\nSpkGen proof is much smaller now.\r\nSpkVerify has reduced steps but its equally correct and secure.",
      "createdAt": "2022-02-14T17:30:53Z",
      "updatedAt": "2022-02-23T21:43:31Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "68f56263eac415e2dc3e022e60bd1544c0d352eb",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "ml/detsign",
      "headRefOid": "d0394236c672602528e1e122057c1fe678735010",
      "closedAt": "2022-02-23T21:43:28Z",
      "mergedAt": "2022-02-23T21:43:28Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "d02eced2451d4d63fb765ae0c75f44b9365e9d46"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the `spkGen` and `spkVerify` are those essentially the same changes as in PR#23 with different notation?? \r\n\r\nI can close PR#23 since it seems to do the same thing for those functions.",
          "createdAt": "2022-02-14T19:40:06Z",
          "updatedAt": "2022-02-14T19:40:06Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No there not exactly the same",
          "createdAt": "2022-02-14T19:40:57Z",
          "updatedAt": "2022-02-14T19:40:57Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> No there not exactly the same\r\n\r\nOk. Is there a reason to keep both PRs open then??\r\n\r\nIt does seem that every change in #23 is also here.",
          "createdAt": "2022-02-14T19:50:34Z",
          "updatedAt": "2022-02-14T19:50:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "In general im supportive of the direction this PR is taking so thanks @mikelodder7 for submitting it, however it is difficult to review because it is attempting to do many things, including:\r\n\r\n- Updates the sign procedure to be deterministic\r\n- Changing SpkGen procedure, including the resulting serialization of the proof\r\n- Changing SpkVerify procedure, including how it relies on the proof as its input (now uses the challenge supplied)\r\n- Multiple updates to notation including changing terms from r to q? Captializing some notation h -> H And using new notation that isn't completely defined e.g `hash.read()`\r\n\r\n@mikelodder7 have I got the above right as the scope of this PR ^ and if so any way we can break it apart for independent review of each item?",
          "createdAt": "2022-02-15T07:54:41Z",
          "updatedAt": "2022-02-15T07:54:41Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > No there not exactly the same\r\n> \r\n> Ok. Is there a reason to keep both PRs open then??\r\n> \r\n> It does seem that every change in #23 is also here.\r\n\r\nIt\u2019s not exactly. That PR has the dual commitment equality check that isn\u2019t needed",
          "createdAt": "2022-02-16T00:47:51Z",
          "updatedAt": "2022-02-16T00:47:51Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you address the reviews above and conflicts after merging #23?",
          "createdAt": "2022-02-16T00:54:30Z",
          "updatedAt": "2022-02-16T00:54:30Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @mikelodder7 can you address the reviews above and conflicts after merging #23?\r\n\r\nPlanning on in the next day or so",
          "createdAt": "2022-02-16T00:56:17Z",
          "updatedAt": "2022-02-16T00:56:17Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can't get the proof to work out with these changes so far, is there an implementation to compare against?",
          "createdAt": "2022-02-17T20:44:24Z",
          "updatedAt": "2022-02-17T20:44:24Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you update this PR to resolve the conflict?",
          "createdAt": "2022-02-19T03:56:56Z",
          "updatedAt": "2022-02-19T03:56:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 21st of Feb, unable to progress at this time, PR conflicts need to be resolved",
          "createdAt": "2022-02-21T19:27:40Z",
          "updatedAt": "2022-02-21T19:27:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Merging this PR on the understanding that @BasileiosKal and @mikelodder7 are working behind the scenes to ensure that this description of SpkGen is still consistent with academic literature.",
          "createdAt": "2022-02-23T21:43:15Z",
          "updatedAt": "2022-02-23T21:43:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840k_oF",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T19:48:53Z",
          "updatedAt": "2022-02-14T19:48:54Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "`b = P1 + H0 * s + H[1] * msg[1] + ... + H[L] * msg[L]` I think, and probably `msg[1]` instead of `msg[i]` above. Should we capitalize B?",
              "createdAt": "2022-02-14T19:48:53Z",
              "updatedAt": "2022-02-14T19:48:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lAM0",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T19:51:15Z",
          "updatedAt": "2022-02-14T19:51:16Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "`+ B * r1` I believe",
              "createdAt": "2022-02-14T19:51:16Z",
              "updatedAt": "2022-02-14T19:51:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lAnz",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T19:53:01Z",
          "updatedAt": "2022-02-14T19:53:02Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Have we changed all occurances of using r through out this draft?",
              "createdAt": "2022-02-14T19:53:01Z",
              "updatedAt": "2022-02-14T19:53:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lCXW",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T20:00:13Z",
          "updatedAt": "2022-02-14T20:00:13Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "Based on `Abar = A'k` checked by the pairing. `Abar = A'(-e) + B*r1 = A'(-e) + A'(e + k) = A'k`",
              "createdAt": "2022-02-14T20:00:13Z",
              "updatedAt": "2022-02-14T20:00:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lLyX",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T20:40:10Z",
          "updatedAt": "2022-02-14T20:40:11Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Assume this should actually be generalized here?\r\n```suggestion\r\n2. h = HASH(SK  || msg[i] || ... || msg[L])\r\n```",
              "createdAt": "2022-02-14T20:40:10Z",
              "updatedAt": "2022-02-14T20:40:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lL65",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T20:40:45Z",
          "updatedAt": "2022-02-14T20:40:45Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "Need to document this .read() notation somewhere and what happens on consecutive reads",
              "createdAt": "2022-02-14T20:40:45Z",
              "updatedAt": "2022-02-14T20:41:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840mx9c",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "See comments above",
          "createdAt": "2022-02-15T07:49:34Z",
          "updatedAt": "2022-02-15T07:49:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840pz3i",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T17:31:05Z",
          "updatedAt": "2022-02-15T17:31:15Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Why not just check for `e(A', W) == e(Abar, P2)`??",
              "createdAt": "2022-02-15T17:31:05Z",
              "updatedAt": "2022-02-15T17:31:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840rgCF",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T00:56:03Z",
          "updatedAt": "2022-02-16T00:56:03Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Because mathematically it\u2019s quicker. You can compute what I put with a single pairing versus two pairings. Most folks don\u2019t know that. It\u2019s also preferable this way.",
              "createdAt": "2022-02-16T00:56:03Z",
              "updatedAt": "2022-02-16T00:56:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840s4zX",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T09:15:10Z",
          "updatedAt": "2022-02-16T09:15:11Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Got it, thanks! Maybe we should replace it with `e(A' + Abar, W - P2) != 1` then??",
              "createdAt": "2022-02-16T09:15:10Z",
              "updatedAt": "2022-02-16T11:46:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xB-t",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:36:20Z",
          "updatedAt": "2022-02-16T23:36:21Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "It matches all the other changes I've made.",
              "createdAt": "2022-02-16T23:36:21Z",
              "updatedAt": "2022-02-16T23:36:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xCKV",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:37:30Z",
          "updatedAt": "2022-02-16T23:37:31Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "No its different.",
              "createdAt": "2022-02-16T23:37:31Z",
              "updatedAt": "2022-02-16T23:37:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xCTf",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:38:28Z",
          "updatedAt": "2022-02-16T23:38:28Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Well its can be written that way but if you were to actually compute it that way it might not work.",
              "createdAt": "2022-02-16T23:38:28Z",
              "updatedAt": "2022-02-16T23:38:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xDS8",
          "commit": {
            "abbreviatedOid": "331fd56"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:45:37Z",
          "updatedAt": "2022-02-16T23:45:38Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "If that's the case then i don't see the difference with checking for equality. Don't you still compute 2 pairings??",
              "createdAt": "2022-02-16T23:45:37Z",
              "updatedAt": "2022-02-16T23:45:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84016ZL",
          "commit": {
            "abbreviatedOid": "331fd56"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T21:03:24Z",
          "updatedAt": "2022-02-17T21:03:24Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "So you are introducing a dependency on a concrete hash algorithm here? I think previous conversations in the working group and documented in issues like #8 #46 #5 was to have this abstracted away?",
              "createdAt": "2022-02-17T21:03:24Z",
              "updatedAt": "2022-02-17T21:03:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402cxW",
          "commit": {
            "abbreviatedOid": "681d5b6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T23:51:35Z",
          "updatedAt": "2022-02-17T23:51:35Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "I can give you a code sample to illustrate ",
              "createdAt": "2022-02-17T23:51:35Z",
              "updatedAt": "2022-02-17T23:51:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402hoL",
          "commit": {
            "abbreviatedOid": "681d5b6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T00:27:18Z",
          "updatedAt": "2022-02-18T01:01:48Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Is this correct?? I don't think that `C1` in spkGen is equal to the `C1` in SpkVerify and i think it is because of the change here.",
              "createdAt": "2022-02-18T00:27:18Z",
              "updatedAt": "2022-02-18T01:01:48Z"
            },
            {
              "originalPosition": 323,
              "body": "Does this hold?? If `T = D * (-r3) + H0 * s' + ...` which is what we try to prove if I'm not mistaken, then i don't think that the `C2` here is equal to the `C2` in `spkGen`. For example if we where to expand the equation, to find the scalar multiplied with `D` we would have to calculate `D * (-r3*c) + D * (-r3^)` which is not equal to `D * (-r3~)` as it appears in `spkGen` in the equation for `C2`, since `r3^ = re~ + c*r3`?",
              "createdAt": "2022-02-18T00:58:38Z",
              "updatedAt": "2022-02-18T01:01:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402mbW",
          "commit": {
            "abbreviatedOid": "681d5b6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:04:43Z",
          "updatedAt": "2022-02-18T01:04:44Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Please do!! thanks!!",
              "createdAt": "2022-02-18T01:04:43Z",
              "updatedAt": "2022-02-18T01:04:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402mj_",
          "commit": {
            "abbreviatedOid": "681d5b6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:05:52Z",
          "updatedAt": "2022-02-18T01:05:52Z",
          "comments": [
            {
              "originalPosition": 323,
              "body": "Yes it holds. I have code to prove it",
              "createdAt": "2022-02-18T01:05:52Z",
              "updatedAt": "2022-02-18T01:05:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402sjg",
          "commit": {
            "abbreviatedOid": "3c01431"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:57:04Z",
          "updatedAt": "2022-02-18T01:57:04Z",
          "comments": [
            {
              "originalPosition": 323,
              "body": "Great! I would be interested seen the code. Regardless I would also be more at ease if we could prove correctness with math since this PR does not use exactly the formulas from the academic paper (i.e., `s\u2019 = s + r2*r2` instead of `s\u2019 = s - r2*r2` which is used in the paper etc.). But I may be missing something and the code could help.",
              "createdAt": "2022-02-18T01:57:04Z",
              "updatedAt": "2022-02-18T01:57:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8405617",
          "commit": {
            "abbreviatedOid": "3c01431"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T17:57:10Z",
          "updatedAt": "2022-02-18T17:57:11Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "```suggestion\r\n26. for i in RIdxs: m^[i] = m~[i] + c * msg[i]\r\n```",
              "createdAt": "2022-02-18T17:57:10Z",
              "updatedAt": "2022-02-18T17:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841Jcz3",
          "commit": {
            "abbreviatedOid": "d039423"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-23T20:56:23Z",
          "updatedAt": "2022-02-23T20:56:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841JdOS",
          "commit": {
            "abbreviatedOid": "d039423"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-23T20:58:06Z",
          "updatedAt": "2022-02-23T20:58:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOF8lax84y13MF",
      "title": "Add basic section on subgroup selection for the scheme",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/63",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #59 ",
      "createdAt": "2022-02-15T08:45:53Z",
      "updatedAt": "2022-02-16T08:59:26Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "55ba4a292f66e89a31b32793497ebc78b044dfe9",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/sub-group-selection",
      "headRefOid": "3dcd450138376a2a741210c333e46165973d281e",
      "closedAt": "2022-02-16T08:59:22Z",
      "mergedAt": "2022-02-16T08:59:21Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "5aa6595ff5789cfa2a5610ed06462986730f0c5b"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-02-16T08:59:17Z",
          "updatedAt": "2022-02-16T08:59:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840oaDL",
          "commit": {
            "abbreviatedOid": "3dcd450"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-15T13:47:50Z",
          "updatedAt": "2022-02-15T13:47:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840sBgc",
          "commit": {
            "abbreviatedOid": "3dcd450"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-16T04:51:27Z",
          "updatedAt": "2022-02-16T04:51:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOF8lax84y82b1",
      "title": "Messages and generators notation update for readability",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/64",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "First attempt to close issue #54 (see in the issue for other options).\r\n\r\nThis PR proposes to pass the generators directly to functions instead of their indexes, with the goal of increasing spec readability.\r\n\r\nIMO this simplifies notation. For example, using indexes in spkGen will require notation for 5 different lists of indexes. This can get confusing. By passing the generators as a list, only requires notation for 2 lists of indexes (and one less input argument in SpkGen). Also,\r\n\r\n1. Passing the messages as a map between the message and the index of the generator will still require a lot of notation for indexes.\r\n2. Mentioning that those generators are not necessarily the `L` first elements from the global (or not) generators list, also preserves the flexibility required from the blind signatures.\r\n3. Mentioning that implementations may choose to pass the indexes of the generators instead and pointing to a reference implementation or perhaps a more detailed explanation in the Appendix IMO will be enough to address the efficiency of the applications concerns, while keeping the spec more readable.\r\n\r\nAlso, changes in this PR use the terminology from PR #62 to some places, but I will update it elsewhere after that PR is merged.",
      "createdAt": "2022-02-16T20:41:58Z",
      "updatedAt": "2022-03-02T04:57:46Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "d02eced2451d4d63fb765ae0c75f44b9365e9d46",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "indexes_notation",
      "headRefOid": "82dc45dca363ad3afa66a893368c50f782f0361d",
      "closedAt": "2022-03-02T04:57:46Z",
      "mergedAt": "2022-03-02T04:57:46Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "cd28c67eccd9327b9349d33011f9564bc436a841"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 21st of Feb, awaiting review from other WG members ",
          "createdAt": "2022-02-21T20:08:26Z",
          "updatedAt": "2022-02-21T20:08:26Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "In general I like the direction of this PR, I think the core draft should remain agnostic from any application specific generators such as those proposed in #68 ",
          "createdAt": "2022-02-21T20:09:06Z",
          "updatedAt": "2022-02-21T20:09:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal can you please update this PR to resolve the conflicts?",
          "createdAt": "2022-02-23T21:46:19Z",
          "updatedAt": "2022-02-23T21:46:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, PR open for 2 weeks and discussed on WG call, massive improvement in notation across the spec, merging",
          "createdAt": "2022-03-02T04:57:35Z",
          "updatedAt": "2022-03-02T04:57:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8401MQC",
          "commit": {
            "abbreviatedOid": "c1fb1c8"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Sadly, I am not qualified to review this, but it looks to be a massive improvement in documenting things. \r\n\r\n",
          "createdAt": "2022-02-17T18:07:59Z",
          "updatedAt": "2022-02-17T18:07:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8402nhx",
          "commit": {
            "abbreviatedOid": "c1fb1c8"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:14:02Z",
          "updatedAt": "2022-02-18T01:14:02Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "`m~_j` instead of `m~[j]`?",
              "createdAt": "2022-02-18T01:14:02Z",
              "updatedAt": "2022-02-18T01:14:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402nna",
          "commit": {
            "abbreviatedOid": "c1fb1c8"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:14:50Z",
          "updatedAt": "2022-02-18T01:14:50Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "`m^_j` and `m~_j`? Seems inconsistent to sometimes use the `[n]` notation for array indices.",
              "createdAt": "2022-02-18T01:14:50Z",
              "updatedAt": "2022-02-18T01:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402sFT",
          "commit": {
            "abbreviatedOid": "552b9ef"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:53:04Z",
          "updatedAt": "2022-02-18T01:53:04Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "Updated. I agree but if we move to `m_c` instead of `m^` for example then it will become `m_c_j` and `m_c_j1, m_c_j2, ...` which I don't know if I like. updated now for consistency.",
              "createdAt": "2022-02-18T01:53:04Z",
              "updatedAt": "2022-02-18T01:53:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84021L1",
          "commit": {
            "abbreviatedOid": "552b9ef"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T03:16:51Z",
          "updatedAt": "2022-02-18T03:16:52Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "I think we can probably keep m~ and m^ now they aren't causing formatting issues.",
              "createdAt": "2022-02-18T03:16:51Z",
              "updatedAt": "2022-02-18T03:16:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840wvlo",
          "commit": {
            "abbreviatedOid": "552b9ef"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Couple of minor suggestions",
          "createdAt": "2022-02-16T21:59:54Z",
          "updatedAt": "2022-02-23T09:25:05Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nThroughout the operations of this signature scheme, each message that is signed is paired with a specific generator (point in G1). Specifically, if a generator `H_1` is raised to the power of `msg_1` during signing, then `H_1` should be raised to the power of `msg_1` in all other operations as well (signature verification, proof generation and proof verification). For simplicity, each function will take as input the list of generators to be used with the messages. Those generators can be any distinct element from the generators list `H`. Applications for efficiency can elect to pass the indexes of those generators to the list `H` instead. Care must be taken for the correct generator to be raised to the correct message in that case.\r\n```",
              "createdAt": "2022-02-16T21:59:54Z",
              "updatedAt": "2022-02-23T09:25:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841cIfp",
          "commit": {
            "abbreviatedOid": "82dc45d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-01T16:51:07Z",
          "updatedAt": "2022-03-01T16:51:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841eJo0",
          "commit": {
            "abbreviatedOid": "82dc45d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-02T04:56:16Z",
          "updatedAt": "2022-03-02T04:56:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDOF8lax84y-O5V",
      "title": "Start of population of BLS 12-381 cipher suite",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/65",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Simplifies definition around the point_to_octet and octet_to_point functions including providing a concrete link to the serialization and deserialization procedure for BLS12-381 which starts to address #2. Also documents the digest algorithm agreed in previous working group calls and highlighted in #5.  ",
      "createdAt": "2022-02-17T07:56:30Z",
      "updatedAt": "2022-02-18T00:37:09Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5aa6595ff5789cfa2a5610ed06462986730f0c5b",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/add-detail-to-cipher-suite",
      "headRefOid": "22eb4faa5a4695cd11d1570d291db73814bc1baa",
      "closedAt": "2022-02-18T00:37:06Z",
      "mergedAt": "2022-02-18T00:37:06Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "dc30bb88bf1491659f325fee1b9ae74394ffff04"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8400mVh",
          "commit": {
            "abbreviatedOid": "df15dd9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Suggestion for better readability in html.",
          "createdAt": "2022-02-17T16:11:34Z",
          "updatedAt": "2022-02-17T16:20:21Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n* H\r\n```",
              "createdAt": "2022-02-17T16:11:34Z",
              "updatedAt": "2022-02-17T16:20:21Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\n* point\\_to\\_octets\r\n```",
              "createdAt": "2022-02-17T16:12:22Z",
              "updatedAt": "2022-02-17T16:20:21Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n* octets\\_to\\_point\r\n```",
              "createdAt": "2022-02-17T16:12:34Z",
              "updatedAt": "2022-02-17T16:20:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8401oGl",
          "commit": {
            "abbreviatedOid": "b1fce97"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-17T19:45:24Z",
          "updatedAt": "2022-02-17T19:45:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8401sBT",
          "commit": {
            "abbreviatedOid": "b1fce97"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-17T20:00:55Z",
          "updatedAt": "2022-02-17T20:00:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84012L9",
          "commit": {
            "abbreviatedOid": "b1fce97"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-17T20:45:07Z",
          "updatedAt": "2022-02-17T20:45:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOF8lax84zCEe9",
      "title": "Update signature serialisation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/66",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Likely not going to be the final notation used in this spec, we will probably abstract away the signature encoding and decoding rules into its own function in time, however in the meantime its important to document how the e and s components are actually sent over the wire.",
      "createdAt": "2022-02-18T00:45:22Z",
      "updatedAt": "2022-02-18T01:09:03Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "dc30bb88bf1491659f325fee1b9ae74394ffff04",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-signature-serialization",
      "headRefOid": "b2ddf10a0b8bc4eb2a6e36a6cc62f011387608f9",
      "closedAt": "2022-02-18T01:09:00Z",
      "mergedAt": "2022-02-18T01:09:00Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "17b026f71660b4abe8356df2982c17bc7f61756f"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor update providing important clarification around how a signature is actually encoded or decoded, partially addresses #2, multiple approvals, merging",
          "createdAt": "2022-02-18T01:08:56Z",
          "updatedAt": "2022-02-18T01:08:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8402lJN",
          "commit": {
            "abbreviatedOid": "b2ddf10"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T00:54:13Z",
          "updatedAt": "2022-02-18T00:54:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8402mVN",
          "commit": {
            "abbreviatedOid": "b2ddf10"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T01:03:58Z",
          "updatedAt": "2022-02-18T01:03:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOF8lax84zIGO7",
      "title": "Add basic test vectors for signature cases",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/67",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds a section for test vectors associated to signature generation and verification, includes an automated script that will allow us to update the fixtures via the input JSON files over time.",
      "createdAt": "2022-02-18T22:10:22Z",
      "updatedAt": "2022-02-22T21:12:22Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "17b026f71660b4abe8356df2982c17bc7f61756f",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/signature-fixtures",
      "headRefOid": "080479828e64fbb6658ff3e2d1b83390f8ec60fa",
      "closedAt": "2022-02-22T21:10:51Z",
      "mergedAt": "2022-02-22T21:10:51Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9b314e03d710ed12a627ec8ed74930ff2c0bd3e5"
      },
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "Uhm, I like this so much I wonder what license the TS bits are under such that I might reuse them? ;)\r\n\r\n\"Imitation is the sincerest form of flattery\"",
          "createdAt": "2022-02-18T23:47:26Z",
          "updatedAt": "2022-02-18T23:47:26Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me!",
          "createdAt": "2022-02-18T23:57:17Z",
          "updatedAt": "2022-02-18T23:57:17Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Uhm, I like this so much I wonder what license the TS bits are under such that I might reuse them? ;)\r\n> \r\n> \"Imitation is the sincerest form of flattery\"\r\n\r\nFeel free! Glad it is helpful!",
          "createdAt": "2022-02-19T00:28:10Z",
          "updatedAt": "2022-02-19T00:28:10Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@quartzjer I have updated the tooling script to be licensed under apache 2.0 :)",
          "createdAt": "2022-02-19T00:31:34Z",
          "updatedAt": "2022-02-19T00:31:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead @mikelodder7 would you be able to test these fixtures out against your implementations for correctness?",
          "createdAt": "2022-02-19T03:55:25Z",
          "updatedAt": "2022-02-19T03:55:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "A couple of notes about the current set of test fixtures:\r\n- Using the issuer public key derived generators (because we have not merged in the algorithm described in #38 yet\r\n- Deterministic signatures based on #43  ",
          "createdAt": "2022-02-20T20:05:53Z",
          "updatedAt": "2022-02-20T20:05:53Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I've added a note to the test vectors section that documents the experimental current state of these test vectors",
          "createdAt": "2022-02-20T20:13:30Z",
          "updatedAt": "2022-02-20T20:13:30Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, test vectors are still marked as experimental, merging",
          "createdAt": "2022-02-22T21:10:45Z",
          "updatedAt": "2022-02-22T21:10:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840_c6x",
          "commit": {
            "abbreviatedOid": "0804798"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-21T19:39:03Z",
          "updatedAt": "2022-02-21T19:39:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841EPgb",
          "commit": {
            "abbreviatedOid": "0804798"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T20:06:54Z",
          "updatedAt": "2022-02-22T20:06:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDOF8lax84zYJfy",
      "title": "Document generator creation procedure",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/71",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Initial stab at this attempting to document and resolve #38. In general I was keen to define a generic procedure that could take a seed scoped either globally, issuer or signature specific. Detail about the concrete seed we are using the BLS12-381 cipher suite is still missing.",
      "createdAt": "2022-02-24T01:00:31Z",
      "updatedAt": "2022-03-11T03:32:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "ba9aa770453f1c99c9c32996c5bdae6af6b20ec2",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/create-generators",
      "headRefOid": "ded91eb78672674a7cc4e9fdff2a5cd0dcb0c625",
      "closedAt": "2022-03-11T03:32:53Z",
      "mergedAt": "2022-03-11T03:32:52Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "94d8d8ebd3c10e7a8b97f0c9db364941eabfeb16"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, open for two weeks, merging.",
          "createdAt": "2022-03-11T03:32:41Z",
          "updatedAt": "2022-03-11T03:32:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax841U5ng",
          "commit": {
            "abbreviatedOid": "473e4c4"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T05:44:08Z",
          "updatedAt": "2022-02-28T05:45:38Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Maybe `generators_i =`?",
              "createdAt": "2022-02-28T05:44:08Z",
              "updatedAt": "2022-02-28T05:45:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841WvYH",
          "commit": {
            "abbreviatedOid": "473e4c4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T14:28:40Z",
          "updatedAt": "2022-02-28T14:29:56Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n: The cryptographic hash function that takes as an arbitrary octet string input and returns a point in G1 as defined in [@!I-D.irtf-cfrg-hash-to-curve]. The algorithm first requires selection of the pairing friendly curve and digest algorithm. Once selected, apply the isogeny simplified SWU map to compute a point in G1 using the random oracle method. The domain separation tag value is dst.\r\n```",
              "createdAt": "2022-02-28T14:28:40Z",
              "updatedAt": "2022-02-28T14:29:56Z"
            },
            {
              "originalPosition": 19,
              "body": "Very minor suggestion.",
              "createdAt": "2022-02-28T14:29:49Z",
              "updatedAt": "2022-02-28T14:29:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841YZF0",
          "commit": {
            "abbreviatedOid": "473e4c4"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T20:58:20Z",
          "updatedAt": "2022-02-28T20:58:21Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think this is too long. I would just leave it as \r\n\r\n```\r\nThe cryptographic hash function that takes as an arbitrary octet string input and returns a point in G1 as defined in [@!I-D.irtf-cfrg-hash-to-curve].`",
              "createdAt": "2022-02-28T20:58:21Z",
              "updatedAt": "2022-02-28T20:58:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841eKGJ",
          "commit": {
            "abbreviatedOid": "a383ec4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T05:00:10Z",
          "updatedAt": "2022-03-02T05:00:10Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It is the same text, however I agree that dropping the last sentence is an improvement",
              "createdAt": "2022-03-02T05:00:10Z",
              "updatedAt": "2022-03-02T05:00:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841eKJ2",
          "commit": {
            "abbreviatedOid": "a383ec4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T05:00:39Z",
          "updatedAt": "2022-03-02T05:00:40Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n: The cryptographic hash function that takes as an arbitrary octet string input and returns a point in G1 as defined in [@!I-D.irtf-cfrg-hash-to-curve].\r\n```\r\n\r\nAs per @mikelodder7 suggestion",
              "createdAt": "2022-03-02T05:00:39Z",
              "updatedAt": "2022-03-02T05:00:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841eKYQ",
          "commit": {
            "abbreviatedOid": "17c2886"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T05:02:35Z",
          "updatedAt": "2022-03-02T05:02:35Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "With the merging of #64 agree",
              "createdAt": "2022-03-02T05:02:35Z",
              "updatedAt": "2022-03-02T05:02:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841eKa5",
          "commit": {
            "abbreviatedOid": "17c2886"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T05:02:55Z",
          "updatedAt": "2022-03-02T05:02:56Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "```suggestion\r\n2. for i in 0 to length: generators_i = hash_to_curve_g1(h.read(64), dst)\r\n```",
              "createdAt": "2022-03-02T05:02:55Z",
              "updatedAt": "2022-03-02T05:02:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841nvgv",
          "commit": {
            "abbreviatedOid": "8fc637e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-03T22:49:54Z",
          "updatedAt": "2022-03-03T22:49:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841-gCc",
          "commit": {
            "abbreviatedOid": "ded91eb"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-10T09:50:09Z",
          "updatedAt": "2022-03-10T09:50:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOF8lax84zYUCG",
      "title": "Auto create message generators",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/72",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Builds on #71 to automate re-creating these and including as test vectors in the specification.",
      "createdAt": "2022-02-24T02:35:06Z",
      "updatedAt": "2022-03-11T23:25:27Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "94d8d8ebd3c10e7a8b97f0c9db364941eabfeb16",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/auto-generate-generators",
      "headRefOid": "594bd48fbc553e36891386a51df378f1a90e5ad5",
      "closedAt": "2022-03-11T23:25:24Z",
      "mergedAt": "2022-03-11T23:25:24Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2a7a5f756d5a4ca8d8d6cc63052277a8afdc2f33"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, open over two weeks, builds on #71, merging",
          "createdAt": "2022-03-11T23:25:17Z",
          "updatedAt": "2022-03-11T23:25:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax841NwTf",
          "commit": {
            "abbreviatedOid": "577c898"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T17:59:26Z",
          "updatedAt": "2022-02-24T17:59:27Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "This should have an extra underscore on the end",
              "createdAt": "2022-02-24T17:59:26Z",
              "updatedAt": "2022-02-24T17:59:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841OgoY",
          "commit": {
            "abbreviatedOid": "577c898"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T21:03:02Z",
          "updatedAt": "2022-02-24T21:03:02Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "@andrewwhitehead can you explain why?",
              "createdAt": "2022-02-24T21:03:02Z",
              "updatedAt": "2022-02-24T21:03:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841OhHh",
          "commit": {
            "abbreviatedOid": "577c898"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T21:05:19Z",
          "updatedAt": "2022-02-24T21:05:19Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "In the code it does :)",
              "createdAt": "2022-02-24T21:05:19Z",
              "updatedAt": "2022-02-24T21:05:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841W7dP",
          "commit": {
            "abbreviatedOid": "98b53c6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-28T15:06:56Z",
          "updatedAt": "2022-02-28T15:06:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841YeRL",
          "commit": {
            "abbreviatedOid": "98b53c6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T21:23:25Z",
          "updatedAt": "2022-02-28T21:23:25Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "In the hash to curve spec they leave an underscore at the end as well. Its mostly for consistency.",
              "createdAt": "2022-02-28T21:23:25Z",
              "updatedAt": "2022-02-28T21:23:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841YfCr",
          "commit": {
            "abbreviatedOid": "98b53c6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T21:27:03Z",
          "updatedAt": "2022-02-28T21:27:04Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "The values `(A', Abar, d)` are part of the spk and used to prove possession of the BBS signature, without revealing the signature itself. Note that; `e(A', Pk) = e(Abar, P2)` where `Pk` the signer's public key and P2 the base element in G2 (used to create the signer\u2019s `Pk`, see [SkToPk](#sktopk)). This also serves to bind the spk to the signer's `Pk`.",
              "createdAt": "2022-02-28T21:27:03Z",
              "updatedAt": "2022-02-28T21:27:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842C_xd",
          "commit": {
            "abbreviatedOid": "577c898"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-11T04:33:29Z",
          "updatedAt": "2022-03-11T04:33:30Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Have updated this now, thanks",
              "createdAt": "2022-03-11T04:33:30Z",
              "updatedAt": "2022-03-11T04:33:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842DAQN",
          "commit": {
            "abbreviatedOid": "594bd48"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-11T04:38:17Z",
          "updatedAt": "2022-03-11T04:38:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 77,
      "id": "PR_kwDOF8lax840AnFf",
      "title": "Initial attempt to document the MapMessageToScalar function",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/77",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This PR is primarily designed to help support conversation around design options we have here, it is also an extension of #61 and related to #76.\r\n\r\nCurrently for the core sign, verify, spkGen and spkVerify operations take the inputed messages as a set of octet strings so we either need to.\r\n\r\n1. Clarify that the messages supplied here can be of abitrary value and that MapMessageToScalar becomes an operation executed within sign, verify, spkGen or spkVerify.\r\n2. OR clarify that the messages supplied here have to be valid scalars and that MapMessageToScalar MUST be called on each message prior to calling sign, verify, spkGen or spkVerify.\r\n\r\nThe complexity we are managing is not just that the messages need to be mapped to scalars its also that they could be mapped in multiple ways (e.g message -> scalar as hash or as number) so where ever this definition occurs will also have to account for this optionality (e.g sign would not only take a list of messages to sign but the mapping method for each message)",
      "createdAt": "2022-03-07T00:21:10Z",
      "updatedAt": "2022-03-15T01:55:17Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2a7a5f756d5a4ca8d8d6cc63052277a8afdc2f33",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/map-message-generators",
      "headRefOid": "ee7808de7d3f93b7441f391195d3ac89a494eb3f",
      "closedAt": "2022-03-15T01:55:13Z",
      "mergedAt": "2022-03-15T01:55:12Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "dd367470f08c36a9c8e9e0856d85aac22ac59d97"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This PR needs to be updated to use hash_to_field not hash_to_curve",
          "createdAt": "2022-03-09T04:58:24Z",
          "updatedAt": "2022-03-09T04:58:24Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "PR has been updated to use hash_to_field now",
          "createdAt": "2022-03-11T23:25:56Z",
          "updatedAt": "2022-03-11T23:25:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Remove the _g1 suffix. Scalars are not part of the g1 subgroup. They are their own field. Scalars can be used in either field to scale g1 or G2 groups.\r\n\r\nAddressed",
          "createdAt": "2022-03-13T20:08:15Z",
          "updatedAt": "2022-03-13T20:08:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, PR open a week, no objections, merging",
          "createdAt": "2022-03-15T01:55:03Z",
          "updatedAt": "2022-03-15T01:55:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842H19a",
          "commit": {
            "abbreviatedOid": "8b7bab6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Remove the _g1 suffix. Scalars are not part of the g1 subgroup. They are their own field. Scalars can be used in either field to scale g1 or G2 groups. ",
          "createdAt": "2022-03-12T16:49:06Z",
          "updatedAt": "2022-03-12T16:49:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax842NcRc",
          "commit": {
            "abbreviatedOid": "3006617"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-14T23:06:41Z",
          "updatedAt": "2022-03-14T23:06:42Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "This should have its own `dst` value different but similar to hash_to_curve_g1. I propose `BBS_BLS12381FQ_XOF:SHAKE-256_SSWU_RO`",
              "createdAt": "2022-03-14T23:06:42Z",
              "updatedAt": "2022-03-14T23:06:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842NcWo",
          "commit": {
            "abbreviatedOid": "3006617"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM except we need a DST for hash_to_field. Good job.",
          "createdAt": "2022-03-14T23:07:15Z",
          "updatedAt": "2022-03-14T23:07:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax842Nh4a",
          "commit": {
            "abbreviatedOid": "3006617"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-14T23:50:02Z",
          "updatedAt": "2022-03-14T23:50:02Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Resolved",
              "createdAt": "2022-03-14T23:50:02Z",
              "updatedAt": "2022-03-14T23:50:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842NlD2",
          "commit": {
            "abbreviatedOid": "7a6d75a"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-15T00:16:59Z",
          "updatedAt": "2022-03-15T00:16:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax842NlZN",
          "commit": {
            "abbreviatedOid": "7a6d75a"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-15T00:19:53Z",
          "updatedAt": "2022-03-15T00:19:53Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Maybe \"a cryptographic hash function\" as with hash_to_curve?",
              "createdAt": "2022-03-15T00:19:53Z",
              "updatedAt": "2022-03-15T00:19:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842NtTf",
          "commit": {
            "abbreviatedOid": "7a6d75a"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-15T01:30:44Z",
          "updatedAt": "2022-03-15T01:30:45Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Cool done",
              "createdAt": "2022-03-15T01:30:45Z",
              "updatedAt": "2022-03-15T01:30:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842Nvaj",
          "commit": {
            "abbreviatedOid": "ee7808d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-15T01:49:44Z",
          "updatedAt": "2022-03-15T01:49:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOF8lax840GCmr",
      "title": "Add hash to curve definition for BLS12-381 SHAKE-256 suite",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/81",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As described in #80 currently the [latest hash to curve draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14#section-8.8) does not define a suite for BLS12-381 which uses the extendable output function of SHAKE-256 used by this draft in the CreateGenerators operation defined in #71 and the MapMessageToScalar operation defined in #61 for the [BLS12-381 ciphersuite](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-bls12-381-ciphersuite), this PR establishes that definition so we can point to it.\r\n\r\nNote I would like to review and merge this PR before proceeding with #71 #61",
      "createdAt": "2022-03-08T09:45:00Z",
      "updatedAt": "2022-03-09T00:42:25Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "1b1f8740747deac1950804aca7743bba9b2ffce5",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/hash-to-curve",
      "headRefOid": "edf9cf1d723c7c91d19276b157212a68031f7ed9",
      "closedAt": "2022-03-09T00:42:21Z",
      "mergedAt": "2022-03-09T00:42:21Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "aee0bb43453a9cd972f5347e04735b13d50abbbb"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed in issue, merging as it is blocking PR #71 and #61",
          "createdAt": "2022-03-09T00:42:16Z",
          "updatedAt": "2022-03-09T00:42:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8412hGL",
          "commit": {
            "abbreviatedOid": "edf9cf1"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-08T19:29:53Z",
          "updatedAt": "2022-03-08T19:29:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8413CCN",
          "commit": {
            "abbreviatedOid": "edf9cf1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-08T21:43:09Z",
          "updatedAt": "2022-03-08T21:43:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOF8lax840JXvf",
      "title": "Add hash to curve definition to ciphersuite format definition and BLS12-381 ciphersuite",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/82",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As described above in the title, this defines the usage of the hash to curve suite that was defined in #80 ",
      "createdAt": "2022-03-09T03:16:21Z",
      "updatedAt": "2022-03-09T18:54:10Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "aee0bb43453a9cd972f5347e04735b13d50abbbb",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/add-hash-to-curve-bls12381-suite",
      "headRefOid": "34feafbdd5b5f6e746d3a4486b1cb113dd25b6b1",
      "closedAt": "2022-03-09T18:54:06Z",
      "mergedAt": "2022-03-09T18:54:06Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ba9aa770453f1c99c9c32996c5bdae6af6b20ec2"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, somewhat blocking progress on other PR's, merging",
          "createdAt": "2022-03-09T18:54:02Z",
          "updatedAt": "2022-03-09T18:54:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84137Xz",
          "commit": {
            "abbreviatedOid": "34feafb"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-09T04:34:02Z",
          "updatedAt": "2022-03-09T04:34:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8416TJh",
          "commit": {
            "abbreviatedOid": "34feafb"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-09T14:50:32Z",
          "updatedAt": "2022-03-09T14:50:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOF8lax840bvO4",
      "title": "Fixes definition of MapMessageToScalarAsHash",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/83",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes the in-correct definition for this operation introduced in #61 ",
      "createdAt": "2022-03-15T02:11:26Z",
      "updatedAt": "2022-03-15T02:31:02Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "dd367470f08c36a9c8e9e0856d85aac22ac59d97",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/fix-map-message-definition",
      "headRefOid": "7726a4e84d3348de45d9f3cb556d533acba12b2a",
      "closedAt": "2022-03-15T02:30:59Z",
      "mergedAt": "2022-03-15T02:30:59Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "096452940e3ca92a07e25d2bac832252efe2814f"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor tweak to PR 61, purely editorial, approved, merging",
          "createdAt": "2022-03-15T02:30:55Z",
          "updatedAt": "2022-03-15T02:30:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842NztK",
          "commit": {
            "abbreviatedOid": "7726a4e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-15T02:25:29Z",
          "updatedAt": "2022-03-15T02:25:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 84,
      "id": "PR_kwDOF8lax840b4hN",
      "title": "Change usages of HASH function to use XOF",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/84",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We currently use a HASH function separate to how we use an XOF function in the KeyGen SpkGen and SpkVerify functions, this provides an updated definition resolving H -> HASH instead of having two notations to describe the same thing AND provides a concrete definition for the BLS12-381 cipher suite including how many bytes we draw for the operations.",
      "createdAt": "2022-03-15T03:37:28Z",
      "updatedAt": "2022-03-21T02:15:50Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "096452940e3ca92a07e25d2bac832252efe2814f",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-hash-algorithm-definition",
      "headRefOid": "0667283d9123f94077dec62be55490fe103f2248",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Please hold on reviewing this PR, I am going to restructure how we use the HASH and XOF functions in the spec.",
          "createdAt": "2022-03-15T18:44:57Z",
          "updatedAt": "2022-03-15T18:44:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Have updated this PR to change direction, instead of having both a HASH function and XOF this PR collapses into just using the XOF function.",
          "createdAt": "2022-03-16T03:08:58Z",
          "updatedAt": "2022-03-16T03:08:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Will do, thanks @mikelodder7 ",
          "createdAt": "2022-03-17T17:56:50Z",
          "updatedAt": "2022-03-17T17:56:50Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should we be drawing different number of bytes depending on the EC used since we mod after?? For example, for [bn462](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-bn-curves-for-the-128-bit-s), should we draw at least 74 bytes for 128 bits of security?? (using [this](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-14.html#name-security-considerations) method that @mikelodder7 pointed out and/or lemma 6 from [here](https://eprint.iacr.org/2009/050.pdf))",
          "createdAt": "2022-03-17T20:27:52Z",
          "updatedAt": "2022-03-17T20:27:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Should we be drawing different number of bytes depending on the EC used since we mod after?? For example, for [bn462](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-bn-curves-for-the-128-bit-s), should we draw at least 74 bytes for 128 bits of security?? (using [this](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-14.html#name-security-considerations) method that @mikelodder7 pointed out and/or lemma 6 from [here](https://eprint.iacr.org/2009/050.pdf))\r\n\r\nThanks, @BasileiosKal lets parameterise this in the cipher suite section, can you clarify the need to draw 74 bytes applies when using the BN 462 curve for key gen? Or also the challenge hash?",
          "createdAt": "2022-03-19T23:20:17Z",
          "updatedAt": "2022-03-19T23:20:17Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I have opened #87 so we can look at what this would look like",
          "createdAt": "2022-03-21T02:14:06Z",
          "updatedAt": "2022-03-21T02:14:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> The challenge hash needs to draw 64 bytes and be converted to a scalar to complete the proving protocol. Verify should do the same thing. The reason is the challenge is used to compute the schnorr proofs for the hidden messages.\r\n\r\nOk I will file a seperate PR to make this change",
          "createdAt": "2022-03-21T02:15:50Z",
          "updatedAt": "2022-03-21T02:15:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842Uzgh",
          "commit": {
            "abbreviatedOid": "0667283"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "A couple of notes\r\n\r\n- Let\u2019s remove hkdf for the secret key generation since the Xof serves the same purpose and simplifies things.\r\n- There\u2019s no advantage to hashing the salt first. We should just do H = XOF(salt, ikm), okm= H.read(64), sk = okm mod q, if sk=0 read more bytes and reduce again, output sk\r\n- The challenge hash needs to draw 64 bytes and be converted to a scalar to complete the proving protocol. Verify should do the same thing. The reason is the challenge is used to compute the schnorr proofs for the hidden messages.",
          "createdAt": "2022-03-16T10:40:46Z",
          "updatedAt": "2022-03-16T10:40:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOF8lax840qvRx",
      "title": "BBS spk security against the issuer",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/86",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #75 \r\n\r\nAdding a section to the security considerations to document the fact that a bbs spk is not zero knowledge against the issuer,",
      "createdAt": "2022-03-18T16:45:46Z",
      "updatedAt": "2022-03-21T21:12:35Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "096452940e3ca92a07e25d2bac832252efe2814f",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "untrusted-issuers-security",
      "headRefOid": "6da61caca8044edc97fa2e9fadaff1aa6dafa654",
      "closedAt": "2022-03-21T21:12:35Z",
      "mergedAt": "2022-03-21T21:12:35Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "7463c8157db02ea81f63af9e5576f5889fe9b3d9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on WG call, purely editorial non-normative content, merging",
          "createdAt": "2022-03-21T21:12:30Z",
          "updatedAt": "2022-03-21T21:12:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842im8Z",
          "commit": {
            "abbreviatedOid": "6da61ca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2022-03-19T23:17:57Z",
          "updatedAt": "2022-03-19T23:17:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax842m8UK",
          "commit": {
            "abbreviatedOid": "6da61ca"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-21T18:19:48Z",
          "updatedAt": "2022-03-21T18:19:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOF8lax840temi",
      "title": "[PROPOSAL] refactor key generation procedure",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/87",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "dont-merge-yet"
      ],
      "body": "Initial proposal to refactor the key generation procedure to just rely upon the XOF rather than a combination of a HASH function and HKDF inline with @mikelodder7 proposal [here](https://github.com/decentralized-identity/bbs-signature/pull/84#pullrequestreview-911423521)\r\n\r\nOutstanding questions\r\n- Do we want to continue to support key_info in the key generation, this PR has removed it for now, however we can re-add it\r\n- What guidance do we need to add to the cipher suite definition about calculating the appropriate value for this?",
      "createdAt": "2022-03-21T02:13:33Z",
      "updatedAt": "2022-03-23T21:28:21Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bef218f8eab3d0ff830bda5238cc1d85f2bed077",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-key-gen",
      "headRefOid": "1d50786b1822e969ebc65fe58e7953b10dbceeb2",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal is currently reviewing the usage of HKDF as it would apply here including whether we want to continue to support `key_info` and if so, how.",
          "createdAt": "2022-03-22T01:18:21Z",
          "updatedAt": "2022-03-22T01:18:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This will likely be the same for any XOF -> Scalar generation in the spec like the challenge computation. I think we may want to add a generic function to the spec for this (HashToField for instance), implemented over the specific curve parameters.\r\n\r\nThe algorithm is probably more like this...\r\n\r\n    salt = \"BBS-SIG-KEYGEN-SALT-\"\r\n    h = XOF(salt || IKM)\r\n    SK = 0\r\n    while SK == 0:\r\n        OKM = h.read(okm_key_gen_byte_length)\r\n        SK = OS2IP(OKM) mod q\r\n    return SK\r\n",
          "createdAt": "2022-03-22T23:01:24Z",
          "updatedAt": "2022-03-22T23:01:24Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @andrewwhitehead updated the key gen procedure proposal to be inline with the above.",
          "createdAt": "2022-03-23T04:37:47Z",
          "updatedAt": "2022-03-23T04:37:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Please hold off merging this, more detail on the outstanding things to discuss is outlined above.",
          "createdAt": "2022-03-23T21:28:21Z",
          "updatedAt": "2022-03-23T21:28:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842wT8d",
          "commit": {
            "abbreviatedOid": "1d50786"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-23T11:46:55Z",
          "updatedAt": "2022-03-23T11:46:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDOF8lax840tf8r",
      "title": "[PROPOSAL] generalize map message to scalar operation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/88",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "dont-merge-yet"
      ],
      "body": "Given we use this mapping procedure in the protocol to map values other than messages to scalars, this PR proposes to generalize that operation so we can use it elsewhere (such as for the challenge value as raised by @mikelodder7 [here](https://github.com/decentralized-identity/bbs-signature/pull/84#pullrequestreview-911423521), the alternative way we could do this instead is to use the underlying function of `hash_to_field` in places like this and leave the MapMessageToScalar as is.",
      "createdAt": "2022-03-21T02:26:35Z",
      "updatedAt": "2022-03-22T01:17:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "c4a214d4aa07535af0c0452173e7e06df9d62012",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/generalize-map-value-to-scalar",
      "headRefOid": "384b653852d52be7a25fdecc738a2fb243820f8c",
      "closedAt": "2022-03-22T01:17:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on the WG, we are going to instead leave the definition for MapMessageToScalar as is and just use hash_to_field in required places directly. Therefore dis-regard this PR",
          "createdAt": "2022-03-21T21:30:03Z",
          "updatedAt": "2022-03-21T21:30:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing this PR now, have opened issue #89 to track the progress of resolving the original issue that brought this PR about in #84 ",
          "createdAt": "2022-03-22T01:17:25Z",
          "updatedAt": "2022-03-22T01:17:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 91,
      "id": "PR_kwDOF8lax841VRk1",
      "title": "Updating the spk security consideration",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/91",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updating and re-closing issue #75 \r\n\r\nBased on the discussion in the above issue, the method originally proposed was wrong and any other method does not work on type 3 pairings. Updating the section accordingly.\r\n",
      "createdAt": "2022-03-30T18:32:28Z",
      "updatedAt": "2022-03-31T20:01:47Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bef218f8eab3d0ff830bda5238cc1d85f2bed077",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "issue-75",
      "headRefOid": "2e27cc2b576f6b6e197ecd59e3e3bcf4b92b126a",
      "closedAt": "2022-03-31T20:01:47Z",
      "mergedAt": "2022-03-31T20:01:47Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "cf614ee5157c4e72bfd80f639e110e45261a6299"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, informational, merging ",
          "createdAt": "2022-03-31T20:01:42Z",
          "updatedAt": "2022-03-31T20:01:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax843OjOx",
          "commit": {
            "abbreviatedOid": "2e27cc2"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-30T18:39:38Z",
          "updatedAt": "2022-03-30T18:39:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843Prz3",
          "commit": {
            "abbreviatedOid": "2e27cc2"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T00:27:41Z",
          "updatedAt": "2022-03-31T00:27:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843Q8-W",
          "commit": {
            "abbreviatedOid": "2e27cc2"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T08:27:20Z",
          "updatedAt": "2022-03-31T08:27:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDOF8lax841VX2u",
      "title": "Collapsing random element generation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/92",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A suggestion to group together some of the random element generation, to make the displayed algorithms a little smaller. This is just for readability and displaying purposes.",
      "createdAt": "2022-03-30T18:57:34Z",
      "updatedAt": "2022-04-04T21:15:31Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bef218f8eab3d0ff830bda5238cc1d85f2bed077",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "notation-update",
      "headRefOid": "8f9d712803cd597ce2f361b4bc59cf08937349d0",
      "closedAt": "2022-04-04T21:15:31Z",
      "mergedAt": "2022-04-04T21:15:31Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "52db5c7a02f5b8ab82816c923617ed16f95641a9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 04/04/2022, multiple approvals, purely editorial change to improve readability, merging",
          "createdAt": "2022-04-04T21:15:27Z",
          "updatedAt": "2022-04-04T21:15:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax843Q8wu",
          "commit": {
            "abbreviatedOid": "6111fbd"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T08:26:41Z",
          "updatedAt": "2022-03-31T08:26:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843ep_d",
          "commit": {
            "abbreviatedOid": "6111fbd"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-04T18:20:59Z",
          "updatedAt": "2022-04-04T18:20:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843erPf",
          "commit": {
            "abbreviatedOid": "6111fbd"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-04T18:25:35Z",
          "updatedAt": "2022-04-04T18:25:35Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Can you please add a check for rand_el = 0 like above",
              "createdAt": "2022-04-04T18:25:35Z",
              "updatedAt": "2022-04-04T18:25:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax843e7P_",
          "commit": {
            "abbreviatedOid": "6111fbd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-04T19:26:58Z",
          "updatedAt": "2022-04-04T19:26:58Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Done! Thank you!",
              "createdAt": "2022-04-04T19:26:58Z",
              "updatedAt": "2022-04-04T19:26:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOF8lax841XYXa",
      "title": "Rework of the introduction",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/93",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds a rework of the introduction to describe the two key properties enabled by the core scheme, includes a simple asci art diagram to describe how the key operations are used and by who",
      "createdAt": "2022-03-31T03:24:19Z",
      "updatedAt": "2022-04-01T05:06:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bef218f8eab3d0ff830bda5238cc1d85f2bed077",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/rework-intro",
      "headRefOid": "cddb0864a779a0c857df9fad9efac5bd53e68026",
      "closedAt": "2022-04-01T05:06:19Z",
      "mergedAt": "2022-04-01T05:06:19Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "f4067e5f05578d8a6a82f234d1cf63f917e604b1"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-04-01T05:06:30Z",
          "updatedAt": "2022-04-01T05:06:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax843SZCg",
          "commit": {
            "abbreviatedOid": "22409da"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T13:24:22Z",
          "updatedAt": "2022-03-31T13:24:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843SZ2M",
          "commit": {
            "abbreviatedOid": "22409da"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-31T13:26:29Z",
          "updatedAt": "2022-03-31T13:26:29Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Can be one word `Unlinkable`",
              "createdAt": "2022-03-31T13:26:29Z",
              "updatedAt": "2022-03-31T13:26:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax843Ud1n",
          "commit": {
            "abbreviatedOid": "22409da"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T20:01:18Z",
          "updatedAt": "2022-03-31T20:01:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843UeP_",
          "commit": {
            "abbreviatedOid": "22409da"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-31T20:02:55Z",
          "updatedAt": "2022-03-31T20:02:56Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n**Unlinkable Presentations** - The proofs generated by the scheme are known as a signature proof of knowledge meaning a verifying party in receipt of a proof is unable to determine which signature was used to generate the proof.\r\n```",
              "createdAt": "2022-03-31T20:02:55Z",
              "updatedAt": "2022-03-31T20:02:56Z"
            }
          ]
        }
      ]
    }
  ]
}