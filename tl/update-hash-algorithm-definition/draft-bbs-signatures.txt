



none                                                           M. Lodder
                                                                 CryptID
                                                               T. Looker
                                                                   Mattr
                                                            A. Whitehead
                                                           16 March 2022


                        The BBS Signature Scheme
                          draft-bbs-signatures

Abstract

   BBS is a digital signature scheme categorized as a form of short
   group signature that supports several novel properties.  Notably, the
   scheme supports signing multiple messages whilst producing a single
   output digital signature.  Through this capability, the possessor of
   a signature is able to derive proofs that selectively reveal subsets
   of the originally signed set of messages, whilst preserving the
   verifiable authenticity and integrity of the messages.  Furthermore,
   these derived proofs are said to be zero-knowledge in nature as they
   do not reveal the underlying signature; instead, what they reveal is
   a proof of knowledge of the undisclosed signature.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Source for this draft and an issue tracker can be found at
   https://github.com/decentralized-identity/bbs-signature.

Table of Contents

   1.  Introduction
     1.1.  Terminology
     1.2.  Notation
     1.3.  Organization of this document
   2.  Conventions
   3.  Scheme Definition
     3.1.  Parameters
     3.2.  Considerations
       3.2.1.  Subgroup Selection
       3.2.2.  Messages and generators
     3.3.  Operations
       3.3.1.  KeyGen
       3.3.2.  SkToPk
       3.3.3.  KeyValidate
       3.3.4.  Sign
       3.3.5.  Verify
       3.3.6.  SpkGen
       3.3.7.  SpkVerify
       3.3.8.  CreateGenerators
   4.  Security Considerations
     4.1.  Validating public keys
     4.2.  Skipping membership checks
     4.3.  Side channel attacks
     4.4.  Randomness considerations
     4.5.  Presentation message selection
     4.6.  Implementing hash_to_curve_g1
     4.7.  Use of Contexts
     4.8.  Choice of underlying curve
   5.  Ciphersuites
     5.1.  Ciphersuite Format
     5.2.  BLS12-381 Ciphersuite
       5.2.1.  Test Vectors
   6.  IANA Considerations
   7.  Normative References
   8.  Informative References
   Appendix A.  Appendix
     A.1.  BLS12-381 hash_to_curve definition using SHAKE-256
       A.1.1.  BLS12-381 G1
       A.1.2.  BLS12-381 G2
     A.2.  Usecases
       A.2.1.  Non-correlating Security Token
       A.2.2.  Improved Bearer Security Token
       A.2.3.  Hardware Attestations
       A.2.4.  Selectively Disclosure Enabled Identity Assertions
       A.2.5.  Privacy preserving bound signatures
     A.3.  Additional BLS12-381 Ciphersuite Test Vectors
       A.3.1.  Modified Message Signature
       A.3.2.  Extra Unsigned Message Signature
       A.3.3.  Missing Message Signature
       A.3.4.  Reordered Message Signature
       A.3.5.  Wrong Public Key Signature
   Authors' Addresses

1.  Introduction

   A digital signature scheme is a fundamental cryptographic primitive
   that is used to provide data integrity and verifiable authenticity in
   various protocols.  The core premise of digital signature technology
   is built upon asymmetric cryptography where-by the possessor of a
   private key is able to sign a message, where anyone in possession of
   the corresponding public key matching that of the private key is able
   to verify the signature.

   However, traditional digital signature schemes require both the
   signature and the entire message to be disclosed during verification,
   constraining its usage in certain applications.

   The BBS Signature scheme on the other hand allows a party to sign
   multiple messages and produce a single output signature.This then
   allows the possessor a signature to derive proofs from it that
   selectively reveal from the originally signed set of messages, whilst
   continuing to retain the underlying core properties of a digital
   signature which are verifiable authenticity and integrity of the
   revealed messages back to the original signer.  Futhermore these
   derived proofs are said to be zero-knowledge in nature as they do not
   reveal the underlying signature, instead the generated proof is
   considered a proof of knowledge of the signature which is beneficial
   for applications where revealing the underlying signature can cause
   undesirable correlation.

1.1.  Terminology

   The following terminology is used throughout this document:

   SK  The secret key for the signature scheme.

   PK  The public key for the signature scheme.

   L  The total number of messages that the signature scheme can sign.

   R  The set of message indices that are retained or hidden in a
      signature proof of knowledge.

   D  The set of message indices that are disclosed in a signature proof
      of knowledge.

   msg  An input message to be signed by the signature scheme.

   generator  A valid point on the selected sub-group of the curve being
      used that is used to commit a value.

   H[i]  The generator corresponding to a given msg.

   H0  A generator for the blinding value in the signature.

   signature  The digital signature output.

   commitment  A pedersen commitment composed of 1 or more messages.

   nonce  A cryptographic nonce

   presentation_message (pm)  A message generated and bound to the
      context of a specific spk.

   spk  Zero-Knowledge Signature Proof of Knowledge.

   nizk  A non-interactive zero-knowledge proof from fiat-shamir
      heuristic.

   dst  The domain separation tag.

   I2OSP  As defined by Section 4 of [RFC8017]

   OS2IP  As defined by Section 4 of [RFC8017].

1.2.  Notation

   The following notation and primitives are used:

   a || b  Denotes the concatenation of octet strings a and b.

   I J  For sets I and J, denotes the difference of the two sets i.e.,
      all the elements of I that do not appear in J, in the same order
      as they were in I.

   [n]: Denotes all integers from 1 to n.

   Terms specific to pairing-friendly elliptic curves that are relevant
   to this document are restated below, originally defined in
   [I-D.irtf-cfrg-pairing-friendly-curves]

   E1, E2  elliptic curve groups defined over finite fields.  This
      document assumes that E1 has a more compact representation than
      E2, i.e., because E1 is defined over a smaller field than E2.

   G1, G2  subgroups of E1 and E2 (respectively) having prime order p.

   GT  a subgroup, of prime order p, of the multiplicative group of a
      field extension.

   e  G1 x G2 -> GT: a non-degenerate bilinear map.

   q  The prime order of the G1 and G2 subgroups.

   P1, P2  points on G1 and G2 respectively.  For a pairing-friendly
      curve, this document denotes operations in E1 and E2 in additive
      notation, i.e., P + Q denotes point addition and x * P denotes
      scalar multiplication.  Operations in GT are written in
      multiplicative notation, i.e., a * b is field multiplication.

   Identity_G1, Identity_G1  The identity element for the G1 and G2
      subgroups respectively.

   hash_to_curve_g1(ostr) -> P  A cryptographic hash function that takes
      as an arbitrary octet string input and returns a point in G1 as
      defined in [I-D.irtf-cfrg-hash-to-curve].

   point_to_octets(P) -> ostr  returns the canonical representation of
      the point P as an octet string.  This operation is also known as
      serialization.

   octets_to_point(ostr) -> P  returns the point P corresponding to the
      canonical representation ostr, or INVALID if ostr is not a valid
      output of point_to_octets.  This operation is also known as
      deserialization.

   subgroup_check(P) -> VALID or INVALID  returns VALID when the point P
      is an element of the subgroup of order p, and INVALID otherwise.
      This function can always be implemented by checking that p * P is
      equal to the identity element.  In some cases, faster checks may
      also exist, e.g., [Bowe19].

1.3.  Organization of this document

   This document is organized as follows:

   *  Section 3 defines the BBS signature scheme including any
      parameters required to define a concrete ciphersuite.

   *  Section 4 defines security considerations associated to the
      signature scheme.

   *  Section 5 defines the format of a ciphersuite alongside a concrete
      ciphersuite based on the BLS12-381 curve.

2.  Conventions

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in [RFC2119].

3.  Scheme Definition

   This section defines the BBS signature scheme, including the
   parameters required to define a concrete cipher-suite.

3.1.  Parameters

   The schemes operations defined in Section 3.3 depend the following
   parameters:

   *  A pairing-friendly elliptic curve, plus associated functionality
      given in Section 1.4.

   *  XOF, a cryptographically secure extendable-output function like
      SHAKE128 or SHAKE256.  XOF input is an octet string and outputs
      any desirable amount of bytes using the .read(int) method.

   *  PRF(n): a pseudo-random function similar to [RFC4868].  Returns n
      pseudo randomly generated bytes.

3.2.  Considerations

3.2.1.  Subgroup Selection

   In definition of this signature scheme there are two possible
   variations based upon the sub-group selection, namely where public
   keys are defined in G2 and signatures in G1 OR the opposite where
   public keys are defined in G1 and signatures in G2.  Some pairing
   cryptography based digital signature schemes such as
   [I-D.irtf-cfrg-bls-signature] elect to allow for both variations,
   because they optimize for different things.  However, in the case of
   this scheme, due to the operations involved in both signature and
   proof generation being computational in-efficient when performed in
   G2 and in the pursuit of simplicity, the scheme is limited to a
   construction where public keys are in G2 and signatures in G1.

3.2.2.  Messages and generators

   Throughout the operations of this signature scheme, each message that
   is signed is paired with a specific generator (point in G1).
   Specifically, if a generator H_1 is raised to the power of msg_1
   during signing, then H_1 should be raised to the power of msg_1 in
   all other operations as well (signature verification, proof
   generation and proof verification).  For simplicity, each function
   will take as input the list of generators to be used with the
   messages.  Those generators can be any distinct element from the
   generators list H.  Applications for efficiency can elect to pass the
   indexes of those generators to the list H instead.  Care must be
   taken for the correct generator to be raised to the correct message
   in that case.

3.3.  Operations

3.3.1.  KeyGen

   The KeyGen algorithm generates a secret key SK deterministically from
   a secret octet string IKM.

   KeyGen uses an HKDF [RFC5869] instantiated with the hash function H.

   For security, IKM MUST be infeasible to guess, e.g., generated by a
   trusted source of randomness.

   IKM MUST be at least 32 bytes long, but it MAY be longer.

   Because KeyGen is deterministic, implementations MAY choose either to
   store the resulting SK or to store IKM and call KeyGen to derive SK
   when necessary.

   KeyGen takes an optional parameter, key_info.  This parameter MAY be
   used to derive multiple independent keys from the same IKM.  By
   default, key_info is the empty string.

SK = KeyGen(IKM)

Inputs:

- IKM, a secret octet string. See requirements above.

Outputs:

- SK, a uniformly random integer such that 0 < SK < q.

Parameters:

- key_info, an optional octet string. if this is not supplied, it MUST default to an empty string.

Definitions:

- HKDF-Extract is as defined in [@!RFC5869], instantiated with hash H.
- HKDF-Expand is as defined in [@!RFC5869], instantiated with hash H.
- I2OSP and OS2IP are as defined in [@!RFC8017], Section 4.
- L is the integer given by ceil((3 * ceil(log2(q))) / 16).
- "BBS-SIG-KEYGEN-SALT-" is an ASCII string comprising 20 octets.

Procedure:
1. salt = "BBS-SIG-KEYGEN-SALT-"

2. SK = 0

3. while SK == 0:

4.     h = XOF(salt)

5.     hashed_salt = h.read(32)

6.     PRK = HKDF-Extract(hashed_salt, IKM || I2OSP(0, 1))

7.     OKM = HKDF-Expand(PRK, key_info || I2OSP(L, 2), L)

8.     SK = OS2IP(OKM) mod q

9. return SK

3.3.2.  SkToPk

   SkToPk algorithm takes a secret key SK and outputs a corresponding
   public key.

   PK = SkToPk(SK)

   Inputs:

   - SK, a secret integer such that 0 < SK < q

   Outputs:

   - PK, a public key encoded as an octet string

   Procedure:

   1. W = SK * P2

   2. PK = W

   3. return point_to_octets(PK)

3.3.3.  KeyValidate

   KeyValidate checks if the public key is valid.

   As an optimization, implementations MAY cache the result of
   KeyValidate in order to avoid unnecessarily repeating validation for
   known keys.

   result = KeyValidate(PK)

   Inputs:

   - PK, a public key in the format output by SkToPk.

   Outputs:

   - result, either VALID or INVALID

   Procedure:

   1. (W, H0, H) = octets_to_point(PK)

   2. If W == Identity_G2, return INVALID

   3. result = subgroup_check(W) && subgroup_check(H0)

   4. for i in 0 to len(H): result &= subgroup_check(H[i])

   5. return result

3.3.4.  Sign

   Sign computes a signature from SK, PK, over a vector of messages.
   This method describes deterministic signing.  For threshold signing,
   XOF can be replaced with a PRF due to the insecurity of deterministic
   threshold signing.

   signature = Sign(SK, PK, (msg_1,..., msg_L), (H_1,..., H_L))

   Inputs:

   - msg_1,...,msg_L, octet strings. Messages to be signed.
   - H_1,..., H_L, points of G1. Generators used to sign the messages.
   - SK, a secret key output from KeyGen
   - PK, a public key output from SkToPk

   Outputs:

   - signature, an octet string

   Procedure:

   1. (W, H0, H) = octets_to_point(PK)

   2. h = XOF(SK  || msg[i] || ... || msg[L])

   3. k = h.read(64)

   4. e = OS2IP(k) mod q. If e = 0, go back to step 3.

   5. r = h.read(64)

   6. s = OS2IP(r) mod q. If s = 0, go back to step 5.

   7. B = P1 + H0 * s + H_1 * msg_1 + ... + H_L * msg_L

   8. A = B * (1 / (SK + e))

   9. signature = (point_to_octets_min(A), e, s)

   10. return signature

3.3.5.  Verify

   Verify checks that a signature is valid for the octet string messages
   under the public key.

result = Verify(PK, (msg_1,..., msg_L), (H_1,..., H_L), signature)

Inputs:

- msg_1,..., msg_L, octet strings. Messages in input to Sign.
- H_1,..., H_L, points of G1. The generators in input to Sign.
- signature, octet string.
- PK, a public key in the format output by SkToPk.

Outputs:

- result, either VALID or INVALID.

Procedure:

1. (A, e, s) = (octets_to_point(signature.A), OS2IP(signature.e), OS2IP(signature.s))

2. pub_key = octets_to_point(PK)

3. if subgroup_check(A) is INVALID

4. if KeyValidate(pub_key) is INVALID

5. B = P1 + H0 * s + H_1 * msg_1 + ... + H_L * msg_L

6. C1 = e(A, W + P2 * e)

7. C2 = e(B, P2)

8. return C1 == C2

3.3.6.  SpkGen

   A signature proof of knowledge generating algorithm that creates a
   zero-knowledge proof of knowledge of a signature while selectively
   disclosing messages from a signature given a vector of messages, a
   vector of indices of the revealed messages, the signer's public key,
   and a presentation message.

   If an application chooses to pass the indexes of the generators
   instead, then it will also need to pass the indexes of the generators
   corresponding to the revealed messages.

spk = SpkGen(PK, (msg_1,..., msg_L), (H_1,..., H_L), RevealedIndexes, signature, pm)

Inputs:

- PK, octet string in output form from SkToPk
- msg_1,..., msg_L, octet strings. Messages in input to Sign.
- H_1,..., H_L, points of G1. The generators in input to Sign.
- RevealedIndexes, vector of unsigned integers. Indexes of revealed messages.
- signature, octet string in output form from Sign
- pm, octet string

Outputs:

- spk, octet string

Procedure:

1. (A, e, s) = (octets_to_point(signature.A), OS2IP(signature.e), OS2IP(signature.s))

2. (i1, i2,..., iR) = RevealedIndexes

3. (j1, j2,..., jU) = [L] \ RevealedIndexes

4. if subgroup_check(A) is INVALID abort

5. if KeyValidate(PK) is INVALID abort

6. b = P1 + H0 * s + H_1 * msg_1 + ... + H_L * msg_L

7. r1 = HASH(PRF(8*ceil(log2(q)))) mod q

8. r2 = HASH(PRF(8*ceil(log2(q)))) mod q

9. e~ = HASH(PRF(8*ceil(log2(q)))) mod q

10. r2~ = HASH(PRF(8*ceil(log2(q)))) mod q

11. r3~ = HASH(PRF(8*ceil(log2(q)))) mod q

12. s~ = HASH(PRF(8*ceil(log2(q)))) mod q

13. r3 = r1 ^ -1 mod q

14. for j in (j1, j2,..., jU): m~_j = HASH(PRF(8*ceil(log2(q)))) mod q

15. A' = A * r1

16. Abar = A' * (-e) + B * r1

17. D = B * r1 + h0 * r2

18. s' = s + r2 * r3

19. C1 = A' * e~ + H0 * r2~

20. C2 = D * (-r3~) + H0 * s~ + H_j1 * m~_j1 + ... + H_jU * m~_jU

21. h = XOF(PK || Abar || A' || D || C1 || C2 || pm)

22. c_hash = h.read(32)

22. e^ = e~ + c_hash * e

23. r2^ = r2~ + c_hash * r2

24. r3^ = r3~ + c_hash * r3

25. s^ = s~ + c_hash * s'

26. for j in (j1, j2,..., jU): m^_j = m~_j + c_hash * msg_j

27. spk = ( A', Abar, D, c_hash, e^, r2^, r3^, s^, (m^_j1, ..., m^_jU))

28. return spk

3.3.6.1.  Algorithmic Explanation

   The following section provides an explanation of how the Signature
   Proof Of Knowledge Generation (SpkGen) works.

   Let the prover be in possession of a BBS signature (A, e, s) with A =
   B * (1/(e + Sk)) where Sk the signer's secret key and,

   B = P1 + h0 * s + h[1] * msg_1 + ... + h[L] * msg_L

   (without loss of generality we assume that the messages and
   generators are indexed from 0 to L).  Let (i1,...,iR) be the indexes
   of generators corresponding to messages the prover wants to disclose
   and (j1,...,jU) be the indexes corresponding to undisclosed messages
   (i.e., (j1,...,jU) = [L] \ (i1,...,iR)).  To prove knowledge of a
   signature on the disclosed messages, work as follows,

   *  Randomize the signature (A, e, s), by taking uniformly random r1,
      r2 in [1, q-1], and calculate,

      1.  A' = A * r1,
      2.  Abar = A' * (-e) + B * r1
      3.  D = B * r1 + H0 * r2.

   Also set,

       4.  r3 = r1 ^ -1 mod q
       5.  s' = s + r2 * r3.

   The values (A', Abar, d) will be part of the spk and are used to
   prove possession of a BBS signature, without revealing the signature
   itself.  Note that; e(A', Pk) = e(Abar, P2) where Pk the signer's
   public key and P2 the base element in G2 (used to create the signer's
   Pk, see SkToPk (#sktopk)).  This also serves to bind the spk to the
   signer's Pk.

   *  Set the following,

      1.  C1 = Abar - D
      2.  C2 = P1 +  H_i1 * msg_i1 + ... + H_iR * msg_iR

   Create a non-interactive zero-knowledge generalized Schnorr proof of
   knowledge (nizk) of the values e, r2, r3, s' and msg_j1,...,msg_jU
   (the undisclosed messages) so that both of the following equalities
   hold,

    EQ1.  C1 = A' * (-e) - H0 * r2
    EQ2.  C2 = D * (-r3) + H0 * s' + H_j1 * msg_j1 + ... + H_jU * msg_jU.

   If both EQ1 and EQ2 hold, and e(A', Pk) = e(Abar, P2), an extractor
   can return a valid BBS signature from the signers Sk, on the
   disclosed messages.  The spk returned is (A', Abar, d, nizk).  To
   validate the spk, a verifier checks that e(A', Pk) = e(Abar, P2) and
   verifies nizk.

3.3.7.  SpkVerify

   SpkVerify checks if a signature proof of knowledge is VALID given the
   proof, the signer's public key, a vector of revealed messages, a
   vector with the indices of these revealed messages, and the
   presentation message used in SpkGen.

result = SpkVerify(spk, PK, (msg_i1,..., msg_iR), (H_1,..., H_L), RevealedIndexes, pm)

Inputs:

- spk, octet string.
- PK, octet string in output form from SkToPk.
- msg_i1,..., msg_iR, octet strings. The revealed messages in input to spkGen.
- H_1,..., H_L, points of G1. The generators in input to Sign.
- RevealedIndexes, vector of unsigned integers. Indexes of revealed messages.
- pm, octet string

Outputs:

- result, either VALID or INVALID.

Procedure:

1. if KeyValidate(PK) is INVALID

2. (i1, i2, ..., iR) = RevealedIndexes

3. (j1, j2, ..., jU) = [L]\RevealedIndexes

4. (A', Abar, D, c_hash, e^, r2^, r3^, s^, (m^_j1,...,m^_jU)) = spk

5. C1 = (Abar - D) * c_hash + A' * e^ + H0 * r2^

6. T = P1 + H_i1 * msg_i1 + ... H_iR * msg_iR

7. C2 = T * c_hash + D * (-r3^) + H0 * s^ + H_j1 * m^_j1 + ... + H_jU * m^_jU

8. h = XOF(PK || Abar || A' || D || C1 || C2 || pm)

9. cv_hash = h.read(32)

10. if c_hash != cv_hash return INVALID

11. if A' == 1 return INVALID

12. if e(A', W) * e(Abar, -P2) != 1 return INVALID

13. return VALID

3.3.8.  CreateGenerators

   The CreateGenerators operation defines how to create a set of
   generators that form a part of the public parameters used by the BBS
   Signature scheme to accomplish operations such as sign, verify,
   spkgen and spkverify.

   _Note_ The scope in which the seed used below is determined, is still
   an active conversation in the working group see Section 5 for the
   current method being used.

generators = CreateGenerators(dst, message_generator_seed, length);

Inputs:

dst, octet string - Domain Separation Tag
message_generator_seed, octet string
length, unsigned integer - Number of generators to create from the seed and dst

Outputs:

- generators, an array of generators

Procedure:

1. h = XOF(seed)

2. for i in 0 to length:

3.    generator_i = Identity_G1

4.    while(generator_i == Identity_G1 or generator_i == P1)

5.        candidate = hash_to_curve_g1(h.read(64), dst)

6.        if candidate not in generators: generator_i = candidate

3. return generators

4.  Security Considerations

4.1.  Validating public keys

   All algorithms in Section 2 that operate on points in public keys
   require first validating those keys.  For the sign, verify and proof
   schemes, the use of KeyValidate is REQUIRED.

4.2.  Skipping membership checks

   Some existing implementations skip the subgroup_check invocation in
   Verify (Section 2.8), whose purpose is ensuring that the signature is
   an element of a prime-order subgroup.  This check is REQUIRED of
   conforming implementations, for two reasons.

   1.  For most pairing-friendly elliptic curves used in practice, the
       pairing operation e (Section 1.3) is undefined when its input
       points are not in the prime-order subgroups of E1 and E2.  The
       resulting behavior is unpredictable, and may enable forgeries.

   2.  Even if the pairing operation behaves properly on inputs that are
       outside the correct subgroups, skipping the subgroup check breaks
       the strong unforgeability property [ADR02].

4.3.  Side channel attacks

   Implementations of the signing algorithm SHOULD protect the secret
   key from side-channel attacks.  One method for protecting against
   certain side-channel attacks is ensuring that the implementation
   executes exactly the same sequence of instructions and performs
   exactly the same memory accesses, for any value of the secret key.
   In other words, implementations on the underlying pairing-friendly
   elliptic curve SHOULD run in constant time.

4.4.  Randomness considerations

   The IKM input to KeyGen MUST be infeasible to guess and MUST be kept
   secret.  One possibility is to generate IKM from a trusted source of
   randomness.  Guidelines on constructing such a source are outside the
   scope of this document.

   Secret keys MAY be generated using other methods; in this case they
   MUST be infeasible to guess and MUST be indistinguishable from
   uniformly random modulo q.

   BBS signatures are nondeterministic, meaning care must be taken
   against attacks arising from signing with bad randomness, for
   example, the nonce reuse attack on ECDSA [HDWH12].  It is RECOMMEDNED
   that the nonces and presentation messages used in this specification
   are chosen at random from a trusted source of randomness (see
   "Presentation message selection" section below for additional
   considerations).

   BlindSign as discussed in 2.10 uses randomness from two parties so
   care MUST be taken that both sources of randomness are trusted.  If
   one party uses weak randomness, it could compromise the signature.

   When a trusted source of randomness is used, signatures and proofs
   are much harder to forge or break due to the use of multiple nonces.

4.5.  Presentation message selection

   The signature proofs of knowledge generated in this specification are
   created using a specified presentation message.  A verifier-specified
   cryptographically random value (e.g., a nonce) featuring in the
   presentation message provides strong protections against replay
   attacks, and is RECOMMENDED in most use cases.  In some settings,
   proofs can be generated in a non-interactive fashion, in which case
   verifiers MUST be able to verify the uniqueness of the presentation
   message values.

4.6.  Implementing hash_to_curve_g1

   The security analysis models hash_to_curve_g1 as random oracles.  It
   is crucial that these functions are implemented using a
   cryptographically secure hash function.  For this purpose,
   implementations MUST meet the requirements of
   [I-D.irtf-cfrg-hash-to-curve].

   In addition, ciphersuites MUST specify unique domain separation tags
   for hash_to_curve.  Some guidance around defining this can be found
   in Section 5.

4.7.  Use of Contexts

   Contexts can be used to separate uses of the protocol between
   different protocols (which is very hard to reliably do otherwise) and
   between different uses within the same protocol.  However, the
   following SHOULD be kept in mind:

   The context SHOULD be a constant string specified by the protocol
   using it.  It SHOULD NOT incorporate variable elements from the
   message itself.

   Contexts SHOULD NOT be used opportunistically, as that kind of use is
   very error prone.  If contexts are used, one SHOULD require all
   signature schemes available for use in that purpose support contexts.

   Contexts are an extra input, which percolate out of APIs; as such,
   even if the signature scheme supports contexts, those may not be
   available for use.  This problem is compounded by the fact that many
   times the application is not invoking the signing, verification, and
   proof functions directly but via some other protocol.

   The ZKP protocols use nonces which MUST be different in each context.

4.8.  Choice of underlying curve

   BBS signatures can be implemented on any pairing-friendly curve.
   However care MUST be taken when selecting one that is appropriate,
   this specification defines a profile for using the BLS12-381 curve in
   Section 5 which as a curve currently achieves close to 128-bit
   security.

5.  Ciphersuites

   This section defines the format for a BLS ciphersuite.  It also gives
   concrete ciphersuites based on the BLS12-381 pairing-friendly
   elliptic curve [I-D.irtf-cfrg-pairing-friendly-curves].

5.1.  Ciphersuite Format

   *  XOF: A cryptographically secure extendable-output function like
      SHAKE128 or SHAKE256.

   *  point_to_octets: A function that returns the canonical
      representation of the point P as an octet string.

   *  octets_to_point: A function that returns the point P corresponding
      to the canonical representation ostr, or INVALID if ostr is not a
      valid output of point_to_octets.

   *  hash_to_curve_g1: A cryptographic hash function that takes as an
      arbitrary octet string input and returns a point in G1 as defined
      in [I-D.irtf-cfrg-hash-to-curve].

   *  dst: Domain separation tag used in the hash_to_curve_g1 operation

   *  message_generator_seed: The seed used to generate the message
      generators which form part of the public parameters used by the
      BBS signature scheme, Note there are multiple possible scopes for
      this seed including; a globally shared seed (where the resulting
      message generators are common across all BBS signatures); a signer
      specific seed (where the message generators are specific to a
      signer); signature specific seed (where the message generators are
      specific per signature).  The ciphersuite MUST define this seed OR
      how to compute it as a pre-cursor operations to any others.

5.2.  BLS12-381 Ciphersuite

   XOF  SHAKE-256 as defined in [SHA3]

   point_to_octets  follows the format documented in Appendix C section
      1 of [I-D.irtf-cfrg-pairing-friendly-curves].

   octets_to_point  follows the format documented in Appendix C section
      2 of [I-D.irtf-cfrg-pairing-friendly-curves].

   hash_to_curve_g1  follows the suite defined in Appendix A.1 for the
      G1 subgroup

   dst  "BBS_BLS12381G1_XOF:SHAKE-256_SSWU_RO_"

   message_generator_seed  A global seed value of
      "BBS_BLS12381G1_XOF:SHAKE-256_SSWU_RO_MESSAGE_GENERATOR_SEED"
      which is used by the Section 3.3.8 operation to compute the
      required set of message generators.

5.2.1.  Test Vectors

   The following section details a basic set of test vectors that can be
   used to confirm an implementations correctness

   *NOTE* All binary data below is represented as octet strings encoded
   in hexadecimal format

   *NOTE* These fixtures are a work in progress and subject to change

   Further fixtures are available in Appendix A.3

5.2.1.1.  Message Generators

   Following the procedure defined in Section 3.3.8 with an input seed
   value of

   BBS_BLS12381G1_XOF:SHAKE-256_SSWU_RO_MESSAGE_GENERATOR_SEED

   a dst of

   BBS_BLS12381G1_XOF:SHAKE-256_SSWU_RO_

   and a length value of 10

   Outputs the following values

95c10133d125fd556a14b96b2f0607b757d41fbce15b61fc64ab60c4c9e3b268469abc41fb7713dc4034d3fee18eed6f

a410a9c0fa4f48e14dc9f3cc11164625f98f5cc9c0e6f7690008ab6c83a073a63811caf1598d4094593bd1233bdf228e

861b44ba4897f9b10b926c22c60e09c7234c76b75bfb15bcb786ee7c26430dbfe6576ffbfd2cb88ba960847b134c17f2

a7f1b70c9bf41f7b686c19198fa29a2b55088e719ae1b5219046121c1d70e1d7f2eccc5ca0e6f1fb8073fac69752b455

b06b73e3cfa6003d39fdaad503eaae19d9f790e5ce706f2249a96c582f2ea74fc75f0f0d3dddbcbec8192b464eae6e3f

a287f77f414644ce6d1ce101486999af0a0dde5f5017314d27922350888a48d7355ac0c2d20215b12d0f4e743a4fcce8

aa3ad2f578cd54daceccf6e065ae0af32d7b2173a67b2394d08203c64277dfe3d1778782a7834364a22ad1dc6002d773

ab19bd40525e36bb4e132378e0596f21b32d7455de969862f3a48864eb9e2dd4c1e8bc903ceea686861b1dc0280b0b15

91230b37837e5df457ff32eb129fbc5fd31de7af88cb4263b545f998a23294b073d92458be7639b6c867f4e340c209d5

9594346850ba101da9f94b9856bba3843c959d22e8d6d58c3ad8b25c9a2209945ca73cdf9ce6fd51478ecc1377bdad05

5.2.1.2.  Key Pair

   Following the procedure defined in Section 3.3.1 with an input IKM
   value as follows

   0cf3cc44220fdb2f8ca701f8686ed7e9a32db440edc15a9b62222905d8c7bba3

   Outputs the following SK value

   5fb7e74b515a7ecd39e8b38df0eaa66e3630ec90c4df496f67ee7a2737dcb321

   Following the procedure defined in Section 3.3.2 with an input SK
   value as above produces the following PK value

8e146f42de0bf1754692788a4692eeed788f9555837fd208bd6d207affc12916fe25615d5afe2e386984dded54b0bd0809a82bfcd93795a85ee00f5857294cc06391fc049d0b7ea4d1d7ce65548199429dbdb0bf0946f6123daf3454c39bcae4

5.2.1.3.  Valid Single Message Signature

   Using the following message

   9872ad089e452c7b6e283dfac2a80d58e8d0ff71cc4d5e310a1debdda4a45f02

   Along with the SK value as defined in Section 5.2.1.2 as inputs into
   the Sign operations, yields the following output signature

aacb0e0ccc477de9408ec18810b508abccb975e2c8099ea93ba28bf66c836ac31189097446c5c5b67d6aa6aa1a5e01a45d2ee5348010e06d0e9ce7c0737e0e2cd40f270d3fec47e85f6900bce168c0701b87c0afae739823481f3de17823587bec26d5716a3d893a24d996396eca139e

5.2.1.4.  Valid Multi-Message Signature

   Using the following messages (*Note* the ordering of the messages
   MUST be preserved)

9872ad089e452c7b6e283dfac2a80d58e8d0ff71cc4d5e310a1debdda4a45f02

38376138626436353664343965653037623831313065316438666434663164636566366662396263333638633439326439626338633466393861373339616336

39363031323039366164646133663133646434616462653465656134383161346334623537313739333262373362303065333138303764336335383934623930

61633535666233336137353930396564616338393934383239623235303737393239386161373564363933323461333635373333663136633333336661393433

64313833646463366532363635616134653266303838616639323937623738633064323262343239303237336462363337656433336666356366373033313531

35313561653135336532326161653034616431366637353965303732333762343330323263623163656434633137366530393939633661386261353831376363

34393636393437373463353630346162316232353434656162616263663066353332373866663530343063316537376338313136353665383232303431376132

37376665393765623937613165626532653831653465333539376133656537343061363665396566323431323437326332333336343536383532336638623931

37333732653964616135656433316536636435633832356561633162383535653834343736613164393439333261613334386530376237333230393132343136

63333434313336643961623032646134646435393038626262613931336165366635386332636338343462383032613666383131663566623037356639623830

   Along with the SK value as defined in Section 5.2.1.2 as inputs into
   the Sign operations, yields the following output signature

89f61a400283385ab6d6233e9a7c4659e1822e280d4b9a0ba9ec867faa59a4ff27f44d956a3f2e297236342d7419a4c758385744297a55459c3a18c5ed76601e0c2226da1a95df39f9be2bbf2311b46859482c85ba0b109d5fa9b7cbaf90f9b8bc78f506666c9e64f14490441669ccc5

6.  IANA Considerations

   This document does not make any requests of IANA.

7.  Normative References

   [I-D.irtf-cfrg-hash-to-curve]
              Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,
              and C. A. Wood, "Hashing to Elliptic Curves", Work in
              Progress, Internet-Draft, draft-irtf-cfrg-hash-to-curve-
              14, 18 February 2022,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              hash-to-curve-14>.

   [I-D.irtf-cfrg-pairing-friendly-curves]
              Sakemi, Y., Kobayashi, T., Saito, T., and R. S. Wahby,
              "Pairing-Friendly Curves", Work in Progress, Internet-
              Draft, draft-irtf-cfrg-pairing-friendly-curves-10, 30 July
              2021, <https://datatracker.ietf.org/doc/html/draft-irtf-
              cfrg-pairing-friendly-curves-10>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC4868]  Kelly, S. and S. Frankel, "Using HMAC-SHA-256, HMAC-SHA-
              384, and HMAC-SHA-512 with IPsec", RFC 4868,
              DOI 10.17487/RFC4868, May 2007,
              <https://www.rfc-editor.org/info/rfc4868>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/info/rfc5869>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [SHA3]     NIST, "Recommendation for Stateful Hash-Based Signature
              Schemes",
              <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/
              NIST.SP.800-208.pdf>.

8.  Informative References

   [I-D.irtf-cfrg-bls-signature]
              Boneh, D., Gorbunov, S., Wahby, R. S., Wee, H., and Z.
              Zhang, "BLS Signatures", Work in Progress, Internet-Draft,
              draft-irtf-cfrg-bls-signature-04, 10 September 2020,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              bls-signature-04>.

Appendix A.  Appendix

A.1.  BLS12-381 hash_to_curve definition using SHAKE-256

   The following defines a hash_to_curve suite
   [I-D.irtf-cfrg-hash-to-curve] for the BLS12-381 curve for both the G1
   and G2 subgroups using the extendable output function (XOF) of
   SHAKE-256 as per the guidance defined in section 8.9 of
   [I-D.irtf-cfrg-hash-to-curve].

   Note the notation used in the below definitions is sourced from
   [I-D.irtf-cfrg-hash-to-curve].

A.1.1.  BLS12-381 G1

   The suite of BLS12381G1_XOF:SHAKE-256_SSWU_R0_ is defined as follows:

* encoding type: hash_to_curve (Section 3 of [@!I-D.irtf-cfrg-hash-to-curve])

* E: y^2 = x^3 + 4

* p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab

* m: 1

* k: 128

* expand_message: expand_message_xof (Section 5.4.2 of [@!I-D.irtf-cfrg-hash-to-curve])

* H: SHAKE-256

* L: 64

* f: Simplified SWU for AB == 0 (Section 6.6.3 of [@!I-D.irtf-cfrg-hash-to-curve])

* Z: 11

*  E': y'^2 = x'^3 + A' * x' + B', where

      -  A' = 0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aef
         d881ac98936f8da0e0f97f5cf428082d584c1d

      -  B' = 0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14f
         cef35ef55a23215a316ceaa5d1cc48e98e172be0

*  iso_map: the 11-isogeny map from E' to E given in Appendix E.2 of [@!I-D.irtf-cfrg-hash-to-curve]

*  h_eff: 0xd201000000010001

   Note that the h_eff values for this suite are copied from that
   defined for the BLS12381G1_XMD:SHA-256_SSWU_RO_ suite defined in
   section 8.8.1 of [I-D.irtf-cfrg-hash-to-curve].

   An optimized example implementation of the Simplified SWU mapping to
   the curve E' isogenous to BLS12-381 G1 is given in Appendix F.2
   [I-D.irtf-cfrg-hash-to-curve].

A.1.2.  BLS12-381 G2

   The suite of BLS12381G2_XOF:SHAKE-256_SSWU_R0_ is defined as follows:

* encoding type: hash_to_curve (Section 3 of [@!I-D.irtf-cfrg-hash-to-curve])

* E: y^2 = x^3 + 4 * (1 + I)

* base field F is GF(p^m), where

  -  p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6
         b0f6241eabfffeb153ffffb9feffffffffaaab

  -  m: 2

  -  (1, I) is the basis for F, where I^2 + 1 == 0 in F

* k: 128

* expand_message: expand_message_xof (Section 5.4.2 of [@!I-D.irtf-cfrg-hash-to-curve])

* H: SHAKE-256

* L: 64

* f: Simplified SWU for AB == 0 (Section 6.6.3 of [@!I-D.irtf-cfrg-hash-to-curve])

* Z: -(2 + I)

*  E': y'^2 = x'^3 + A' * x' + B', where

      -  A' = 240 * I

      -  B' = 1012 * (1 + I)

*  iso_map: the isogeny map from E' to E given in Appendix E.3 of [@!I-D.irtf-cfrg-hash-to-curve]

*  h_eff: 0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff0315
  08ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689
  f6a359894c0adebbf6b4e8020005aaa95551

   Note that the h_eff values for this suite are copied from that
   defined for the BLS12381G2_XMD:SHA-256_SSWU_RO_ suite defined in
   section 8.8.1 of [I-D.irtf-cfrg-hash-to-curve].

   An optimized example implementation of the Simplified SWU mapping to
   the curve E' isogenous to BLS12-381 G2 is given in Appendix F.2
   [I-D.irtf-cfrg-hash-to-curve].

A.2.  Usecases

A.2.1.  Non-correlating Security Token

   In the most general sense BBS signatures can be used in any
   application where a cryptographically secured token is required but
   correlation caused by usage of the token is un-desirable.

   For example in protocols like OAuth2.0 the most commonly used form of
   the access token leverages the JWT format alongside conventional
   cryptographic primitives such as traditional digital signatures or
   HMACs.  These access tokens are then used by a relying party to prove
   authority to a resource server during a request.  However, because
   the access token is most commonly sent by value as it was issued by
   the authorization server (e.g in a bearer style scheme), the access
   token can act as a source of strong correlation for the relying
   party.  Relevant prior art can be found here
   (https://www.ietf.org/archive/id/draft-private-access-tokens-
   01.html).

   BBS Signatures due to their unique properties removes this source of
   correlation but maintains the same set of guarantees required by a
   resource server to validate an access token back to its relevant
   authority (note that an approach to signing JSON tokens with BBS that
   may be of relevance is the JWP (https://json-web-proofs.github.io/
   json-web-proofs/draft-jmiller-json-web-proof.html) format and
   serialization).  In the context of a protocol like OAuth2.0 the
   access token issued by the authorization server would feature a BBS
   Signature, however instead of the relying party providing this access
   token as issued, in their request to a resource server, they derive a
   unique proof from the original access token and include that in the
   request instead, thus removing this vector of correlation.

A.2.2.  Improved Bearer Security Token

   Bearer based security tokens such as JWT based access tokens used in
   the OAuth2.0 protocol are a highly popular format for expressing
   authorization grants.  However their usage has several security
   limitations.  Notably a bearer based authorization scheme often has
   to rely on a secure transport between the authorized party (client)
   and the resource server to mitigate the potential for a MITM attack
   or a malicious interception of the access token.  The scheme also has
   to assume a degree of trust in the resource server it is presenting
   an access token to, particularly when the access token grants more
   than just access to the target resource server, because in a bearer
   based authorization scheme, anyone who possesses the access token has
   authority to what it grants.  Bearer based access tokens also suffer
   from the threat of replay attacks.

   Improved schemes around authorization protocols often involve adding
   a layer of proof of cryptographic key possession to the presentation
   of an access token, which mitigates the deficiencies highlighted
   above as well as providing a way to detect a replay attack.  However,
   approaches that involve proof of cryptographic key possession such as
   DPoP (https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-04
   (https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-04))
   suffer from an increase in protocol complexity.  A party requesting
   authorization must pre-generate appropriate key material, share the
   public portion of this with the authorization server alongside
   proving possession of the private portion of the key material.  The
   authorization server must also be-able to accommodate receiving this
   information and validating it.

   BBS Signatures ofter an alternative model that solves the same
   problems that proof of cryptographic key possession schemes do for
   bearer based schemes, but in a way that doesn't introduce new up-
   front protocol complexity.  In the context of a protocol like
   OAuth2.0 the access token issued by the authorization server would
   feature a BBS Signature, however instead of the relying party
   providing this access token as issued, in their request to a resource
   server, they derive a unique proof from the original access token and
   include that in the request instead.  Because the access token is not
   shared in a request to a resource server, attacks such as MITM are
   mitigated.  A resource server also obtains the ability to detect a
   replay attack by ensuring the proof presented is unique.

A.2.3.  Hardware Attestations

   TODO

A.2.4.  Selectively Disclosure Enabled Identity Assertions

   TODO

A.2.5.  Privacy preserving bound signatures

   TODO

A.3.  Additional BLS12-381 Ciphersuite Test Vectors

   *NOTE* These fixtures are a work in progress and subject to change

A.3.1.  Modified Message Signature

   Using the following message

63333434313336643961623032646134646435393038626262613931336165366635386332636338343462383032613666383131663566623037356639623830

   And the following signature

aacb0e0ccc477de9408ec18810b508abccb975e2c8099ea93ba28bf66c836ac31189097446c5c5b67d6aa6aa1a5e01a45d2ee5348010e06d0e9ce7c0737e0e2cd40f270d3fec47e85f6900bce168c0701b87c0afae739823481f3de17823587bec26d5716a3d893a24d996396eca139e

   Along with the PK value as defined in Section 5.2.1.2 as inputs into
   the Verify operation should fail signature validation due to the
   message value being different from what was signed

A.3.2.  Extra Unsigned Message Signature

   Using the following messages

9872ad089e452c7b6e283dfac2a80d58e8d0ff71cc4d5e310a1debdda4a45f02

63333434313336643961623032646134646435393038626262613931336165366635386332636338343462383032613666383131663566623037356639623830

   And the following signature

aacb0e0ccc477de9408ec18810b508abccb975e2c8099ea93ba28bf66c836ac31189097446c5c5b67d6aa6aa1a5e01a45d2ee5348010e06d0e9ce7c0737e0e2cd40f270d3fec47e85f6900bce168c0701b87c0afae739823481f3de17823587bec26d5716a3d893a24d996396eca139e

   Along with the PK value as defined in Section 5.2.1.2 as inputs into
   the Verify operation should fail signature validation due to an
   additional message being supplied that was not signed

A.3.3.  Missing Message Signature

   Using the following messages

9872ad089e452c7b6e283dfac2a80d58e8d0ff71cc4d5e310a1debdda4a45f02

38376138626436353664343965653037623831313065316438666434663164636566366662396263333638633439326439626338633466393861373339616336

   And the following signature

89f61a400283385ab6d6233e9a7c4659e1822e280d4b9a0ba9ec867faa59a4ff27f44d956a3f2e297236342d7419a4c758385744297a55459c3a18c5ed76601e0c2226da1a95df39f9be2bbf2311b46859482c85ba0b109d5fa9b7cbaf90f9b8bc78f506666c9e64f14490441669ccc5

   Along with the PK value as defined in Section 5.2.1.2 as inputs into
   the Verify operation should fail signature validation due to missing
   messages that were originally present during the signing

A.3.4.  Reordered Message Signature

   Using the following messages

63333434313336643961623032646134646435393038626262613931336165366635386332636338343462383032613666383131663566623037356639623830

37333732653964616135656433316536636435633832356561633162383535653834343736613164393439333261613334386530376237333230393132343136

37376665393765623937613165626532653831653465333539376133656537343061363665396566323431323437326332333336343536383532336638623931

34393636393437373463353630346162316232353434656162616263663066353332373866663530343063316537376338313136353665383232303431376132

35313561653135336532326161653034616431366637353965303732333762343330323263623163656434633137366530393939633661386261353831376363

64313833646463366532363635616134653266303838616639323937623738633064323262343239303237336462363337656433336666356366373033313531

61633535666233336137353930396564616338393934383239623235303737393239386161373564363933323461333635373333663136633333336661393433

39363031323039366164646133663133646434616462653465656134383161346334623537313739333262373362303065333138303764336335383934623930

38376138626436353664343965653037623831313065316438666434663164636566366662396263333638633439326439626338633466393861373339616336

9872ad089e452c7b6e283dfac2a80d58e8d0ff71cc4d5e310a1debdda4a45f02

   And the following signature

89f61a400283385ab6d6233e9a7c4659e1822e280d4b9a0ba9ec867faa59a4ff27f44d956a3f2e297236342d7419a4c758385744297a55459c3a18c5ed76601e0c2226da1a95df39f9be2bbf2311b46859482c85ba0b109d5fa9b7cbaf90f9b8bc78f506666c9e64f14490441669ccc5

   Along with the PK value as defined in Section 5.2.1.2 as inputs into
   the Verify operation should fail signature validation due to messages
   being re-ordered from the order in which they were signed

A.3.5.  Wrong Public Key Signature

   Using the following messages

63333434313336643961623032646134646435393038626262613931336165366635386332636338343462383032613666383131663566623037356639623830

37333732653964616135656433316536636435633832356561633162383535653834343736613164393439333261613334386530376237333230393132343136

37376665393765623937613165626532653831653465333539376133656537343061363665396566323431323437326332333336343536383532336638623931

34393636393437373463353630346162316232353434656162616263663066353332373866663530343063316537376338313136353665383232303431376132

35313561653135336532326161653034616431366637353965303732333762343330323263623163656434633137366530393939633661386261353831376363

64313833646463366532363635616134653266303838616639323937623738633064323262343239303237336462363337656433336666356366373033313531

61633535666233336137353930396564616338393934383239623235303737393239386161373564363933323461333635373333663136633333336661393433

39363031323039366164646133663133646434616462653465656134383161346334623537313739333262373362303065333138303764336335383934623930

38376138626436353664343965653037623831313065316438666434663164636566366662396263333638633439326439626338633466393861373339616336

9872ad089e452c7b6e283dfac2a80d58e8d0ff71cc4d5e310a1debdda4a45f02

   And the following signature

89f61a400283385ab6d6233e9a7c4659e1822e280d4b9a0ba9ec867faa59a4ff27f44d956a3f2e297236342d7419a4c758385744297a55459c3a18c5ed76601e0c2226da1a95df39f9be2bbf2311b46859482c85ba0b109d5fa9b7cbaf90f9b8bc78f506666c9e64f14490441669ccc5

   Along with the PK value as defined in Section 5.2.1.2 as inputs into
   the Verify operation should fail signature validation due to public
   key used to verify is in-correct

Authors' Addresses

   Mike Lodder
   CryptID
   Email: redmike7gmail.com


   Tobias Looker
   Mattr
   Email: tobias.looker@mattr.global


   Andrew Whitehead
   Email: cywolf@gmail.com
